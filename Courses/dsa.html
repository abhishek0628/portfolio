<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data Type</title>
    <style>
       body {
    font-family: "Segoe UI", Roboto, Arial, sans-serif;
    background: #ffffff; /* white background */
    color: #000000;      /* black text */
    margin: 0;
    padding: 20px;
    line-height: 1.7;
}

/* Container */
.container {
    max-width: 1000px;
    margin: auto;
    padding: 40px;
}

/* Headings */
h1, h2, h3 {
    color: #000000; /* black headings */
    margin-top: 30px;
}

h1 {
    font-size: 2.5rem;
    border-bottom: 2px solid #000000;
    padding-bottom: 10px;
}

h2 {
    font-size: 1.9rem;
}

h3 {
    font-size: 1.4rem;
    color: #000000;
}

/* Paragraphs and lists */
p {
    font-size: 1.05rem;
    margin: 15px 0;
}

ul, ol {
    margin-left: 25px;
    margin-bottom: 15px;
}

li {
    margin: 8px 0;
}

/* Boxes for examples or notes */
.box, .example {
    background: #f0f0f0; /* light gray background */
    border-left: 5px solid #000000;
    padding: 20px;
    margin: 25px 0;
    border-radius: 6px;
    color: #000000;
}

/* Code and diagram blocks */
.diagram, .code, pre {
    background: #e5e5e5; /* slightly darker gray for code/diagrams */
    padding: 20px;
    font-family: "Courier New", monospace;
    white-space: pre;
    border-radius: 6px;
    margin: 20px 0;
    color: #000000;
    overflow-x: auto;
}

code {
    font-family: monospace;
    background-color: #f4f4f4;
    padding: 2px 4px;
    border-radius: 4px;
    color: #000000;
}

/* Tables */
table {
    width: 100%;
    border-collapse: collapse;
    margin: 20px 0;
}

table th, table td {
    border: 1px solid #cccccc;
    padding: 10px;
    text-align: left;
    color: #000000;
}

table th {
    background: #e0e0e0;
    color: #000000;
}

/* Highlighted text */
.highlight {
    color: #ff6600; /* orange for highlights */
}

/* Footer */
footer {
    text-align: center;
    padding: 20px;
    color: #ffffff;
    background-color: #000000; /* black footer background */
    margin-top: 20px;
}
    </style>
</head>
<body>
    <h1>What is a Data Type?</h1>
    <p>A data type specifies:</p>
    <ul>
        <li>what kind of value a variable can store</li>
        <li>how much memory it needs</li>
        <li>what operations are allowed on it</li>
    </ul>
    <p><strong>In short:</strong> rules so chaos doesn’t win.</p>
    <h1>1. Primitive (Basic) Data Types</h1>

    <h2>1. What is int?</h2>
    <p><strong>int</strong> stands for integer.</p>
    <ul>
        <li>Stores whole numbers, positive, negative, or zero.</li>
        <li>Cannot store decimals, fractions, or funny symbols.</li>
        <li>Basic type in almost all languages: C, C++, Java, Python (sort of), etc.</li>
    </ul>

    <h3>2. Memory and Range</h3>
    <p>The size depends on compiler and platform, but standard assumptions:</p>
    <table>
        <tr>
            <th>Type</th>
            <th>Size (typical)</th>
            <th>Range (signed)</th>
            <th>Range (unsigned)</th>
        </tr>
        <tr>
            <td>int</td>
            <td>4 bytes (32-bit)</td>
            <td>-2,147,483,648 to 2,147,483,647</td>
            <td>0 to 4,294,967,295</td>
        </tr>
        <tr>
            <td>short int</td>
            <td>2 bytes</td>
            <td>-32,768 to 32,767</td>
            <td>0 to 65,535</td>
        </tr>
        <tr>
            <td>long int</td>
            <td>8 bytes (on 64-bit)</td>
            <td>-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807</td>
            <td>0 to 18,446,744,073,709,551,615</td>
        </tr>
    </table>
    <p><strong>Signed vs Unsigned:</strong></p>
    <ul>
        <li>Signed int: Can store negative numbers (default).</li>
        <li>Unsigned int: Only non-negative numbers, doubles the max positive value.</li>
    </ul>

    <h3>3. Declaration and Initialization</h3>
    <pre><code>int a;           // declaration
int b = 10;      // declaration + initialization
unsigned int c;  // only positive numbers
</code></pre>
    <p>You can combine keywords: long int, short int, unsigned int.</p>
    <p>Multiple variables can be declared at once:</p>
    <pre><code>int x, y = 5, z;</code></pre>

    <h3>4. Operations on int</h3>
    <ul>
        <li>Arithmetic: + - * / %</li>
        <li>Comparison: == != &gt; &lt; &gt;= &lt;=</li>
        <li>Bitwise: &amp; | ^ &lt;&lt; &gt;&gt; ~</li>
        <li>Assignment: = += -= *= /= %=</li>
    </ul>
    <pre><code>int x = 10, y = 3;
int sum = x + y;      // 13
int diff = x - y;     // 7
int mod = x % y;      // 1
</code></pre>

    <h3>5. Why int matters</h3>
    <ul>
        <li>Memory-efficient: Stores numbers compactly.</li>
        <li>Fast: Processors handle integers faster than floats or doubles.</li>
        <li>Ubiquitous: Loops, counters, indexes, flags—everything starts with int.</li>
    </ul>

    <h3>6. Common pitfalls</h3>
    <ul>
        <li><strong>Overflow/Underflow</strong>
            <pre><code>int a = 2147483647;
a = a + 1; // overflow → undefined behavior in C
</code></pre>
        </li>
        <li><strong>Mixing signed and unsigned</strong>
            <pre><code>int a = -5;
unsigned int b = 10;
if(a &lt; b) {} // can give unexpected results
</code></pre>
        </li>
        <li><strong>Integer division</strong>
            <pre><code>int x = 7, y = 2;
int z = x / y; // 3, not 3.5
</code></pre>
        </li>
    </ul>

    <h3>Quick memory diagram (4-byte int):</h3>
    <pre><code>Memory (32 bits)
+-------------------------------+
| bit31 | ... | bit1 | bit0      |
+-------------------------------+
| Sign  | Value bits            |
</code></pre>
    <p>bit31 = 0 → positive, 1 → negative (2’s complement)</p>

    <h2>What is a float?</h2>
    <p>float is a primitive data type used to store decimal numbers (numbers with fractional parts) in C, C++, Java, etc.</p>
    <p>It’s also called a single-precision floating-point number. Typically uses 4 bytes (32 bits) of memory.</p>

    <h3>Why Not Just Use Decimal Normally?</h3>
    <p>Because computers don’t have infinite space, they approximate decimal numbers in binary. That’s why 0.1 + 0.2 != 0.3 in most programming languages.</p>

    <h3>Memory Representation of float</h3>
    <p>A float uses the IEEE 754 standard:</p>
    <ul>
        <li>Sign bit (1 bit): 0 = positive, 1 = negative</li>
        <li>Exponent (8 bits): Determines the scale</li>
        <li>Mantissa / Significand (23 bits): Holds the significant digits</li>
    </ul>
    <p>Formula:</p>
    <pre><code>Value = (-1)^sign × 1.mantissa × 2^(exponent-127)</code></pre>

    <p>Example:</p>
    <pre><code>Let float f = 5.75;

Convert 5.75 to binary: 101.11
Normalize: 1.0111 × 2^2
Sign = 0 (positive)
Exponent = 2 + 127 = 129 → 10000001 (in binary)
Mantissa = 01110000000000000000000 (fill 23 bits)
Memory layout:
0 | 10000001 | 01110000000000000000000
</code></pre>

    <h3>Float Characteristics</h3>
    <table>
        <tr><th>Property</th><th>Float</th></tr>
        <tr><td>Size</td><td>4 bytes (32 bits)</td></tr>
        <tr><td>Precision</td><td>~6-7 decimal digits</td></tr>
        <tr><td>Range</td><td>~1.2E-38 to 3.4E38</td></tr>
        <tr><td>Default in C</td><td>float literal needs f suffix (e.g., 3.14f)</td></tr>
    </table>

    <h3>Limitations</h3>
    <ul>
        <li>Precision loss: Only 6–7 digits accurately stored</li>
        <li>Rounding errors: 0.1 + 0.2 ≈ 0.30000001</li>
        <li>Overflow/underflow: Too big → infinity, too small → 0</li>
    </ul>

    <h3>Example in C</h3>
    <pre><code>#include &lt;stdio.h&gt;

int main() {
    float pi = 3.14159265f;
    printf("Value of pi: %.7f\n", pi); // shows 3.1415927 (rounded)
    return 0;
}</code></pre>

    <h2>1. What is double?</h2>
    <p>A primitive data type in C, C++, Java, etc. Stores decimal numbers (floating-point numbers) with double precision. Usually 8 bytes (64 bits) in memory.</p>

    <h3>Memory Layout (IEEE 754 Standard)</h3>
    <p>double uses 64 bits:</p>
    <table>
        <tr><th>Part</th><th>Bits</th><th>Purpose</th></tr>
        <tr><td>Sign</td><td>1</td><td>0 = positive, 1 = negative</td></tr>
        <tr><td>Exponent</td><td>11</td><td>Represents the magnitude, with bias of 1023</td></tr>
        <tr><td>Mantissa (Fraction)</td><td>52</td><td>Represents the significant digits (precision)</td></tr>
    </table>

    <p>Formula:</p>
    <pre><code>Value = (-1)^Sign × 1.Mantissa × 2^(Exponent-1023)</code></pre>

    <h3>Declaration & Initialization</h3>
    <pre><code>double pi = 3.141592653589793;
double balance = 12345.67;
double distance = 1.2e5; // 120000
double smallValue = 5.6e-3; // 0.0056
</code></pre>

    <h3>Operations on double</h3>
    <pre><code>double a = 5.5, b = 2.0;
double sum = a + b;       // 7.5
double diff = a - b;      // 3.5
double product = a * b;   // 11.0
double quotient = a / b;  // 2.75
</code></pre>
    <p>Comparisons (==, &lt;, &gt;) are tricky due to floating-point precision. Use a tolerance:</p>
    <pre><code>if (fabs(a - b) &lt; 0.00001) { /* treat as equal */ }</code></pre>

    <h3>When to Use double?</h3>
    <ul>
        <li>When precision matters: scientific calculations, financial apps, engineering computations.</li>
        <li>When float might round off too much.</li>
        <li>Don’t use for exact values like money in currency systems (better to use integers or fixed-point arithmetic).</li>
    </ul>

    <h3>float vs double at a Glance</h3>
    <table>
        <tr><th>Feature</th><th>float</th><th>double</th></tr>
        <tr><td>Size</td><td>4 bytes</td><td>8 bytes</td></tr>
        <tr><td>Precision</td><td>~7 digits</td><td>~15-16 digits</td></tr>
        <tr><td>Range</td><td>~10⁻³⁸ to 10³⁸</td><td>~10⁻³⁰⁸ to 10³⁰⁸</td></tr>
        <tr><td>Suffix</td><td>f</td><td>optional (or l for long double)</td></tr>
    </table>

    <h2>1. What is char?</h2>
    <p><strong>char</strong> (short for character) is a basic data type used to store single characters.</p>
    <ul>
        <li>Size: Typically 1 byte (8 bits)</li>
        <li>Range: Signed char: -128 to 127, Unsigned char: 0 to 255</li>
    </ul>
    <p>Internally, a char stores a numeric ASCII value. The character itself is just a human-readable representation.</p>

    <h3>Example:</h3>
    <pre><code>char ch = 'A'; // Stores ASCII 65
printf("%c %d", ch, ch); // Output: A 65</code></pre>

    <h3>Declaration & Initialization</h3>
    <pre><code>char grade = 'B';       // Single character
char newline = '\n';    // Escape character
char letters[] = "Hello"; // String (array of chars)</code></pre>

    <p>Rules:</p>
    <ul>
        <li>Use single quotes for a single character ('A').</li>
        <li>Double quotes create a string ("A" → array of chars).</li>
    </ul>

    <h3>ASCII & Storage</h3>
    <table>
        <tr><th>Char</th><th>ASCII</th><th>Char</th><th>ASCII</th></tr>
        <tr><td>A</td><td>65</td><td>a</td><td>97</td></tr>
        <tr><td>0</td><td>48</td><td>9</td><td>57</td></tr>
        <tr><td>\n</td><td>10</td><td>\t</td><td>9</td></tr>
    </table>

    <p>You can do arithmetic with chars:</p>
    <pre><code>char c = 'A';
c = c + 1; // Now 'B' (66)</code></pre>

    <h3>Signed vs Unsigned</h3>
    <pre><code>signed char a = -50;
unsigned char b = 200;</code></pre>

    <h3>Special Characters (Escape Sequences)</h3>
    <ul>
        <li>\n → newline</li>
        <li>\t → tab</li>
        <li>\\ → backslash</li>
        <li>\' → single quote</li>
        <li>\" → double quote</li>
        <li>\0 → null character (string terminator)</li>
    </ul>
    <p>Strings in C always end with \0.</p>

    <h3>Char Arrays and Strings</h3>
    <pre><code>char name[6] = "Abhis"; // 5 chars + 1 null
printf("%c", name[0]); // A</code></pre>

    <h3>Operations on char</h3>
    <ul>
        <li>Comparison: if(ch == 'A')</li>
        <li>Arithmetic: ch + 1, ch - 32 (case conversion)</li>
        <li>Input/Output: 
            <pre><code>char ch;
scanf("%c", &ch);
printf("%c", ch);</code></pre>
        </li>
    </ul>

    <h3>Memory and Efficiency</h3>
    <p>char is ideal when memory is tight. Can be used for bitwise operations, flags, or raw byte storage.</p>

    <h2>What is void?</h2>
    <p>In C/C++ (and similar languages), <strong>void</strong> is a special data type that represents no value. It tells the compiler: there is nothing here, deal with it.</p>

    <h3>Uses of void</h3>
    <h4>1. Void Functions</h4>
    <pre><code>void greet() {
    printf("Hello, World!\n");
}</code></pre>
    <p>Return type is void. You cannot assign its return to a variable:</p>
    <pre><code>int x = greet(); // ❌ Error</code></pre>
    <p>Used when a function’s purpose is side effects (printing, modifying global variables, etc.).</p>

    <h4>2. Void Pointers (void*)</h4>
    <pre><code>int num = 10;
float f = 3.14;

void *ptr;
ptr = &num; // ok
ptr = &f;   // ok

int *p = (int*)ptr;
printf("%d", *p);</code></pre>
    <p>Useful for writing generic functions, e.g., memory allocation:</p>
    <pre><code>void* malloc(size_t size);</code></pre>

    <h4>3. Void in Function Parameters</h4>
    <pre><code>int sum(void) {
    return 0;
}</code></pre>
    <p>In C, () alone also works, but void makes it clear there are no parameters.</p>

    <h4>4. Void as an Expression Result</h4>
    <pre><code>(void)printf("Hello\n"); // ignoring the int returned by printf</code></pre>
    <p>Handy to suppress compiler warnings.</p>

    <h3>Quick Summary Table</h3>
    <table>
        <tr><th>Usage</th><th>Meaning</th><th>Example</th></tr>
        <tr><td>Function return</td><td>Nothing is returned</td><td>void greet()</td></tr>
        <tr><td>Function params</td><td>No parameters accepted</td><td>int sum(void)</td></tr>
        <tr><td>Pointer type</td><td>Generic pointer</td><td>void *ptr</td></tr>
        <tr><td>Cast expression</td><td>Ignore result</td><td>(void)func();</td></tr>
    </table>

    <h3>Conceptual Tip</h3>
    <ul>
        <li>A function returning void → returns nothing</li>
        <li>A pointer of type void* → points to something, but you don’t know what yet</li>
        <li>It’s basically a placeholder for nothingness that still matters.</li>
    </ul>
    <h1>2. Derived Data Types</h1>

    <h2>1. What is an Array?</h2>
    <p>An array is a collection of elements of the same data type, stored contiguously in memory.</p>
    <p>“Contiguous” means no sneaky gaps between elements.</p>
    <p>Each element can be accessed using an index, usually starting from 0.</p>

    <h3>Syntax in C:</h3>
    <pre><code>data_type array_name[size];
int numbers[5]; // stores 5 integers</code></pre>

    <h2>2. Characteristics of Arrays</h2>
    <ul>
        <li>Fixed size (in C/C++): Once declared, cannot grow or shrink.</li>
        <li>Homogeneous elements: All elements must be of the same type.</li>
        <li>Random access: Can directly access any element using index → <code>arr[i]</code>.</li>
        <li>Stored contiguously → memory efficiency, cache-friendly.</li>
    </ul>

    <h2>3. Memory Representation</h2>
    <p>For example:</p>
    <pre><code>int arr[5] = {10, 20, 30, 40, 50};</code></pre>

    <p>Memory layout (assuming each int = 4 bytes):</p>
    <table>
        <tr>
            <th>Index</th>
            <td>0</td>
            <td>1</td>
            <td>2</td>
            <td>3</td>
            <td>4</td>
        </tr>
        <tr>
            <th>Value</th>
            <td>10</td>
            <td>20</td>
            <td>30</td>
            <td>40</td>
            <td>50</td>
        </tr>
        <tr>
            <th>Address</th>
            <td>1000</td>
            <td>1004</td>
            <td>1008</td>
            <td>1012</td>
            <td>1016</td>
        </tr>
    </table>
    <p>Address of element <code>arr[i]</code> = base_address + i * size_of_element</p>

    <h2>4. Types of Arrays</h2>
    <h3>One-dimensional (1D)</h3>
    <p>Linear list of elements.</p>
    <pre><code>int marks[5] = {90, 80, 85, 70, 95};</code></pre>

    <h3>Two-dimensional (2D)</h3>
    <p>Like a table or matrix.</p>
    <pre><code>int matrix[3][3] = {
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9}
};</code></pre>
    <p>Row-major order: stored row by row in memory.</p>

    <h3>Multi-dimensional</h3>
    <p>3D or more (rarely used except in graphics, physics simulations).</p>

    <h2>5. Array Operations</h2>
    <table>
        <tr>
            <th>Operation</th>
            <th>How</th>
        </tr>
        <tr>
            <td>Traversal</td>
            <td>Access each element using loop (for, while)</td>
        </tr>
        <tr>
            <td>Insertion</td>
            <td>Shift elements to make space (costly in 1D arrays)</td>
        </tr>
        <tr>
            <td>Deletion</td>
            <td>Shift elements to fill gap (costly)</td>
        </tr>
        <tr>
            <td>Searching</td>
            <td>Linear search O(n), Binary search O(log n) if sorted</td>
        </tr>
        <tr>
            <td>Updating</td>
            <td>Direct access → <code>arr[index] = value;</code></td>
        </tr>
    </table>

    <h2>6. Advantages</h2>
    <ul>
        <li>Simple and easy to use</li>
        <li>Direct access using index → O(1) read</li>
        <li>Good for static datasets</li>
    </ul>

    <h2>7. Disadvantages</h2>
    <ul>
        <li>Fixed size → no dynamic growth</li>
        <li>Insertion/deletion costly → O(n) if not at end</li>
        <li>Homogeneous → cannot mix types</li>
    </ul>

    <h2>8. Real-world Example</h2>
    <p>Think of an exam hall seating chart:</p>
    <ul>
        <li>Each seat has a number (index)</li>
        <li>Each seat holds exactly one student (homogeneous)</li>
        <li>Can directly ask, “Who’s at seat 10?” → instant access</li>
    </ul>
    <h1>What is a Pointer?</h1>
    <p>A pointer is a variable that stores the memory address of another variable instead of a direct value.</p>
    <p>Think of it like this:</p>
    <ul>
        <li><strong>Normal variable</strong> → has a value (<code>int x = 10;</code>)</li>
        <li><strong>Pointer</strong> → has the address of that value (<code>int *p = &x;</code>)</li>
    </ul>

    <h2>Why Pointers Exist</h2>
    <ul>
        <li>Dynamic memory allocation (<code>malloc</code>, <code>calloc</code>, <code>free</code>)</li>
        <li>Pass large structures/arrays to functions without copying</li>
        <li>Build complex data structures (linked lists, trees, graphs)</li>
        <li>Function pointers for callbacks</li>
        <li>Low-level memory manipulation</li>
    </ul>

    <h2>Pointer Syntax in C</h2>
    <pre><code>int a = 10;     // normal variable
int *p = &a;    // pointer to int, stores address of a

*p → dereference (access value at address)
&a → address-of operator (gets the memory address of a)</code></pre>

    <h2>Pointer Types</h2>
    <ul>
        <li><strong>Null Pointer:</strong> Points to nothing
            <pre><code>int *p = NULL;</code></pre>
        </li>
        <li><strong>Void Pointer:</strong> Generic pointer, can point to any type
            <pre><code>void *ptr;</code></pre>
        </li>
        <li><strong>Dangling Pointer:</strong> Points to freed/deleted memory (dangerous!)</li>
        <li><strong>Wild Pointer:</strong> Uninitialized pointer (even more dangerous!)</li>
        <li><strong>Function Pointer:</strong> Points to a function
            <pre><code>int (*funcPtr)(int, int) = &add;</code></pre>
        </li>
        <li><strong>Pointer to Pointer:</strong> Stores the address of another pointer
            <pre><code>int **pp;</code></pre>
        </li>
    </ul>

    <h2>Pointer Arithmetic</h2>
    <p>Since pointers know the type they point to, arithmetic moves by size of the type:</p>
    <pre><code>int arr[5] = {10,20,30,40,50};
int *p = arr; // points to arr[0]

p++; // now points to arr[1]

p + 1 → next int (4 bytes ahead if int = 4 bytes)
p - 1 → previous int</code></pre>

    <h2>Pointers and Arrays</h2>
    <pre><code>int arr[3] = {1,2,3};
int *p = arr; // p points to arr[0]

printf("%d", *(p+2)); // prints 3</code></pre>

    <h2>Pointers and Functions</h2>
    <h3>Pass by Address</h3>
    <pre><code>void increment(int *x) {
    (*x)++;
}

int main() {
    int a = 5;
    increment(&a);
    // a becomes 6
}</code></pre>

    <h3>Return by Pointer</h3>
    <p>Can return dynamically allocated memory or array.</p>

    <h2>Pointers and Structures</h2>
    <pre><code>struct Student {
    int id;
    float marks;
};

struct Student s1 = {101, 95.5};
struct Student *ptr = &s1;

printf("%d", ptr->id); // Access using arrow operator

(*ptr).id also works, but arrow is cleaner</code></pre>

    <h2>Dynamic Memory Allocation</h2>
    <pre><code>int *p = (int*)malloc(sizeof(int)); // allocate memory
*p = 100;
free(p); // release memory</code></pre>
    <p>Always free dynamically allocated memory to avoid leaks.</p>

    <h2>Common Mistakes</h2>
    <ul>
        <li>Dereferencing NULL or uninitialized pointers → crash</li>
        <li>Forgetting <code>*</code> when dereferencing → logic errors</li>
        <li>Forgetting <code>free()</code> → memory leaks</li>
        <li>Pointer arithmetic out of bounds → undefined behavior</li>
    </ul>
    <h1>1. What is a Function?</h1>
<p>A function is a block of code designed to perform a specific task. Instead of rewriting code, you call the function whenever needed.</p>
<p>Think of it as a machine in a factory: you give it input, it does work, and returns output.</p>
<p>General idea:</p>
<pre>
return_type function_name(parameters) {
    // body
    return value; // optional
}
</pre>

<h2>2. Advantages of Using Functions</h2>
<ul>
    <li>Reusability: Write once, use many times.</li>
    <li>Modularity: Break a program into logical pieces.</li>
    <li>Readability: Makes code organized and understandable.</li>
    <li>Maintainability: Change in one function, changes everywhere it’s used.</li>
    <li>Debugging ease: Problems are easier to isolate.</li>
</ul>

<h2>3. Components of a Function</h2>
<ul>
    <li><strong>Function Name</strong> – identifier to call the function.</li>
    <li><strong>Return Type</strong> – data type of value returned. If none, use void.</li>
    <li><strong>Parameters (Input)</strong> – values passed to the function. Optional.</li>
    <li><strong>Body</strong> – set of statements performing the task.</li>
    <li><strong>Return Statement</strong> – sends value back. Optional if void.</li>
</ul>

<h3>Example:</h3>
<pre>
int add(int a, int b) {
    int sum = a + b;
    return sum;
}

// int → return type
// add → function name
// int a, int b → parameters
// return sum; → output

int result = add(5, 3); // result = 8
</pre>

<h1>4. Types of Functions (C/C++)</h1>

<h2>4.1 Built-in Functions</h2>
<p>A built-in function is a function that is already defined in the programming language or its standard library. You can use it directly after including the appropriate header (in C/C++) or importing the module (in Python).</p>
<ul>
    <li>Already implemented</li>
    <li>Optimized for performance</li>
    <li>Easy to use</li>
    <li>Saves coding time</li>
</ul>

<h3>Examples in C/C++</h3>

<h4>A. Input/Output Functions</h4>
<p>printf() → prints text or numbers to console</p>
<p>scanf() → reads input from user</p>
<pre>
#include &lt;stdio.h&gt;
int main() {
    int x;
    printf("Enter a number: ");
    scanf("%d", &x);
    printf("You entered %d\n", x);
    return 0;
}
</pre>

<h4>B. Math Functions (from &lt;math.h&gt;)</h4>
<ul>
    <li>sqrt(x) → square root</li>
    <li>pow(x, y) → x raised to power y</li>
    <li>abs(x) → absolute value</li>
</ul>
<pre>
#include &lt;math.h&gt;
double r = sqrt(25); // r = 5
double p = pow(2,3); // p = 8
</pre>

<h4>C. String Functions (from &lt;string.h&gt;)</h4>
<ul>
    <li>strlen(str) → length of string</li>
    <li>strcpy(dest, src) → copy string</li>
    <li>strcmp(str1, str2) → compare strings</li>
</ul>
<pre>
#include &lt;string.h&gt;
char str1[20] = "Hello";
char str2[20];
strcpy(str2, str1); // str2 = "Hello"
int len = strlen(str1); // len = 5
</pre>

<h4>D. Utility Functions</h4>
<ul>
    <li>exit(status) → terminate program</li>
    <li>system("command") → execute OS command</li>
</ul>

<h3>Advantages of Built-in Functions</h3>
<ul>
    <li>Time-saving: Don’t have to write from scratch</li>
    <li>Reliable: Tested and optimized</li>
    <li>Portable: Works across systems (if standard library is available)</li>
    <li>Readable code: Others immediately understand what you’re doing</li>
</ul>

<h2>4.2 User-Defined Functions (UDF)</h2>
<p>A User-Defined Function is a block of code written by the programmer to perform a specific task. You define it once and can call it whenever needed.</p>

<pre>
return_type function_name(parameters) {
    // body
    return value; // optional if void
}
</pre>

<h3>Structure of a User-Defined Function</h3>
<ul>
    <li>Function Name: Identifier to call it.</li>
    <li>Return Type: Type of data it gives back (int, float, void, etc.).</li>
    <li>Parameters (Optional): Inputs to the function.</li>
    <li>Function Body: Statements performing the task.</li>
    <li>Return Statement (Optional): Sends a result back to the caller.</li>
</ul>

<h3>Example:</h3>
<pre>
int multiply(int a, int b) {
    int result = a * b;
    return result;
}

int product = multiply(4, 5); // product = 20
</pre>

<h3>Advantages</h3>
<ul>
    <li>Reusability: Write once, use many times.</li>
    <li>Modularity: Break program into logical pieces.</li>
    <li>Easier Maintenance: Fix in one place, effect everywhere.</li>
    <li>Readability: Programs are cleaner and understandable.</li>
</ul>

<h3>Types of User-Defined Functions</h3>
<table>
    <tr>
        <th>Type</th>
        <th>Returns</th>
        <th>Parameters</th>
        <th>Example</th>
    </tr>
    <tr>
        <td>Type 1</td>
        <td>No</td>
        <td>No</td>
        <td>void greet() { printf("Hello!"); }</td>
    </tr>
    <tr>
        <td>Type 2</td>
        <td>No</td>
        <td>Yes</td>
        <td>void printSquare(int n) { printf("%d", n*n); }</td>
    </tr>
    <tr>
        <td>Type 3</td>
        <td>Yes</td>
        <td>No</td>
        <td>int getFive() { return 5; }</td>
    </tr>
    <tr>
        <td>Type 4</td>
        <td>Yes</td>
        <td>Yes</td>
        <td>int add(int a, int b) { return a+b; }</td>
    </tr>
</table>

<h3>Declaration vs Definition</h3>
<p><strong>Declaration (Prototype):</strong> Tells the compiler a function exists.</p>
<pre>int add(int, int); // declaration</pre>
<p><strong>Definition:</strong> Actual code of the function.</p>
<pre>int add(int a, int b) { return a+b; } // definition</pre>

<h3>Calling User-Defined Functions</h3>

<h4>By Value</h4>
<p>Copies the arguments. Original variables unchanged.</p>
<pre>
void increment(int x) { x++; }
</pre>

<h4>By Reference</h4>
<p>Passes the address. Changes reflect in original variables.</p>
<pre>
void increment(int *x) { (*x)++; }
</pre>

<h2>Recursion in User-Defined Functions</h2>
<p>A UDF can call itself to solve problems recursively.</p>
<pre>
int factorial(int n) {
    if(n==0) return 1;
    return n * factorial(n-1);
}
</pre>

<h2>Scope and Lifetime of Variables</h2>

<h3>1. Scope – Where a variable can be accessed</h3>
<ul>
    <li><strong>Local Scope:</strong> Variable declared inside a function or block. Only accessible inside that function.</li>
    <li><strong>Global Scope:</strong> Declared outside all functions. Accessible by all functions.</li>
    <li><strong>Block Scope:</strong> Variables inside {} braces only exist within that block.</li>
    <li><strong>Function Scope (Labels):</strong> In C, labels for goto have function scope. Rarely used.</li>
</ul>

<h3>2. Lifetime – How long a variable exists in memory</h3>
<ul>
    <li><strong>Automatic (Local) Variables:</strong> Created when function is called, destroyed when it ends.</li>
    <li><strong>Static Variables:</strong> Declared with <code>static</code> keyword inside a function. Retains value across function calls. Lifetime = entire program execution.</li>
    <li><strong>Global Variables:</strong> Lifetime = entire program execution (always in memory).</li>
    <li><strong>Dynamic Variables:</strong> Allocated using malloc()/calloc(). Lifetime = until free() is called.</li>
</ul>

<h3>Textual Diagram – Scope & Lifetime</h3>
<pre>
Program Execution Memory

-------------------------------
Global Memory (Lifetime: entire program)
g (global variable)
-------------------------------
Stack (Automatic / Local Variables)
function() {
    int x;         <-- scope: inside function
                   <-- lifetime: while function runs
}
main() {
    int a;         <-- scope: inside main
                   <-- lifetime: while main runs
}
-------------------------------
Static Memory (Lifetime: entire program)
function() {
    static int s;  <-- scope: inside function
                   <-- lifetime: entire program
}
-------------------------------
Heap (Dynamic Memory)
ptr = malloc(...) <-- lifetime: until free()
</pre>

<h3>Quick Table: Scope vs Lifetime</h3>
<table>
    <tr>
        <th>Variable Type</th>
        <th>Scope</th>
        <th>Lifetime</th>
    </tr>
    <tr>
        <td>Local</td>
        <td>Inside function</td>
        <td>Until function exits</td>
    </tr>
    <tr>
        <td>Static Local</td>
        <td>Inside function</td>
        <td>Entire program</td>
    </tr>
    <tr>
        <td>Global</td>
        <td>Anywhere</td>
        <td>Entire program</td>
    </tr>
    <tr>
        <td>Dynamic</td>
        <td>Pointer access</td>
        <td>Until freed</td>
    </tr>
</table>

<h2>Recursion Details</h2>
<p>A recursive function is a function that calls itself either directly or indirectly to solve a smaller instance of the same problem. Each recursive call should reduce the problem size. Base case is mandatory to stop the recursion.</p>

<h3>Structure of a Recursive Function</h3>
<pre>
return_type function_name(parameters) {
    if(base_condition) {
        return value; // stop recursion
    }
    return function_name(smaller_problem); // recursive call
}
</pre>

<h3>Example: Factorial</h3>
<pre>
#include &lt;stdio.h&gt;

int factorial(int n) {
    if(n == 0)          // base case
        return 1;
    else
        return n * factorial(n-1);  // recursive case
}

int main() {
    int num = 5;
    printf("Factorial of %d = %d\n", num, factorial(num));
    return 0;
}
</pre>

<h3>Execution Flow (Stack)</h3>
<pre>
factorial(5) 
= 5 * factorial(4)
= 5 * (4 * factorial(3))
= 5 * (4 * (3 * factorial(2)))
= 5 * (4 * (3 * (2 * factorial(1))))
= 5 * (4 * (3 * (2 * (1 * factorial(0)))))
= 5 * (4 * (3 * (2 * (1 * 1))))   // base case reached

Now, unwind the stack:
= 5 * (4 * (3 * (2 * 1)))
= 5 * (4 * (3 * 2))
= 5 * (4 * 6)
= 5 * 24
= 120
</pre>

<pre>
Stack Representation (Call Stack)

| factorial(0) | <- base case, returns 1
| factorial(1) | <- waiting for factorial(0)
| factorial(2) | <- waiting for factorial(1)
| factorial(3) | <- waiting for factorial(2)
| factorial(4) | <- waiting for factorial(3)
| factorial(5) | <- waiting for factorial(4)
</pre>

<h3>Key Points</h3>
<ul>
    <li>Every recursion must have a base case.</li>
    <li>Each recursive call reduces problem size.</li>
    <li>Uses stack memory; too deep recursion can cause stack overflow.</li>
    <li>Can often be replaced by loops, but recursion is cleaner for problems like Factorial, Fibonacci, Tree traversals, Backtracking, Divide and Conquer algorithms.</li>
</ul>
<h1>User defined data type</h1>
<h1>What is a struct?</h1>
    <p>A <strong>struct</strong> (short for structure) is a user-defined data type in C/C++ that allows you to group variables of different data types under one name. Think of it as a tiny record or a blueprint for a complex object.</p>
    <p>Unlike arrays, which can hold only one type, structs can hold multiple types together.</p>

    <h2>Syntax</h2>
    <pre>
struct TagName {
    data_type member1;
    data_type member2;
    ...
};
    </pre>
    <ul>
        <li><strong>TagName</strong>: optional name to identify the structure.</li>
        <li><strong>Members</strong>: variables inside the struct.</li>
        <li>Semicolon required at the end.</li>
    </ul>

    <h2>Example</h2>
    <pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

struct Student {
    int id;
    char name[50];
    float marks;
};

int main() {
    struct Student s1;

    s1.id = 101;
    strcpy(s1.name, "Abhishek");
    s1.marks = 92.5;

    printf("ID: %d\nName: %s\nMarks: %.2f\n", s1.id, s1.name, s1.marks);
    return 0;
}
    </pre>

    <h3>Output:</h3>
    <pre>
ID: 101
Name: Abhishek
Marks: 92.50
    </pre>

    <h2>Key Points</h2>

    <h3>Memory Layout</h3>
    <p>Each member is stored contiguously, but padding may be added for alignment.</p>

    <h3>Accessing Members</h3>
    <ul>
        <li>Use <strong>dot operator (.)</strong> for a struct variable.</li>
        <li>Use <strong>arrow operator (->)</strong> for a pointer to struct:
        <pre>
struct Student *ptr = &s1;
printf("%s", ptr-&gt;name);
        </pre>
        </li>
    </ul>

    <h3>Nested Structs</h3>
    <pre>
struct Date {
    int day, month, year;
};

struct Student {
    int id;
    char name[50];
    struct Date dob;
};
    </pre>

    <h3>Arrays of Structs</h3>
    <p>Store multiple “objects”:</p>
    <pre>
struct Student class[30];
class[0].id = 101;
    </pre>

    <h3>Passing Structs to Functions</h3>
    <ul>
        <li>By value: copies entire struct (slow if large)</li>
        <li>By reference (pointer): faster</li>
    </ul>
    <pre>
void printStudent(struct Student s);        // by value
void printStudentPtr(struct Student *s);    // by pointer
    </pre>

    <h3>Typedef for Convenience</h3>
    <pre>
typedef struct Student {
    int id;
    char name[50];
    float marks;
} Student;

Student s2;  // no need to write 'struct'
    </pre>

    <h2>When to Use struct</h2>
    <ul>
        <li>To represent records like students, employees, books, etc.</li>
        <li>When you need a single entity combining multiple data types.</li>
        <li>Useful in file handling, linked lists, trees, etc.</li>
    </ul>
    <h1>Union in C/C++</h1>

    <p>A <strong>union</strong> is a user-defined data type in C/C++ that allows you to store different data types in the same memory location, but only one at a time. Think of it like a single parking spot—only one vehicle fits, but you can park a bike, a car, or a truck—just not simultaneously.</p>

    <h2>Syntax</h2>
    <pre><code>union Data {
    int i;
    float f;
    char c;
};</code></pre>
    <p>Here, <code>i</code>, <code>f</code>, and <code>c</code> all share the same memory space.</p>

    <h2>Memory Layout</h2>
    <pre><code>union Data {
    int i;      // 4 bytes
    float f;    // 4 bytes
    char c;     // 1 byte
};
Total size = 4 bytes (largest member: int or float)</code></pre>

    <p>If you write <code>i = 10;</code> and then <code>f = 3.14;</code>, <code>i</code>'s value is overwritten.</p>

    <div class="memory-diagram">
        Memory (4 bytes)<br>
        +---------+<br>
        |  i/f/c  |<br>
        +---------+
    </div>

    <h2>Why Use a Union?</h2>
    <ul>
        <li><strong>Memory efficiency</strong> – Useful in embedded systems or low-memory environments.</li>
        <li><strong>Variant data types</strong> – When a variable can hold multiple types but not simultaneously.</li>
        <li><strong>Interpreting same memory differently</strong> – Example: type punning in low-level programming.</li>
    </ul>

    <h2>Accessing Union Members</h2>
    <pre><code>#include &lt;stdio.h&gt;

union Data {
    int i;
    float f;
    char c;
};

int main() {
    union Data d;
    
    d.i = 10;
    printf("i = %d\n", d.i);
    
    d.f = 3.14;    // overwrites i
    printf("f = %.2f\n", d.f);
    printf("i = %d\n", d.i);  // undefined behavior
    
    d.c = 'A';     // overwrites f
    printf("c = %c\n", d.c);

    return 0;
}</code></pre>

    <h2>Output (example)</h2>
    <pre><code>i = 10
f = 3.14
i = 1078523331   &lt;- garbage because memory is reused
c = A</code></pre>

    <h2>Key Points</h2>
    <ul>
        <li>Declared like <code>struct</code> but memory is shared.</li>
        <li>Only one member can hold a value at a time.</li>
        <li>Size = size of largest member.</li>
        <li>Can have nested unions.</li>
        <li>Useful for memory-critical applications.</li>
    </ul>
    <h1>Enum in C/C++</h1>

<h2>1. What is an enum?</h2>
<p>An enumeration (<code>enum</code>) is a user-defined data type that consists of a set of named integer constants. Instead of remembering numbers, you give them names.</p>

<p><strong>Example in C:</strong></p>
<pre><code>enum Day { MON, TUE, WED, THU, FRI, SAT, SUN };</code></pre>
<p>Here, <code>MON = 0</code>, <code>TUE = 1</code>, …, <code>SUN = 6</code> by default.</p>

<p>You can assign your own numbers too:</p>
<pre><code>enum Day { MON=1, TUE, WED=5, THU, FRI, SAT, SUN };</code></pre>
<p>Now <code>MON=1</code>, <code>TUE=2</code> (auto), <code>WED=5</code>, <code>THU=6</code>, …</p>

<h2>2. Why use enum?</h2>
<ul>
    <li><strong>Readability:</strong> <code>if(day == MON)</code> is easier than <code>if(day == 0)</code>.</li>
    <li><strong>Maintainability:</strong> Changing numbers is painless.</li>
    <li><strong>Type safety:</strong> Some compilers warn if you mix enums and integers carelessly.</li>
    <li><strong>Debugging:</strong> Named constants are easier to interpret in logs.</li>
</ul>

<h2>3. How to use it</h2>

<h3>Declaration and usage</h3>
<pre><code>#include &lt;stdio.h&gt;

enum Day { MON, TUE, WED, THU, FRI, SAT, SUN };

int main() {
    enum Day today;
    today = WED;

    if(today == WED) {
        printf("Midweek blues!\n");
    }

    printf("Numeric value of today: %d\n", today); // prints 2
    return 0;
}</code></pre>

<h3>Enum with custom values</h3>
<pre><code>enum Status { SUCCESS=0, FAILURE=1, PENDING=100 };

enum Status job = PENDING;
printf("%d\n", job); // prints 100</code></pre>

<h2>4. Enum in C++ (Scoped enum)</h2>
<p>C++11 introduced <code>enum class</code>, which is safer.</p>
<pre><code>enum class Color { RED, GREEN, BLUE };
Color c = Color::RED;</code></pre>
<p>Cannot implicitly convert to <code>int</code>. Scoped enums avoid name clashes (e.g., <code>Color::RED</code> vs <code>TrafficLight::RED</code>).</p>

<h2>5. Memory representation</h2>
<p>Usually stored as an <code>int</code> internally (size depends on compiler, often 4 bytes). In C++ you can explicitly change it:</p>
<pre><code>enum class Color : unsigned char { RED, GREEN, BLUE }; // 1 byte</code></pre>

<h2>6. Practical Example</h2>
<pre><code>#include &lt;stdio.h&gt;

enum ErrorCode { OK=0, FILE_NOT_FOUND=1, OUT_OF_MEMORY=2 };

void checkFile(int code) {
    switch(code) {
        case OK: printf("All good\n"); break;
        case FILE_NOT_FOUND: printf("File missing\n"); break;
        case OUT_OF_MEMORY: printf("Memory full\n"); break;
    }
}

int main() {
    enum ErrorCode code = FILE_NOT_FOUND;
    checkFile(code);
    return 0;
}</code></pre>
<p>Cleaner than using <code>#define FILE_NOT_FOUND 1</code> everywhere.</p>

<h2>Summary</h2>
<ul>
    <li><code>enum</code> = named integers</li>
    <li>Makes code readable, maintainable, safer</li>
    <li>C++11 has scoped enums (<code>enum class</code>)</li>
    <li>Can assign custom values or use default auto-increment</li>
    <li>Common in state machines, days, error codes, flags</li>
</ul>
<h1>typedef in C/C++</h1>
    <p>
        <code>typedef</code> in C/C++ does not create a new data type. 
        It simply creates an alias (a nickname) for an existing type. 
        It’s a way to make your code more readable, shorter, or flexible.
    </p>
    <p>
        Think of it like giving <code>unsigned long long</code> a simpler nickname: <code>BigNum</code>. 
        The underlying type doesn’t change. You just don’t have to type the long mess every time.
    </p>

    <h2>Syntax</h2>
    <pre><code>typedef existing_type new_name;</code></pre>
    <ul>
        <li><strong>existing_type</strong> → the type you want to alias</li>
        <li><strong>new_name</strong> → the alias you want to use</li>
    </ul>

    <h2>Examples</h2>

    <h3>Simple type alias</h3>
    <pre><code>typedef unsigned int uint;

uint a = 10; // same as unsigned int a = 10;</code></pre>

    <h3>Struct alias</h3>
    <pre><code>struct Student {
    int id;
    char name[50];
};

typedef struct Student Stu;

Stu s1; // same as struct Student s1;</code></pre>

    <h3>Pointer alias</h3>
    <pre><code>typedef int* IntPtr;

IntPtr p1, p2; // both are int* pointers</code></pre>
    <p>
        <strong>Warning:</strong> Only the typedef name is affected. 
        If you tried <code>int* p1, p2;</code> only <code>p1</code> is a pointer. 
        <code>typedef</code> avoids this pitfall.
    </p>

    <h3>Function pointer alias</h3>
    <pre><code>typedef int (*FuncPtr)(int, int);

int add(int a, int b) { return a+b; }

FuncPtr f = add; // f points to add</code></pre>
    <p>Huge in callbacks and API-heavy code.</p>

    <h2>Why use typedef?</h2>
    <ul>
        <li><strong>Readability:</strong> Makes complex types easier to read
            <pre><code>typedef unsigned long ulong;
ulong bigNumber;</code></pre>
        </li>
        <li><strong>Portability:</strong> Easy to change type in one place for all code
            <pre><code>typedef unsigned long size_type;
size_type length;</code></pre>
        </li>
        <li><strong>Cleaner structs and pointers:</strong> Avoid writing <code>struct</code> everywhere</li>
        <li><strong>Simplifies function pointers:</strong> Which are a nightmare otherwise</li>
    </ul>

    <h2>Things to Remember</h2>
    <ul>
        <li><code>typedef</code> doesn’t create a new type, it’s just a new name.</li>
        <li>Multiple variables can use the alias:
            <pre><code>typedef float real;
real x, y, z; // all floats</code></pre>
        </li>
        <li>Commonly used with <code>struct</code>, <code>enum</code>, <code>union</code>, and pointers.</li>
    </ul>
    <h1>Non-Primitive / Abstract Data Types (ADT)</h1>
    <p>An <strong>Abstract Data Type (ADT)</strong> is a logical description of how data behaves rather than how it is actually stored. Think of it as a contract: it says what operations you can do, not how they are implemented.</p>
    <p><strong>Example:</strong> A stack must let you push and pop in LIFO order. How the memory is arranged—array, linked list, whatever—is someone else’s problem.</p>

    <h2>Key Points of ADTs</h2>
    <ul>
        <li><strong>Behavior-focused:</strong> ADT defines what operations are allowed.</li>
        <li><strong>Implementation-independent:</strong> Internal storage can change without changing the ADT rules.</li>
        <li><strong>Encapsulation:</strong> Hides the internal details. Users see only operations, not memory layout.</li>
        <li><strong>Reusability:</strong> Once defined, the ADT can be reused in multiple programs.</li>
    </ul>

    <h2>1. What is a Stack?</h2>
    <p>A stack is an Abstract Data Type (ADT) where elements are inserted and removed from only one end, called the <strong>top</strong>.</p>
    <p><strong>LIFO (Last In First Out):</strong> The last element pushed is the first to pop out.</p>
    <p>Think of it like a stack of plates: you add/remove from the top.</p>

    <h2>2. Stack Operations</h2>
    <table>
        <tr>
            <th>Operation</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>push(x)</td>
            <td>Add element x to the top</td>
        </tr>
        <tr>
            <td>pop()</td>
            <td>Remove and return the top element</td>
        </tr>
        <tr>
            <td>peek() / top()</td>
            <td>Return top element without removing</td>
        </tr>
        <tr>
            <td>isEmpty()</td>
            <td>Check if the stack is empty</td>
        </tr>
        <tr>
            <td>size()</td>
            <td>Returns number of elements</td>
        </tr>
    </table>

    <h2>3. Stack Implementation</h2>
    <h3>a) Using Array</h3>
    <pre>
#include &lt;stdio.h&gt;
#define MAX 5

int stack[MAX];
int top = -1;

void push(int x) {
    if(top == MAX-1) { printf("Stack Overflow\n"); return; }
    stack[++top] = x;
}

int pop() {
    if(top == -1) { printf("Stack Underflow\n"); return -1; }
    return stack[top--];
}

int peek() {
    if(top == -1) { printf("Stack is empty\n"); return -1; }
    return stack[top];
}

int main() {
    push(10);
    push(20);
    push(30);
    printf("Top element: %d\n", peek());
    printf("Popped element: %d\n", pop());
    printf("Top element now: %d\n", peek());
    return 0;
}
    </pre>

    <h3>b) Using Linked List</h3>
    <pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct Node {
    int data;
    struct Node* next;
};

struct Node* top = NULL;

void push(int x) {
    struct Node* node = (struct Node*)malloc(sizeof(struct Node));
    node->data = x;
    node->next = top;
    top = node;
}

int pop() {
    if(top == NULL) { printf("Stack Underflow\n"); return -1; }
    int val = top->data;
    struct Node* temp = top;
    top = top->next;
    free(temp);
    return val;
}

int peek() {
    if(top == NULL) { printf("Stack is empty\n"); return -1; }
    return top->data;
}

int main() {
    push(10);
    push(20);
    push(30);
    printf("Top element: %d\n", peek());
    printf("Popped element: %d\n", pop());
    printf("Top element now: %d\n", peek());
    return 0;
}
    </pre>

    <h2>4. Textual Diagram</h2>
    <p>Push sequence: 10 → 20 → 30</p>
    <div class="diagram">
Top
 │
 │ 30   &lt;- Last pushed
 │ 20
 │ 10
 └─── Bottom
    </div>

    <p>After pop():</p>
    <div class="diagram">
Top
 │
 │ 20
 │ 10
 └─── Bottom
    </div>

    <h2>5. Applications of Stack</h2>
    <ul>
        <li>Function Call Management (call stack)</li>
        <li>Expression Evaluation (Postfix/Prefix)</li>
        <li>Undo/Redo operations in editors</li>
        <li>Backtracking algorithms (maze solving, chess moves)</li>
        <li>Browser history</li>
    </ul>
    <h1>Queue – In Depth</h1>

<p>A Queue is a linear data structure that follows FIFO (First In, First Out) principle.</p>
<p>First element added → first element removed</p>
<p>Think of it like a real-life queue at a ticket counter.</p>

<h2>Characteristics</h2>
<ul>
    <li><strong>Front:</strong> The end where elements are removed.</li>
    <li><strong>Rear:</strong> The end where elements are inserted.</li>
    <li>Dynamic size (if implemented using linked list) or fixed size (array-based).</li>
    <li>Operations are strictly defined:
        <ul>
            <li>enqueue() → insert element at rear</li>
            <li>dequeue() → remove element from front</li>
            <li>peek() / front() → view front element</li>
            <li>isEmpty() → check if queue is empty</li>
            <li>isFull() → check if queue is full (array implementation)</li>
        </ul>
    </li>
</ul>

<h2>Types of Queues</h2>

<h3>Linear Queue (Simple Queue)</h3>
<p>A Linear Queue is a type of queue where elements are stored in a linear sequence and follow FIFO (First In, First Out) principle.</p>
<p>First element added → first element removed</p>
<p>Rear always increases to insert, Front always increases to remove</p>
<p>Fixed-size (usually array-based) or dynamic (linked list-based)</p>

<h4>Characteristics</h4>
<ul>
    <li><strong>Front:</strong> Points to the first element in the queue (to be dequeued).</li>
    <li><strong>Rear:</strong> Points to the last element in the queue (last inserted).</li>
    <li>FIFO principle strictly followed.</li>
</ul>

<h4>Operations</h4>
<ul>
    <li>enqueue(x) → add element at rear</li>
    <li>dequeue() → remove element from front</li>
    <li>peek() / front() → view the front element</li>
    <li>isEmpty() → check if queue is empty</li>
    <li>isFull() → check if queue is full</li>
</ul>

<h4>Textual Diagram</h4>
<p>Suppose we enqueue 10, 20, 30 into an empty queue:</p>
<pre>Front → 10  20  30 ← Rear</pre>
<p>After a dequeue() (removing 10):</p>
<pre>Front → 20  30 ← Rear</pre>
<p>If we enqueue 40:</p>
<pre>Front → 20  30  40 ← Rear</pre>

<p><strong>Observation:</strong></p>
<ul>
    <li>The rear moves forward with every enqueue.</li>
    <li>The front moves forward with every dequeue.</li>
    <li>Problem: After several dequeues, some space at the beginning of the array is wasted (unless we shift elements or use a circular queue).</li>
</ul>

<h4>Example in C (Linear Queue using Array)</h4>
<pre>
#include &lt;stdio.h&gt;
#define MAX 5

int queue[MAX];
int front = -1, rear = -1;

// Enqueue operation
void enqueue(int x) {
    if(rear == MAX-1) {
        printf("Queue Overflow\n");
        return;
    }
    if(front == -1) front = 0; // first element
    rear++;
    queue[rear] = x;
}

// Dequeue operation
void dequeue() {
    if(front == -1 || front &gt; rear) {
        printf("Queue Underflow\n");
        return;
    }
    printf("Dequeued: %d\n", queue[front]);
    front++;
}

// Display queue
void display() {
    if(front == -1 || front &gt; rear) {
        printf("Queue is empty\n");
        return;
    }
    printf("Queue: ");
    for(int i = front; i &lt;= rear; i++)
        printf("%d ", queue[i]);
    printf("\n");
}

int main() {
    enqueue(10);
    enqueue(20);
    enqueue(30);
    display();   // Queue: 10 20 30
    dequeue();   // Dequeued: 10
    display();   // Queue: 20 30
    enqueue(40);
    display();   // Queue: 20 30 40
    return 0;
}
</pre>

<h4>Output:</h4>
<pre>
Queue: 10 20 30
Dequeued: 10
Queue: 20 30
Queue: 20 30 40
</pre>

<h4>Pros</h4>
<ul>
    <li>Simple and easy to implement</li>
    <li>Useful for small, fixed-size queues</li>
</ul>

<h4>Cons</h4>
<ul>
    <li>Wasted space after multiple dequeues</li>
    <li>Fixed size unless implemented dynamically</li>
</ul>

<h3>Circular Queue – In Depth</h3>
<p>A Circular Queue is a linear queue but the last position is connected back to the first position, forming a circle.</p>
<p>Solves the memory wastage problem of a linear queue.</p>
<p>Uses modulo arithmetic to wrap rear and front.</p>

<h4>Characteristics</h4>
<ul>
    <li>Fixed-size queue (array implementation).</li>
    <li>Front points to first element, rear points to last element.</li>
</ul>

<h4>Operations:</h4>
<ul>
    <li>enqueue(x) → insert at rear ((rear + 1) % MAX is new rear)</li>
    <li>dequeue() → remove from front ((front + 1) % MAX is new front)</li>
    <li>isFull() → (rear + 1) % MAX == front</li>
    <li>isEmpty() → front == -1</li>
</ul>

<h4>Textual Diagram</h4>
<p>Let’s say MAX = 5, enqueue 10, 20, 30:</p>
<pre>
Indices: 0   1   2   3   4
Queue:  10  20  30  -   -
Front → 0
Rear  → 2
</pre>

<p>Dequeue one element (10 removed):</p>
<pre>
Queue:  -   20  30  -   -
Front → 1
Rear  → 2
</pre>

<p>Enqueue 40, 50:</p>
<pre>
Queue:  -   20  30  40  50
Front → 1
Rear  → 4
</pre>

<p>Enqueue 60 → wraps around to index 0:</p>
<pre>
Queue:  60  20  30  40  50
Front → 1
Rear  → 0
</pre>

<p>Now the queue is full because (rear + 1) % MAX == front.</p>

<h4>C Example of Circular Queue</h4>
<pre>
#include &lt;stdio.h&gt;
#define MAX 5

int queue[MAX];
int front = -1, rear = -1;

int isFull() {
    return (front == (rear + 1) % MAX);
}

int isEmpty() {
    return (front == -1);
}

void enqueue(int x) {
    if(isFull()) {
        printf("Queue Overflow\n");
        return;
    }
    if(isEmpty()) front = 0;
    rear = (rear + 1) % MAX;
    queue[rear] = x;
}

void dequeue() {
    if(isEmpty()) {
        printf("Queue Underflow\n");
        return;
    }
    printf("Dequeued: %d\n", queue[front]);
    if(front == rear) { // only one element
        front = rear = -1;
    } else {
        front = (front + 1) % MAX;
    }
}

void display() {
    if(isEmpty()) {
        printf("Queue is empty\n");
        return;
    }
    printf("Queue: ");
    int i = front;
    while(1) {
        printf("%d ", queue[i]);
        if(i == rear) break;
        i = (i + 1) % MAX;
    }
    printf("\n");
}

int main() {
    enqueue(10);
    enqueue(20);
    enqueue(30);
    enqueue(40);
    enqueue(50);
    display();
    dequeue();
    dequeue();
    enqueue(60);
    display();
    return 0;
}
</pre>

<h4>Sample Output:</h4>
<pre>
Queue: 10 20 30 40 50
Dequeued: 10
Dequeued: 20
Queue: 30 40 50 60
</pre>

<h4>Advantages over Linear Queue</h4>
<ul>
    <li>No memory wastage.</li>
    <li>Efficient for fixed-size buffers.</li>
    <li>Works well in real-time systems and circular buffers.</li>
</ul>

<h4>Use Cases</h4>
<ul>
    <li>CPU scheduling (round-robin)</li>
    <li>Traffic control systems</li>
    <li>Streaming data (audio/video buffers)</li>
    <li>Multiplayer game turn management</li>
</ul>

<h3>Priority Queue – In Depth</h3>
<p>A Priority Queue (PQ) is an abstract data type similar to a regular queue, but every element has a priority.</p>
<p>Higher priority elements are dequeued before lower priority ones.</p>
<p>If two elements have the same priority, their order can be FIFO (depends on implementation).</p>
<p>Think of it like an emergency room: a patient with a serious injury goes first, even if someone arrived earlier.</p>

<h4>Characteristics</h4>
<ul>
    <li>Each element has a value and a priority.</li>
</ul>

<h4>Operations:</h4>
<ul>
    <li>insert(x, priority) → add element with priority</li>
    <li>peek() → view element with highest priority</li>
    <li>delete() / extractMax() / extractMin() → remove element with highest (or lowest) priority</li>
</ul>

<p>Can be implemented using:</p>
<ul>
    <li>Array / Linked List (simple but slow for large PQ)</li>
    <li>Heap (efficient, O(log n) insert and delete)</li>
</ul>

<h4>Textual Diagram (Max Priority Queue)</h4>
<p>Let’s enqueue elements: (Value, Priority)</p>
<p>Enqueue: (A, 2), (B, 5), (C, 1), (D, 4)</p>
<p>Logical queue (sorted by priority descending):</p>
<pre>Front → B(5)  D(4)  A(2)  C(1) ← Rear</pre>
<p>After delete() (removes B(5)):</p>
<pre>Front → D(4)  A(2)  C(1) ← Rear</pre>

<h4>Example in C (Array-Based Priority Queue)</h4>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define MAX 100

typedef struct {
    int data;
    int priority;
} Node;

Node pq[MAX];
int size = 0;

void enqueue(int data, int priority) {
    pq[size].data = data;
    pq[size].priority = priority;
    size++;
}

int dequeue() {
    if(size == 0) return -1;

    // Find highest priority
    int maxIndex = 0;
    for(int i = 1; i &lt; size; i++) {
        if(pq[i].priority &gt; pq[maxIndex].priority)
            maxIndex = i;
    }

    int data = pq[maxIndex].data;

    // Shift elements left
    for(int i = maxIndex; i &lt; size - 1; i++) {
        pq[i] = pq[i+1];
    }
    size--;
    return data;
}

void display() {
    printf("Priority Queue: ");
    for(int i = 0; i &lt; size; i++) {
        printf("(%d,%d) ", pq[i].data, pq[i].priority);
    }
    printf("\n");
}

int main() {
    enqueue(10, 2);
    enqueue(20, 5);
    enqueue(30, 1);
    enqueue(40, 4);
    display();
    
    printf("Dequeued: %d\n", dequeue());
    display();
    return 0;
}
</pre>

<h4>Output:</h4>
<pre>
Priority Queue: (10,2) (20,5) (30,1) (40,4) 
Dequeued: 20
Priority Queue: (10,2) (30,1) (40,4) 
</pre>

<h4>Use Cases</h4>
<ul>
    <li>CPU process scheduling (OS)</li>
    <li>Dijkstra’s shortest path algorithm</li>
    <li>Huffman coding</li>
    <li>Event-driven simulations</li>
    <li>Emergency response systems</li>
</ul>

<h4>Notes</h4>
<ul>
    <li>Max-priority queue: Higher value → higher priority</li>
    <li>Min-priority queue: Lower value → higher priority</li>
    <li>Efficient implementation: Binary Heap, giving O(log n) for insert and delete.</li>
</ul>

<h3>Deque (Double-Ended Queue) – In Depth</h3>
<p>A Deque is a linear data structure where insertion and deletion are allowed at both ends — front and rear.</p>
<p>Think of it like a queue where VIPs can enter/exit from both sides.</p>

<h4>Types of Deque</h4>
<ul>
    <li><strong>Input-Restricted Deque:</strong> Insertion allowed at one end only (usually rear), Deletion allowed at both ends</li>
    <li><strong>Output-Restricted Deque:</strong> Deletion allowed at one end only (usually front), Insertion allowed at both ends</li>
</ul>

<h4>Operations of a Deque</h4>
<table>
<tr><th>Operation</th><th>Description</th></tr>
<tr><td>insertFront(x)</td><td>Add element at front</td></tr>
<tr><td>insertRear(x)</td><td>Add element at rear</td></tr>
<tr><td>deleteFront()</td><td>Remove element from front</td></tr>
<tr><td>deleteRear()</td><td>Remove element from rear</td></tr>
<tr><td>getFront()</td><td>Peek element at front</td></tr>
<tr><td>getRear()</td><td>Peek element at rear</td></tr>
<tr><td>isEmpty()</td><td>Check if deque is empty</td></tr>
<tr><td>isFull()</td><td>Check if deque is full (array implementation)</td></tr>
</table>

<h4>Textual Diagram of Deque</h4>
<p>Let’s say we do the following operations:</p>
<ul>
    <li>insertRear(10)</li>
    <li>insertRear(20)</li>
    <li>insertFront(5)</li>
    <li>insertRear(30)</li>
</ul>
<p>Deque looks like:</p>
<pre>Front → 5  10  20  30 ← Rear</pre>

<p>Now, if we do deleteRear():</p>
<pre>Front → 5  10  20 ← Rear</pre>

<h4>Example in C (Deque using Array)</h4>
<pre>
#include &lt;stdio.h&gt;
#define MAX 5

int deque[MAX];
int front = -1, rear = -1;

int isEmpty() { return front == -1; }
int isFull() { return rear == MAX-1; }

void insertRear(int x) {
    if(isFull()) { printf("Deque Overflow\n"); return; }
    if(front == -1) front = 0;
    rear++;
    deque[rear] = x;
}

void insertFront(int x) {
    if(front == 0) { printf("Cannot insert at front\n"); return; }
    if(front == -1) { front = rear = 0; deque[front] = x; return; }
    front--;
    deque[front] = x;
}

void deleteFront() {
    if(isEmpty()) { printf("Deque Underflow\n"); return; }
    printf("Deleted from front: %d\n", deque[front]);
    if(front == rear) front = rear = -1; // empty now
    else front++;
}

void deleteRear() {
    if(isEmpty()) { printf("Deque Underflow\n"); return; }
    printf("Deleted from rear: %d\n", deque[rear]);
    if(front == rear) front = rear = -1;
    else rear--;
}

void display() {
    if(isEmpty()) { printf("Deque is empty\n"); return; }
    printf("Deque: ");
    for(int i = front; i &lt;= rear; i++) printf("%d ", deque[i]);
    printf("\n");
}

int main() {
    insertRear(10);
    insertRear(20);
    insertFront(5);
    insertRear(30);
    display();
    deleteFront();
    deleteRear();
    display();
    return 0;
}
</pre>

<h4>Output:</h4>
<pre>
Deque: 5 10 20 30
Deleted from front: 5
Deleted from rear: 30
Deque: 10 20
</pre>

<h4>Use Cases</h4>
<ul>
    <li>Undo/Redo in text editors</li>
    <li>Sliding window problems</li>
    <li>Palindrome checking</li>
    <li>Scheduling algorithms where both ends are important</li>
</ul>
<h1>Linked List</h1>

    <h2>1. What is a Linked List?</h2>
    <p>A Linked List is a linear data structure where elements (called nodes) are not stored in contiguous memory locations. Each node contains:</p>
    <ul>
        <li><strong>Data</strong> – the value of the node</li>
        <li><strong>Pointer (next)</strong> – address of the next node</li>
    </ul>
    <p>This allows dynamic memory allocation and efficient insertion/deletion.</p>

    <h2>2. Why Use Linked Lists?</h2>
    <table>
        <tr>
            <th>Feature</th>
            <th>Array</th>
            <th>Linked List</th>
        </tr>
        <tr>
            <td>Memory</td>
            <td>Fixed size</td>
            <td>Dynamic</td>
        </tr>
        <tr>
            <td>Insertion/Deletion</td>
            <td>Expensive (shift elements)</td>
            <td>Easy (adjust pointers)</td>
        </tr>
        <tr>
            <td>Access</td>
            <td>Random access O(1)</td>
            <td>Sequential O(n)</td>
        </tr>
        <tr>
            <td>Wasted Space</td>
            <td>None</td>
            <td>Extra memory for pointers</td>
        </tr>
    </table>

    <h2>3. Types of Linked Lists</h2>

    <h3>1. Singly Linked List (SLL)</h3>
    <p>A Singly Linked List is a linear data structure where each element (node) contains:</p>
    <ul>
        <li>Data – stores the value.</li>
        <li>Next – pointer to the next node. The last node points to NULL.</li>
    </ul>
    <p>Key points:</p>
    <ul>
        <li>Traversal is forward only.</li>
        <li>Memory is dynamically allocated.</li>
        <li>Size can grow or shrink at runtime.</li>
    </ul>

    <h4>Node Structure (C Example)</h4>
    <pre>
struct Node {
    int data;
    struct Node* next;
};
    </pre>
    <p><strong>data</strong> → stores value like int, char, etc.</p>
    <p><strong>next</strong> → pointer to the next node.</p>

    <h4>Diagrammatic Representation</h4>
    <p>Suppose we have a list: 10 → 20 → 30</p>
    <pre>
Head -> [10 | Next] -> [20 | Next] -> [30 | Next] -> NULL
    </pre>
    <ul>
        <li>Head points to the first node.</li>
        <li>Each node points to the next node.</li>
        <li>Last node points to NULL.</li>
    </ul>

    <h4>Basic Operations</h4>

    <h5>a) Traversal</h5>
    <pre>
void traverse(struct Node* head) {
    struct Node* temp = head;
    while(temp != NULL) {
        printf("%d -> ", temp->data);
        temp = temp->next;
    }
    printf("NULL\n");
}
    </pre>
    <p>Example Output:</p>
    <pre>10 -> 20 -> 30 -> NULL</pre>

    <h5>b) Insertion</h5>
    <p><strong>At Beginning</strong></p>
    <pre>
newNode->next = head;
head = newNode;
    </pre>
    <pre>
New Node 5
Head -> [5|Next] -> [10|Next] -> [20|Next] -> [30|Next] -> NULL
    </pre>

    <p><strong>At End</strong></p>
    <pre>
last->next = newNode;
newNode->next = NULL;
    </pre>
    <pre>
Head -> [10|Next] -> [20|Next] -> [30|Next] -> [40|Next] -> NULL
    </pre>

    <p><strong>At Position (Middle)</strong></p>
    <p>Traverse to previous node and adjust pointers:</p>
    <pre>
prev->next = newNode;
newNode->next = curr;
    </pre>

    <h5>c) Deletion</h5>
    <p><strong>From Beginning</strong></p>
    <pre>
temp = head;
head = head->next;
free(temp);
    </pre>

    <p><strong>From End</strong></p>
    <pre>
Traverse to second last node
secondLast->next = NULL;
free(last);
    </pre>

    <p><strong>From Position</strong></p>
    <pre>
Traverse to previous node
prev->next = curr->next;
free(curr);
    </pre>

    <h5>d) Search</h5>
    <pre>
struct Node* search(struct Node* head, int key) {
    struct Node* temp = head;
    while(temp != NULL) {
        if(temp->data == key) return temp;
        temp = temp->next;
    }
    return NULL;
}
    </pre>

    <h4>Complete Example in C</h4>
    <pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct Node {
    int data;
    struct Node* next;
};

int main() {
    struct Node* head = NULL;
    struct Node* second = NULL;
    struct Node* third = NULL;

    head = (struct Node*)malloc(sizeof(struct Node));
    second = (struct Node*)malloc(sizeof(struct Node));
    third = (struct Node*)malloc(sizeof(struct Node));

    head->data = 10; head->next = second;
    second->data = 20; second->next = third;
    third->data = 30; third->next = NULL;

    struct Node* temp = head;
    while(temp != NULL) {
        printf("%d -> ", temp->data);
        temp = temp->next;
    }
    printf("NULL\n");

    return 0;
}
    </pre>
    <p>Output:</p>
    <pre>10 -> 20 -> 30 -> NULL</pre>

    <h4>Advantages</h4>
    <ul>
        <li>Dynamic memory allocation (size flexible)</li>
        <li>Easy insertion/deletion (no shifting like arrays)</li>
    </ul>

    <h4>Disadvantages</h4>
    <ul>
        <li>No random access (must traverse sequentially)</li>
        <li>Extra memory for next pointer</li>
    </ul>

    <h4>Real-world Use Cases</h4>
    <ul>
        <li>Undo functionality in text editors – last action stored at the top.</li>
        <li>Dynamic memory allocation (OS memory management).</li>
        <li>Symbol table representation in compilers.</li>
        <li>Chained hash table implementation.</li>
    </ul>

    <h3>2. Doubly Linked List (DLL)</h3>
    <p>A Doubly Linked List is a linear data structure where each node contains:</p>
    <ul>
        <li>Data – the value stored.</li>
        <li>Next Pointer – address of the next node.</li>
        <li>Previous Pointer – address of the previous node.</li>
    </ul>
    <p>This allows traversal in both directions (forward and backward).</p>

    <h4>Structure of a Node (C Example)</h4>
    <pre>
struct Node {
    int data;          
    struct Node* next; // pointer to next node
    struct Node* prev; // pointer to previous node
};
    </pre>

    <h4>Advantages Over Singly Linked List</h4>
    <table>
        <tr>
            <th>Feature</th>
            <th>Singly Linked List</th>
            <th>Doubly Linked List</th>
        </tr>
        <tr>
            <td>Traversal</td>
            <td>Forward only</td>
            <td>Forward & backward</td>
        </tr>
        <tr>
            <td>Deletion</td>
            <td>Need previous node</td>
            <td>Can delete easily using prev pointer</td>
        </tr>
        <tr>
            <td>Insertion</td>
            <td>Need previous node</td>
            <td>Can insert anywhere easily</td>
        </tr>
        <tr>
            <td>Memory</td>
            <td>Less</td>
            <td>More (extra pointer)</td>
        </tr>
    </table>

    <h4>Operations</h4>
    <h5>a) Traversal</h5>
    <p><strong>Forward Traversal:</strong></p>
    <pre>
void traverseForward(struct Node* head) {
    struct Node* temp = head;
    while(temp != NULL) {
        printf("%d <-> ", temp->data);
        temp = temp->next;
    }
    printf("NULL\n");
}
    </pre>

    <p><strong>Backward Traversal:</strong></p>
    <pre>
void traverseBackward(struct Node* tail) {
    struct Node* temp = tail;
    while(temp != NULL) {
        printf("%d <-> ", temp->data);
        temp = temp->prev;
    }
    printf("NULL\n");
}
    </pre>

    <h5>b) Insertion</h5>
    <p><strong>At Beginning:</strong></p>
    <pre>
newNode->next = head;
newNode->prev = NULL;
if(head != NULL)
    head->prev = newNode;
head = newNode;
    </pre>

    <p><strong>At End:</strong></p>
    <pre>
tail->next = newNode;
newNode->prev = tail;
newNode->next = NULL;
tail = newNode;
    </pre>

    <p><strong>At Position:</strong></p>
    <pre>
Traverse to position
Adjust prev and next pointers
    </pre>

    <h5>c) Deletion</h5>
    <p><strong>From Beginning:</strong></p>
    <pre>
temp = head;
head = head->next;
if(head != NULL)
    head->prev = NULL;
free(temp);
    </pre>

    <p><strong>From End:</strong></p>
    <pre>
temp = tail;
tail = tail->prev;
tail->next = NULL;
free(temp);
    </pre>

    <p><strong>From Middle:</strong></p>
    <pre>
Adjust prev->next and next->prev pointers
Free the node
    </pre>

    <h4>Textual Diagram</h4>
    <pre>
Forward: Head -> [10|Next|Prev] <-> [20|Next|Prev] <-> [30|Next|Prev] -> NULL
Backward: Tail -> [30|Prev|Next] <-> [20|Prev|Next] <-> [10|Prev|Next] -> NULL
    </pre>

    <h4>Use Cases</h4>
    <ul>
        <li>Browser History: Forward/backward navigation</li>
        <li>Undo/Redo in Editors: Go back or forward between changes</li>
        <li>Playlist Navigation: Previous/next song</li>
        <li>Memory Management: Free list in operating systems</li>
    </ul>

    <h4>Advantages</h4>
    <ul>
        <li>Easy forward and backward traversal</li>
        <li>Easier insertion and deletion anywhere than singly linked list</li>
    </ul>

    <h4>Disadvantages</h4>
    <ul>
        <li>More memory per node (extra pointer)</li>
        <li>Slightly more complex implementation</li>
    </ul>

    <h3>3. Circular Linked List (CLL)</h3>
    <p>A Circular Linked List is a linked list where the last node points back to the first node, forming a circle.</p>
    <ul>
        <li>Can be singly circular (last node → first node)</li>
        <li>Can be doubly circular (first node’s previous → last node, last node’s next → first node)</li>
    </ul>

    <h4>Why Circular Linked Lists?</h4>
    <ul>
        <li>Eliminates NULL at the end</li>
        <li>Traversal can start at any node and loop indefinitely</li>
        <li>Useful for applications where wrap-around is needed</li>
    </ul>

    <h4>Structure of a Node (C Example)</h4>
    <pre>
struct Node {
    int data;
    struct Node* next; // pointer to next node
};
    </pre>

    <h4>Operations</h4>
    <h5>a) Traversal</h5>
    <pre>
void traverse(struct Node* head) {
    if(head == NULL) return;
    struct Node* temp = head;
    do {
        printf("%d -> ", temp->data);
        temp = temp->next;
    } while(temp != head);
    printf("(back to head)\n");
}
    </pre>

    <h5>b) Insertion</h5>
    <p><strong>At Beginning:</strong></p>
    <pre>
newNode->next = head;
last->next = newNode; // last points to new head
head = newNode;
    </pre>

    <p><strong>At End:</strong></p>
    <pre>
last->next = newNode;
newNode->next = head;
    </pre>

    <p><strong>At Position:</strong></p>
    <pre>
Traverse to previous node
Adjust pointers like normal
Ensure circular link maintained
    </pre>

    <h5>c) Deletion</h5>
    <p><strong>From Beginning:</strong></p>
    <pre>
Move head to head->next
Update last node’s next pointer to new head
Free old head
    </pre>

    <p><strong>From End:</strong></p>
    <pre>
Traverse to second last node
Update secondLast->next = head
Free last node
    </pre>

    <p><strong>From Position:</strong></p>
    <pre>
Traverse to previous node
Adjust pointers
Maintain circular link
    </pre>

    <h5>d) Search</h5>
    <p>Same as singly linked list, but traversal uses do-while to avoid infinite loop.</p>

    <h4>Example: Singly Circular Linked List</h4>
    <pre>
Insert 10 -> 20 -> 30

Step 1: Insert 10
Head -> [10|Next] -> points to itself

Step 2: Insert 20 at end
Head -> [10|Next] -> [20|Next] -> points to head

Step 3: Insert 30 at end
Head -> [10|Next] -> [20|Next] -> [30|Next] -> points to head
    </pre>

    <h4>Use Cases</h4>
    <ul>
        <li>Round Robin Scheduling – CPU cycles through tasks repeatedly</li>
        <li>Music/Media Players – Playlist loops indefinitely</li>
        <li>Traffic Light Control – Cycles through red → green → yellow → red</li>
    </ul>

    <h4>Advantages</h4>
    <ul>
        <li>Efficient for circular operations</li>
        <li>No need to check for NULL at the end</li>
        <li>Can start traversal from any node</li>
    </ul>

    <h4>Disadvantages</h4>
    <ul>
        <li>More complex than singly linked list</li>
        <li>Risk of infinite loops if traversal not handled carefully</li>
    </ul>
    <h1>Set (ADT) – In Depth</h1>

<p>A <strong>Set</strong> is an Abstract Data Type that stores <strong>unique elements</strong>, with no particular order (unless you define an ordered set). Think of it like a real-life set: no duplicates allowed.</p>

<h2>Key Properties</h2>
<ul>
    <li><strong>Uniqueness:</strong> No two elements are the same.</li>
    <li><strong>No specific order:</strong> Elements may not be stored in insertion order (depends on implementation).</li>
    <li><strong>Dynamic size:</strong> Elements can be added or removed.</li>
    <li><strong>Mathematical operations supported:</strong> Union, Intersection, Difference.</li>
</ul>

<h2>Common Operations</h2>
<table>
    <tr>
        <th>Operation</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>add(x)</td>
        <td>Insert element x (ignored if already present)</td>
    </tr>
    <tr>
        <td>remove(x)</td>
        <td>Remove element x if present</td>
    </tr>
    <tr>
        <td>contains(x)</td>
        <td>Check if x is in the set</td>
    </tr>
    <tr>
        <td>size()</td>
        <td>Number of elements</td>
    </tr>
    <tr>
        <td>union(Set B)</td>
        <td>Combine elements of two sets</td>
    </tr>
    <tr>
        <td>intersection(Set B)</td>
        <td>Elements common to both sets</td>
    </tr>
    <tr>
        <td>difference(Set B)</td>
        <td>Elements in this set but not in B</td>
    </tr>
</table>

<h2>Implementation</h2>
<ul>
    <li><strong>Array-based set:</strong> simple but slow O(n) search to avoid duplicates.</li>
    <li><strong>Linked list-based set:</strong> same as array, slightly more memory overhead.</li>
    <li><strong>Hash-based set:</strong> fastest, O(1) average for insert/search/remove.</li>
    <li><strong>Tree-based set:</strong> keeps elements sorted (like TreeSet in Java), O(log n) operations.</li>
</ul>

<h2>Example in C (Using Array)</h2>
<pre><code>#include &lt;stdio.h&gt;
#define MAX 100

struct Set {
    int data[MAX];
    int size;
};

// Add element
void add(struct Set *s, int x) {
    for(int i = 0; i &lt; s-&gt;size; i++)
        if(s-&gt;data[i] == x) return; // already exists
    s-&gt;data[s-&gt;size++] = x;
}

// Print Set
void printSet(struct Set s) {
    printf("{ ");
    for(int i = 0; i &lt; s.size; i++) printf("%d ", s.data[i]);
    printf("}\n");
}

int main() {
    struct Set s = {{0}, 0};
    add(&amp;s, 10);
    add(&amp;s, 20);
    add(&amp;s, 10); // duplicate, ignored
    add(&amp;s, 30);
    printSet(s);
    return 0;
}
</code></pre>

<h3>Output:</h3>
<pre><code>{ 10 20 30 }</code></pre>

<h2>Textual Diagram</h2>

<p>Logical representation of a set storing {10, 20, 30}:</p>
<pre><code>Set S
 ┌─────┐
 │ 10  │
 │ 20  │
 │ 30  │
 └─────┘</code></pre>

<p>If you do a <strong>union</strong> with set {20, 40, 50}:</p>
<pre><code>S ∪ B
 ┌─────┐
 │ 10  │
 │ 20  │
 │ 30  │
 │ 40  │
 │ 50  │
 └─────┘</code></pre>

<p>If you do <strong>intersection</strong>:</p>
<pre><code>S ∩ B
 ┌─────┐
 │ 20  │
 └─────┘</code></pre>

<h2>Applications of Sets</h2>
<ul>
    <li>Removing duplicates from a list</li>
    <li>Membership tests (is this ID already used?)</li>
    <li>Implementing mathematical set operations</li>
    <li>Fast lookup structures</li>
</ul>
<h1>Map / Dictionary (ADT)</h1>

    <p>A <strong>Map</strong> (or <strong>Dictionary</strong>) is an Abstract Data Type that stores data as <strong>key-value pairs</strong>. Every key is <strong>unique</strong>, and each key maps to exactly one value.</p>

    <p>Think of it like a real dictionary: the <em>word</em> is the key, the <em>meaning</em> is the value.</p>

    <h2>Key Points</h2>
    <ul>
        <li><strong>Unique keys:</strong> No duplicates allowed.</li>
        <li><strong>Efficient lookup:</strong> You can find a value quickly if you know the key.</li>
        <li><strong>Flexible value types:</strong> Keys are usually immutable; values can be anything.</li>
        <li>Implementations may vary:
            <ul>
                <li>Hash tables</li>
                <li>Balanced trees (BST, AVL, Red-Black tree)</li>
                <li>Arrays (for very small maps)</li>
            </ul>
        </li>
    </ul>

    <h2>Operations on Map / Dictionary</h2>
    <table>
        <tr>
            <th>Operation</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>put(key, value)</td>
            <td>Add a key-value pair. If key exists, update the value.</td>
        </tr>
        <tr>
            <td>get(key)</td>
            <td>Retrieve the value associated with the key.</td>
        </tr>
        <tr>
            <td>remove(key)</td>
            <td>Delete the key-value pair.</td>
        </tr>
        <tr>
            <td>contains(key)</td>
            <td>Check if a key exists.</td>
        </tr>
        <tr>
            <td>size()</td>
            <td>Number of key-value pairs.</td>
        </tr>
        <tr>
            <td>keys() / values()</td>
            <td>Return all keys or all values.</td>
        </tr>
    </table>

    <h2>Example in C++ (Using std::map)</h2>
    <pre><code>#include &lt;iostream&gt;
#include &lt;map&gt;
using namespace std;

int main() {
    map&lt;string, int&gt; age; // key: string, value: int

    // Insert elements
    age["Alice"] = 25;
    age["Bob"] = 30;
    age["Charlie"] = 28;

    // Update element
    age["Bob"] = 31;

    // Access element
    cout &lt;&lt; "Alice's age: " &lt;&lt; age["Alice"] &lt;&lt; endl;

    // Check if key exists
    if(age.find("David") == age.end()) {
        cout &lt;&lt; "David not found in map." &lt;&lt; endl;
    }

    // Iterate
    for(auto &p : age) {
        cout &lt;&lt; p.first &lt;&lt; " -> " &lt;&lt; p.second &lt;&lt; endl;
    }

    return 0;
}</code></pre>

    <h2>Output</h2>
    <pre>
Alice's age: 25
David not found in map.
Alice -> 25
Bob -> 31
Charlie -> 28
    </pre>

    <h2>Textual Diagram</h2>
    <table>
        <tr>
            <th>Key</th>
            <th>Value</th>
        </tr>
        <tr>
            <td>Alice</td>
            <td>25</td>
        </tr>
        <tr>
            <td>Bob</td>
            <td>31</td>
        </tr>
        <tr>
            <td>Charlie</td>
            <td>28</td>
        </tr>
    </table>

    <h2>Use Cases</h2>
    <ul>
        <li>Storing configuration settings (key=value)</li>
        <li>Counting occurrences of items</li>
        <li>Caching frequently accessed data</li>
        <li>Implementing symbol tables in compilers</li>
    </ul>
    <h1>Hash Table Overview</h1>

<p>A Hash Table is a data structure that implements a Map / Dictionary ADT using a hash function to compute an index (also called a hash code) where the key-value pair will be stored.</p>

<p><strong>Key idea:</strong> Instead of searching through the entire list, you compute the index of the key directly.</p>

<p><strong>Goal:</strong> Very fast operations—average O(1) for insertion, deletion, and search.</p>

<h2>Components of a Hash Table</h2>

<h3>Array (Table)</h3>
<ul>
    <li>Stores key-value pairs.</li>
    <li>Fixed size or dynamically resizable.</li>
</ul>

<h3>Hash Function</h3>
<ul>
    <li>Converts a key into an array index.</li>
    <li>Example: <code>hash(key) = key % table_size</code> (for integer keys)</li>
    <li>Should distribute keys uniformly to avoid clustering.</li>
</ul>

<h3>Collision Handling</h3>
<p>Two keys may map to the same index. This is a collision. Handled via:</p>
<ul>
    <li>Chaining (Linked Lists at each index)</li>
    <li>Open Addressing (Linear probing, Quadratic probing, Double hashing)</li>
</ul>

<h2>Operations</h2>
<table>
    <tr>
        <th>Operation</th>
        <th>How it Works</th>
        <th>Average Complexity</th>
    </tr>
    <tr>
        <td>insert(key, value)</td>
        <td>Compute hash index, store value. If collision, resolve it.</td>
        <td>O(1)</td>
    </tr>
    <tr>
        <td>search(key)</td>
        <td>Compute hash index, check chain or probe sequence</td>
        <td>O(1)</td>
    </tr>
    <tr>
        <td>delete(key)</td>
        <td>Find key, remove it</td>
        <td>O(1)</td>
    </tr>
    <tr>
        <td>update(key, value)</td>
        <td>Find key, replace value</td>
        <td>O(1)</td>
    </tr>
</table>

<h2>Collision Handling Methods</h2>

<h3>Chaining in Hash Tables</h3>
<p>Chaining is a collision resolution technique where each index of the hash table points to a linked list (or chain) of all elements that hash to the same index.</p>
<ul>
    <li>Instead of forcing one element per slot, multiple elements can coexist at the same index.</li>
    <li>Easy to implement and simple to understand.</li>
</ul>

<h4>How Chaining Works</h4>
<p>Compute hash index using hash function:</p>
<pre>index = hash(key) % table_size</pre>

<p>Insert element:</p>
<ul>
    <li>If the slot is empty, place it there.</li>
    <li>If the slot already has elements (collision), add it to the linked list at that index.</li>
</ul>

<p>Search element:</p>
<ul>
    <li>Go to the computed index.</li>
    <li>Traverse the linked list at that index to find the key.</li>
</ul>

<p>Delete element:</p>
<ul>
    <li>Go to the index, traverse the list, remove the node.</li>
</ul>

<h4>Example</h4>
<p>Suppose we want to insert these key-value pairs into a hash table of size 5:</p>
<p>(Alice, 25), (Bob, 31), (Charlie, 28), (David, 22)</p>

<p>Hash function:</p>
<pre>hash(key) = sum of ASCII codes of characters % 5</pre>

<p>Hash calculation:</p>
<table>
    <tr>
        <th>Key</th>
        <th>ASCII sum</th>
        <th>Index = sum % 5</th>
    </tr>
    <tr><td>Alice</td><td>480</td><td>0</td></tr>
    <tr><td>Bob</td><td>275</td><td>0</td></tr>
    <tr><td>Charlie</td><td>550</td><td>0</td></tr>
    <tr><td>David</td><td>420</td><td>0</td></tr>
</table>

<p>Textual Diagram of Hash Table with Chaining:</p>
<pre class="diagram">
Index 0 → [Alice, 25] → [Bob, 31] → [Charlie, 28] → [David, 22]
Index 1 → None
Index 2 → None
Index 3 → None
Index 4 → None
</pre>

<h4>C++ Example Using Chaining</h4>
<pre><code>#include &lt;iostream&gt;
#include &lt;list&gt;
using namespace std;

class HashTable {
    int table_size;
    list&lt;pair&lt;string,int&gt;&gt;* table;
public:
    HashTable(int size) {
        table_size = size;
        table = new list&lt;pair&lt;string,int&gt;&gt;[size];
    }

    int hashFunction(string key) {
        int sum = 0;
        for(char c : key) sum += c;
        return sum % table_size;
    }

    void insert(string key, int value) {
        int index = hashFunction(key);
        table[index].push_back({key, value});
    }

    void display() {
        for(int i=0; i&lt;table_size; i++) {
            cout &lt;&lt; "Index " &lt;&lt; i &lt;&lt; " → ";
            for(auto &amp;p : table[i])
                cout &lt;&lt; "[" &lt;&lt; p.first &lt;&lt; "," &lt;&lt; p.second &lt;&lt; "] -> ";
            cout &lt;&lt; "NULL\n";
        }
    }
};

int main() {
    HashTable ht(5);
    ht.insert("Alice",25);
    ht.insert("Bob",31);
    ht.insert("Charlie",28);
    ht.insert("David",22);

    ht.display();
}
</code></pre>

<p>Output:</p>
<pre class="diagram">
Index 0 → [Alice,25] -> [Bob,31] -> [Charlie,28] -> [David,22] -> NULL
Index 1 → NULL
Index 2 → NULL
Index 3 → NULL
Index 4 → NULL
</pre>

<h3>Advantages of Chaining</h3>
<ul>
    <li>Simple to implement.</li>
    <li>Handles unlimited collisions (linked list grows as needed).</li>
    <li>Deletion is easy (just remove node from list).</li>
</ul>

<h3>Disadvantages</h3>
<ul>
    <li>Extra memory for pointers.</li>
    <li>If many collisions occur, search time becomes O(n) at that index.</li>
    <li>Performance depends on load factor (n / table_size).</li>
</ul>

<h2>Open Addressing Overview</h2>
<p>When a collision occurs (two keys hash to the same index), we probe the hash table according to a specific sequence to find the next available slot.</p>
<ul>
    <li>All keys are stored in the table itself.</li>
    <li>Probing sequence must cover the table to avoid infinite loops.</li>
    <li>Load factor (number of elements / table size) should be &lt; 1 for performance.</li>
</ul>

<h3>Probing Methods: Linear Probing</h3>
<p>Linear Probing is a collision resolution technique in hash tables. When a collision occurs (two keys hash to the same index), check the next slot sequentially until an empty slot is found. Step size = 1.</p>

<p>Formula:</p>
<pre>h'(key,i) = (h(key) + i) % table_size</pre>

<p>Operations:</p>
<ul>
    <li><strong>Insert(key):</strong> Compute hash index. If slot occupied, move linearly to next index until empty.</li>
    <li><strong>Search(key):</strong> Compute hash index. Check the slot; if key not found, continue probing until key or empty slot.</li>
    <li><strong>Delete(key):</strong> Mark slot as deleted (lazy deletion), because skipping it breaks search chains.</li>
</ul>

<h4>Example: Linear Probing</h4>
<p>Hash Table Size: 7<br>
Hash Function: h(key) = key % 7<br>
Keys to Insert: 10, 20, 15, 7, 14</p>

<p>Step-by-Step Insertion:</p>
<ul>
    <li>Insert 10: Index = 10 % 7 = 3 → Table[3] = 10</li>
    <li>Insert 20: Index = 20 % 7 = 6 → Table[6] = 20</li>
    <li>Insert 15: Index = 15 % 7 = 1 → Table[1] = 15</li>
    <li>Insert 7: Index = 7 % 7 = 0 → Table[0] = 7</li>
    <li>Insert 14 (collision at index 0): Probe sequence 0 → 1 → 2 → Table[2] = 14</li>
</ul>

<p>Textual Diagram:</p>
<pre class="diagram">
Index: 0   1   2   3   4   5   6
Value: 7  15  14  10  -   -  20
</pre>

<h3>Problem with Deletion</h3>
<p>If we delete 15 (index 1) and mark it empty, search for 14 will fail. Solution: Use a <strong>Deleted Marker (DEL)</strong>.</p>

<pre class="diagram">
Before deletion:
Index : 0   1   2   3   4   5   6
Value : 7  15  14  10  -   -  20

Delete 15 → mark as DEL:
Index : 0   1   2   3   4   5   6
Value : 7  DEL 14  10  -   -  20
</pre>

<p>Searching for 14 continues past DEL, insertion can use DEL slot.</p>

<h2>Full C++ Implementation Using Linear Probing</h2>
<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

const int TABLE_SIZE = 7;   // Size of hash table
const int EMPTY = -1;       // Slot empty
const int DELETED = -2;     // Slot deleted

class HashTable {
    vector&lt;int&gt; table;

public:
    HashTable() {
        table.resize(TABLE_SIZE, EMPTY);
    }

    // Hash function
    int hash(int key) {
        return key % TABLE_SIZE;
    }

    // Insert key using linear probing
    void insert(int key) {
        int idx = hash(key);
        int start_idx = idx;
        while (table[idx] != EMPTY &amp;&amp; table[idx] != DELETED) {
            idx = (idx + 1) % TABLE_SIZE;
            if (idx == start_idx) {
                cout &lt;&lt; "Hash Table Full! Cannot insert " &lt;&lt; key &lt;&lt; endl;
                return;
            }
        }
        table[idx] = key;
        cout &lt;&lt; "Inserted " &lt;&lt; key &lt;&lt; " at index " &lt;&lt; idx &lt;&lt; endl;
    }

    // Search key using linear probing
    int search(int key) {
        int idx = hash(key);
        int start_idx = idx;
        while (table[idx] != EMPTY) {
            if (table[idx] == key)
                return idx;
            idx = (idx + 1) % TABLE_SIZE;
            if (idx == start_idx)
                break; // full circle
        }
        return -1; // not found
    }

    // Delete key using DEL marker
    void remove(int key) {
        int idx = search(key);
        if (idx == -1) {
            cout &lt;&lt; key &lt;&lt; " not found in table." &lt;&lt; endl;
        } else {
            table[idx] = DELETED;
            cout &lt;&lt; "Deleted " &lt;&lt; key &lt;&lt; " from index " &lt;&lt; idx &lt;&lt; endl;
        }
    }

    // Display table
    void display() {
        cout &lt;&lt; "Hash Table:" &lt;&lt; endl;
        for (int i = 0; i &lt; TABLE_SIZE; i++) {
            cout &lt;&lt; i &lt;&lt; " : ";
            if (table[i] == EMPTY) cout &lt;&lt; "-";
            else if (table[i] == DELETED) cout &lt;&lt; "DEL";
            else cout &lt;&lt; table[i];
            cout &lt;&lt; endl;
        }
    }
};

int main() {
    HashTable ht;

    ht.insert(10);
    ht.insert(20);
    ht.insert(15);
    ht.insert(7);
    ht.insert(14);

    ht.display();

    cout &lt;&lt; "\nSearching for 14: ";
    int idx = ht.search(14);
    if (idx != -1) cout &lt;&lt; "Found at index " &lt;&lt; idx &lt;&lt; endl;
    else cout &lt;&lt; "Not found" &lt;&lt; endl;

    cout &lt;&lt; "\nDeleting 15..." &lt;&lt; endl;
    ht.remove(15);
    ht.display();

    cout &lt;&lt; "\nInserting 22..." &lt;&lt; endl;
    ht.insert(22);
    ht.display();

    return 0;
}
</code></pre>

<h4>Sample Output</h4>
<pre class="diagram">
Inserted 10 at index 3
Inserted 20 at index 6
Inserted 15 at index 1
Inserted 7 at index 0
Inserted 14 at index 2
Hash Table:
0 : 7
1 : 15
2 : 14
3 : 10
4 : -
5 : -
6 : 20

Searching for 14: Found at index 2

Deleting 15...
Deleted 15 from index 1
Hash Table:
0 : 7
1 : DEL
2 : 14
3 : 10
4 : -
5 : -
6 : 20

Inserting 22...
Inserted 22 at index 1
Hash Table:
0 : 7
1 : 22
2 : 14
3 : 10
4 : -
5 : -
6 : 20
</pre>
<h1>Quadratic Probing Overview</h1>

<h2>Concept</h2>
<p>When a collision occurs, instead of checking the next slot (i+1), we check slots according to a quadratic function of the attempt number.</p>

<h2>Formula</h2>
<pre>h'(key, i) = (h(key) + i^2) % table_size</pre>
<ul>
    <li>h(key) = original hash</li>
    <li>i = 0,1,2,… number of attempts</li>
    <li>table_size = size of hash table (usually prime for better distribution)</li>
</ul>

<h2>Advantages over linear probing</h2>
<ul>
    <li>Reduces primary clustering</li>
    <li>Spread elements more evenly</li>
</ul>

<h2>Disadvantages</h2>
<ul>
    <li>More complex than linear probing</li>
    <li>Deletion is tricky (requires a “deleted” marker)</li>
    <li>Can’t guarantee probing all slots unless table size and step are chosen carefully</li>
</ul>

<h2>Operations</h2>
<ul>
    <li><strong>Insert(key):</strong> Compute index = h(key). If occupied, try (index + i^2) % table_size until empty slot found. Place key there.</li>
    <li><strong>Search(key):</strong> Compute index = h(key). If key not there, probe using (index + i^2) % table_size until found or empty slot.</li>
    <li><strong>Delete(key):</strong> Search key. Mark as deleted (lazy deletion) instead of clearing to keep probe sequence intact.</li>
</ul>

<h2>Example</h2>
<p>Hash Function: h(key) = key % 7<br>
Table Size: 7<br>
Keys to insert: 10, 20, 15, 7, 14</p>

<ul>
    <li>Step 1: Insert 10 → 10 % 7 = 3 → empty → place 10 at index 3</li>
    <li>Step 2: Insert 20 → 20 % 7 = 6 → empty → place 20 at index 6</li>
    <li>Step 3: Insert 15 → 15 % 7 = 1 → empty → place 15 at index 1</li>
    <li>Step 4: Insert 7 → 7 % 7 = 0 → empty → place 7 at index 0</li>
    <li>Step 5: Insert 14 → 14 % 7 = 0 → collision
        <ul>
            <li>i=1 → (0 + 1^2) % 7 = 1 → collision</li>
            <li>i=2 → (0 + 2^2) % 7 = 4 → empty → place 14 at index 4</li>
        </ul>
    </li>
</ul>

<h3>Textual Table</h3>
<pre class="diagram">
Index: 0   1   2   3   4   5   6
Value: 7  15  -  10  14  -  20
</pre>

<h2>C Code Implementation</h2>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define TABLE_SIZE 7
#define EMPTY -1
#define DELETED -2

int hashTable[TABLE_SIZE];

// Initialize table
void initTable() {
    for(int i = 0; i &lt; TABLE_SIZE; i++)
        hashTable[i] = EMPTY;
}

// Hash function
int hash(int key) {
    return key % TABLE_SIZE;
}

// Insert key using Quadratic Probing
void insert(int key) {
    int index = hash(key);
    int i = 0;
    while(i &lt; TABLE_SIZE) {
        int newIndex = (index + i*i) % TABLE_SIZE;
        if(hashTable[newIndex] == EMPTY || hashTable[newIndex] == DELETED) {
            hashTable[newIndex] = key;
            printf("Inserted %d at index %d\n", key, newIndex);
            return;
        }
        i++;
    }
    printf("Hash table full, cannot insert %d\n", key);
}

// Search key
int search(int key) {
    int index = hash(key);
    int i = 0;
    while(i &lt; TABLE_SIZE) {
        int newIndex = (index + i*i) % TABLE_SIZE;
        if(hashTable[newIndex] == EMPTY) 
            return -1; // Not found
        if(hashTable[newIndex] == key)
            return newIndex;
        i++;
    }
    return -1; // Not found
}

// Delete key
void delete(int key) {
    int idx = search(key);
    if(idx != -1) {
        hashTable[idx] = DELETED;
        printf("Deleted %d from index %d\n", key, idx);
    } else {
        printf("%d not found in hash table\n", key);
    }
}

// Display table
void display() {
    printf("Hash Table:\n");
    for(int i = 0; i &lt; TABLE_SIZE; i++)
        printf("Index %d: %d\n", i, hashTable[i]);
}

int main() {
    initTable();
    
    insert(10);
    insert(20);
    insert(15);
    insert(7);
    insert(14);

    display();

    printf("Searching 20: index %d\n", search(20));
    delete(15);
    display();

    return 0;
}
</code></pre>

<h2>Expected Output</h2>
<pre class="diagram">
Inserted 10 at index 3
Inserted 20 at index 6
Inserted 15 at index 1
Inserted 7 at index 0
Inserted 14 at index 4
Hash Table:
Index 0: 7
Index 1: 15
Index 2: -1
Index 3: 10
Index 4: 14
Index 5: -1
Index 6: 20
Searching 20: index 6
Deleted 15 from index 1
Hash Table:
Index 0: 7
Index 1: -2
Index 2: -1
Index 3: 10
Index 4: 14
Index 5: -1
Index 6: 20
</pre>

<h1>Double Hashing Overview</h1>

<h2>Concept</h2>
<p>When a collision occurs, instead of just moving linearly or quadratically, we use a second hash function to calculate the step size.</p>

<h2>Formula for probing</h2>
<pre>h'(key, i) = (h1(key) + i * h2(key)) % table_size</pre>
<ul>
    <li>h1(key) → primary hash</li>
    <li>h2(key) → secondary hash (must not be zero)</li>
    <li>i → attempt number (0,1,2,...)</li>
</ul>

<h2>Rules</h2>
<ul>
    <li>Table size should ideally be prime to avoid cycles.</li>
    <li>Step size from h2(key) should be relatively prime to table size.</li>
</ul>

<h2>Operations</h2>
<ul>
    <li><strong>Insert(key):</strong> Compute index using double hash formula. If slot is empty or deleted, place key there. Otherwise, increment i and try again.</li>
    <li><strong>Search(key):</strong> Same probing sequence. Stop when key is found or an empty slot is reached.</li>
    <li><strong>Delete(key):</strong> Mark slot as “deleted” (lazy deletion) so probing sequence doesn’t break.</li>
</ul>

<h2>Example</h2>
<p>Hash Table size: 7 (prime)<br>
Keys to insert: 10, 20, 15, 7, 14</p>

<p>Hash functions:</p>
<ul>
    <li>h1(key) = key % 7</li>
    <li>h2(key) = 5 - (key % 5)   // step size</li>
</ul>

<h3>Step-by-step Insert</h3>
<ul>
    <li>Insert 10: h1(10) = 10 % 7 = 3 → Slot 3 empty → insert 10</li>
    <li>Insert 20: h1(20) = 20 % 7 = 6 → Slot 6 empty → insert 20</li>
    <li>Insert 15: h1(15) = 15 % 7 = 1 → Slot 1 empty → insert 15</li>
    <li>Insert 7: h1(7) = 7 % 7 = 0 → Slot 0 empty → insert 7</li>
    <li>Insert 14: h1(14) = 14 % 7 = 0 → collision
        <ul>
            <li>h2(14) = 5 - (14 % 5) = 1</li>
            <li>i=1: (0 + 1*1) % 7 = 1 → occupied</li>
            <li>i=2: (0 + 2*1) % 7 = 2 → empty → insert 14 at index 2</li>
        </ul>
    </li>
</ul>

<h3>Textual Diagram</h3>
<pre class="diagram">
Index: 0   1   2   3   4   5   6
Value: 7  15  14  10  -   -  20
</pre>

<h2>C++ Implementation</h2>
<pre><code>#include &lt;iostream&gt;
using namespace std;

const int TABLE_SIZE = 7;

struct HashEntry {
    int key;
    bool deleted;
    HashEntry() { key = -1; deleted = false; }
};

class DoubleHashing {
    HashEntry table[TABLE_SIZE];

    int h1(int key) { return key % TABLE_SIZE; }
    int h2(int key) { return 5 - (key % 5); } // step size

public:
    void insert(int key) {
        int index = h1(key);
        int step = h2(key);
        int i = 0;
        while(table[(index + i*step) % TABLE_SIZE].key != -1 && 
              !table[(index + i*step) % TABLE_SIZE].deleted) {
            i++;
        }
        table[(index + i*step) % TABLE_SIZE].key = key;
        table[(index + i*step) % TABLE_SIZE].deleted = false;
    }

    bool search(int key) {
        int index = h1(key);
        int step = h2(key);
        int i = 0;
        while(i &lt; TABLE_SIZE) {
            int idx = (index + i*step) % TABLE_SIZE;
            if(table[idx].key == key &amp;&amp; !table[idx].deleted) return true;
            if(table[idx].key == -1) return false;
            i++;
        }
        return false;
    }

    void remove(int key) {
        int index = h1(key);
        int step = h2(key);
        int i = 0;
        while(i &lt; TABLE_SIZE) {
            int idx = (index + i*step) % TABLE_SIZE;
            if(table[idx].key == key &amp;&amp; !table[idx].deleted) {
                table[idx].deleted = true;
                return;
            }
            if(table[idx].key == -1) return;
            i++;
        }
    }

    void display() {
        for(int i=0;i&lt;TABLE_SIZE;i++){
            if(table[i].key != -1 &amp;&amp; !table[i].deleted)
                cout &lt;&lt; i &lt;&lt; " -&gt; " &lt;&lt; table[i].key &lt;&lt; endl;
            else
                cout &lt;&lt; i &lt;&lt; " -&gt; " &lt;&lt; "-" &lt;&lt; endl;
        }
    }
};

int main() {
    DoubleHashing dh;
    dh.insert(10);
    dh.insert(20);
    dh.insert(15);
    dh.insert(7);
    dh.insert(14);

    cout &lt;&lt; "Hash Table:" &lt;&lt; endl;
    dh.display();

    cout &lt;&lt; "\nSearch 15: " &lt;&lt; (dh.search(15) ? "Found" : "Not Found") &lt;&lt; endl;
    dh.remove(15);
    cout &lt;&lt; "After deleting 15:" &lt;&lt; endl;
    dh.display();

    return 0;
}
</code></pre>

<h2>Output</h2>
<pre class="diagram">
Hash Table:
0 -> 7
1 -> 15
2 -> 14
3 -> 10
4 -> -
5 -> -
6 -> 20

Search 15: Found
After deleting 15:
0 -> 7
1 -> -
2 -> 14
3 -> 10
4 -> -
5 -> -
6 -> 20
</pre>
<h1>Tree (Data Structure)</h1>

<p>A tree is a hierarchical data structure consisting of nodes connected by edges. Unlike arrays or lists, trees are non-linear, meaning data isn’t in a single straight line.</p>
<p>It’s basically like a family tree but with no messy gossip.</p>

<h2>Key Terminology</h2>
<table>
    <tr>
        <th>Term</th>
        <th>Meaning</th>
    </tr>
    <tr>
        <td>Node</td>
        <td>Basic unit of a tree, contains data</td>
    </tr>
    <tr>
        <td>Root</td>
        <td>Topmost node (no parent)</td>
    </tr>
    <tr>
        <td>Parent</td>
        <td>Node with child nodes</td>
    </tr>
    <tr>
        <td>Child</td>
        <td>Node under another node</td>
    </tr>
    <tr>
        <td>Leaf</td>
        <td>Node with no children</td>
    </tr>
    <tr>
        <td>Sibling</td>
        <td>Nodes with the same parent</td>
    </tr>
    <tr>
        <td>Edge</td>
        <td>Connection between parent and child</td>
    </tr>
    <tr>
        <td>Height</td>
        <td>Max number of edges from root to leaf</td>
    </tr>
    <tr>
        <td>Depth</td>
        <td>Number of edges from root to a node</td>
    </tr>
    <tr>
        <td>Subtree</td>
        <td>Tree formed by a node and its descendants</td>
    </tr>
</table>

<h2>Types of Trees</h2>

<h3>General Tree</h3>
<p>A General Tree is a tree in which a node can have any number of children (0, 1, 2, 3… no limit). Unlike binary trees, there’s no restriction on the number of children.</p>
<p>Think of it like a family tree or an organization chart: some managers have 2 direct reports, some have 5.</p>

<h4>Key Features</h4>
<ul>
    <li>Root node: Topmost node (no parent)</li>
    <li>Parent and Child nodes: Nodes are connected hierarchically</li>
    <li>Leaf nodes: Nodes with no children</li>
    <li>Internal nodes: Nodes with at least one child</li>
    <li>Edge: Connection between parent and child</li>
    <li>Subtree: Any node with its descendants forms a subtree</li>
    <li>Depth: Number of edges from root to a node</li>
    <li>Height: Maximum depth of the tree</li>
</ul>

<h4>Operations on General Tree</h4>
<table>
    <tr>
        <th>Operation</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>insert(parent, child)</td>
        <td>Add a new node under a specific parent</td>
    </tr>
    <tr>
        <td>delete(node)</td>
        <td>Remove a node and its subtree</td>
    </tr>
    <tr>
        <td>traverse()</td>
        <td>Visit all nodes (DFS or BFS)</td>
    </tr>
    <tr>
        <td>search(value)</td>
        <td>Find a node with given value</td>
    </tr>
</table>

<h4>Representation</h4>
<p><strong>Using Node Structure</strong></p>
<pre><code>struct Node {
    int data;
    struct Node* children[10]; // or dynamic array/list
    int child_count;
};</code></pre>

<p><strong>Using Linked List of Children</strong></p>
<p>Each node points to its first child and next sibling. Efficient for trees with varying number of children.</p>

<h4>Example (Textual Diagram)</h4>
<pre><code>               CEO
           /    |     \
       CTO      CFO    COO
      /   \            |
  Dev1    Dev2        Ops1</code></pre>

<ul>
    <li>Root: CEO</li>
    <li>Children of CEO: CTO, CFO, COO</li>
    <li>Leaf nodes: Dev1, Dev2, Ops1</li>
    <li>Subtree of CTO: CTO → Dev1, Dev2</li>
</ul>

<h4>Traversal Example</h4>
<ul>
    <li>Depth-First (Preorder): CEO → CTO → Dev1 → Dev2 → CFO → COO → Ops1</li>
    <li>Breadth-First (Level Order): CEO → CTO → CFO → COO → Dev1 → Dev2 → Ops1</li>
</ul>

<h4>Use Cases</h4>
<ul>
    <li>Organization hierarchies</li>
    <li>File system directories</li>
    <li>XML/HTML DOM trees</li>
    <li>Decision trees in AI</li>
</ul>

<h3>Binary Tree</h3>
<p>A Binary Tree is a tree data structure where each node has at most two children, usually called the left child and right child.</p>
<p>It’s simple, structured, and forms the basis for many advanced structures like BST, Heap, and AVL trees.</p>

<h4>Full Binary Tree</h4>
<p>A Full Binary Tree is a binary tree in which every node has either 0 or 2 children.</p>
<ul>
    <li>0 children → Leaf node</li>
    <li>2 children → Internal node</li>
    <li>1 child → Not allowed</li>
</ul>
<p>Think of it like a perfectly polite family: either you have both kids or none.</p>

<h4>Properties</h4>
<ul>
    <li>Number of nodes n and number of leaves l relation: l = (n + 1) / 2</li>
    <li>Height h relation: n = 2^(h+1) - 1</li>
    <li>All internal nodes have exactly 2 children.</li>
</ul>

<h4>Example Full Binary Tree</h4>
<pre><code>        1
       / \
      2   3
     / \  / \
    4  5 6  7</code></pre>

<ul>
    <li>Root: 1</li>
    <li>Leaves: 4, 5, 6, 7</li>
    <li>Internal Nodes: 1, 2, 3</li>
    <li>Total Nodes: 7</li>
</ul>

<h4>Textual Diagram</h4>
<pre><code>Level 0:          1
Level 1:       2       3
Level 2:     4   5   6   7</code></pre>

<h4>C Code Implementation (Full Binary Tree Traversal)</h4>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// Node structure
struct Node {
    int data;
    struct Node* left;
    struct Node* right;
};

// Create new node
struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

// Inorder Traversal
void inorder(struct Node* root) {
    if(root == NULL) return;
    inorder(root->left);
    printf("%d ", root->data);
    inorder(root->right);
}

// Preorder Traversal
void preorder(struct Node* root) {
    if(root == NULL) return;
    printf("%d ", root->data);
    preorder(root->left);
    preorder(root->right);
}

// Postorder Traversal
void postorder(struct Node* root) {
    if(root == NULL) return;
    postorder(root->left);
    postorder(root->right);
    printf("%d ", root->data);
}

int main() {
    // Constructing a Full Binary Tree
    struct Node* root = createNode(1);
    root->left = createNode(2);
    root->right = createNode(3);
    root->left->left = createNode(4);
    root->left->right = createNode(5);
    root->right->left = createNode(6);
    root->right->right = createNode(7);

    printf("Inorder Traversal: ");
    inorder(root);
    printf("\n");

    printf("Preorder Traversal: ");
    preorder(root);
    printf("\n");

    printf("Postorder Traversal: ");
    postorder(root);
    printf("\n");

    return 0;
}</code></pre>

<p><strong>Output:</strong></p>
<pre><code>Inorder Traversal: 4 2 5 1 6 3 7
Preorder Traversal: 1 2 4 5 3 6 7
Postorder Traversal: 4 5 2 6 7 3 1</code></pre>

<p><strong>Why Full Binary Trees Matter</strong></p>
<ul>
    <li>Predictable structure → useful in theoretical questions</li>
    <li>Base for Perfect Binary Trees and Complete Binary Trees</li>
    <li>Helps in understanding tree formulas and traversal logic</li>
    <li>Used in expression trees and heap construction</li>
</ul>

<h4>Perfect Binary Tree (PBT)</h4>
<p>A Perfect Binary Tree is a binary tree in which:</p>
<ul>
    <li>All internal nodes have exactly two children.</li>
    <li>All leaf nodes are at the same level.</li>
</ul>
<p>Think of it as a completely symmetrical tree. Nothing messy allowed.</p>

<h4>Properties of Perfect Binary Tree</h4>
<ul>
    <li>Number of nodes: n = 2^(h+1) − 1, where h = height of tree</li>
    <li>Number of leaf nodes: 2^h</li>
    <li>Height: h = log2(n + 1) − 1</li>
    <li>Fullness: Always a full binary tree, but not all full binary trees are perfect.</li>
</ul>

<h4>Example</h4>
<p>Height (h) = 2</p>
<pre><code>          1
        /   \
      2       3
     / \     / \
    4   5   6   7</code></pre>

<ul>
    <li>Leaf Nodes: 4, 5, 6, 7</li>
    <li>Internal Nodes: 1, 2, 3</li>
    <li>Total Nodes = 7 (matches 2^3 − 1 = 7)</li>
</ul>

<h4>Textual Diagram (Levels)</h4>
<pre><code>Level 0:        1
Level 1:     2      3
Level 2:   4   5  6   7</code></pre>

<h4>C Code Implementation</h4>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct Node {
    int data;
    struct Node* left;
    struct Node* right;
};

// Function to create a new node
struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

// Inorder traversal
void inorder(struct Node* root) {
    if (root == NULL) return;
    inorder(root->left);
    printf("%d ", root->data);
    inorder(root->right);
}

int main() {
    // Manually creating a perfect binary tree of height 2
    struct Node* root = createNode(1);
    root->left = createNode(2);
    root->right = createNode(3);

    root->left->left = createNode(4);
    root->left->right = createNode(5);
    root->right->left = createNode(6);
    root->right->right = createNode(7);

    printf("Inorder Traversal of Perfect Binary Tree: ");
    inorder(root);
    printf("\n");

    return 0;
}</code></pre>

<p><strong>Output:</strong></p>
<pre><code>Inorder Traversal of Perfect Binary Tree: 4 2 5 1 6 3 7</code></pre>

<p><strong>Why Perfect Binary Trees Matter</strong></p>
<ul>
    <li>They are the most balanced binary trees, giving minimum height for a given number of nodes.</li>
    <li>Used in heaps, priority queues, and efficient search algorithms.</li>
    <li>Easy to calculate number of nodes, height, leaves, etc. because formulas are predictable.</li>
</ul>

<h4>Complete Binary Tree (CBT)</h4>
<p>A Complete Binary Tree is a binary tree in which:</p>
<ul>
    <li>All levels except the last are completely filled.</li>
    <li>All nodes in the last level are as left as possible.</li>
</ul>
<p>Think of it as “no gaps on the left side of the tree, and the last row fills left to right.”</p>

<p>Note: Every perfect binary tree is a complete binary tree, but not every complete binary tree is perfect.</p>

<h4>Properties of CBT</h4>
<ul>
    <li>Height h of a CBT with n nodes: h = ⌊log2 n⌋</li>
    <li>Efficient for array representation.</li>
    <li>Good for heap implementation because insertion/deletion is predictable.</li>
</ul>

<h4>Textual Diagram</h4>
<pre><code>        1
      /   \
     2     3
    / \   / 
   4   5 6</code></pre>

<ul>
    <li>Height: 2 (edges from root to deepest leaf)</li>
    <li>Last level nodes: 4, 5, 6 (filled from left)</li>
    <li>Node 3’s right child is missing → still complete because last level fills left to right</li>
</ul>

<h4>Array Representation</h4>
<p>CBTs are easy to store in arrays:</p>
<ul>
    <li>Indexing starts at 1 (or 0, adjust formulas).</li>
    <li>For node at index i: Left child → 2*i, Right child → 2*i + 1, Parent → i/2</li>
</ul>
<p>Example: Tree above → Array: [1, 2, 3, 4, 5, 6]</p>

<h4>C Code for CBT using Array</h4>
<pre><code>#include &lt;stdio.h&gt;

#define MAX 100

int tree[MAX];
int n = 0; // number of nodes in tree

// Insert node (for CBT, append at next available position)
void insert(int value) {
    if(n >= MAX) {
        printf("Tree full!\n");
        return;
    }
    tree[n] = value;
    n++;
}

// Print Level-order (array order)
void levelOrder() {
    for(int i = 0; i &lt; n; i++)
        printf("%d ", tree[i]);
    printf("\n");
}

// Print tree structure (simple textual)
void printTree() {
    printf("Tree (Index -> Value):\n");
    for(int i = 0; i &lt; n; i++)
        printf("%d -> %d\n", i, tree[i]);
}

int main() {
    insert(1);
    insert(2);
    insert(3);
    insert(4);
    insert(5);
    insert(6);

    printf("Level-order traversal: ");
    levelOrder();

    printTree();

    return 0;
}</code></pre>

<p><strong>Output:</strong></p>
<pre><code>Level-order traversal: 1 2 3 4 5 6 
Tree (Index -> Value):
0 -> 1
1 -> 2
2 -> 3
3 -> 4
4 -> 5
5 -> 6</code></pre>

<h4>Use Cases of CBT</h4>
<ul>
    <li>Heap (Min-Heap / Max-Heap)</li>
    <li>Priority queues</li>
    <li>Efficient array-based tree storage</li>
    <li>Reduces pointer overhead compared to linked trees</li>
</ul>

<h4>Degenerate (or Pathological) Tree</h4>
<p>A degenerate tree is a binary tree where each parent node has only one child. Effectively, it behaves like a linked list, because every node points to only one other node.</p>

<h4>Key Characteristics</h4>
<ul>
    <li>Structure: Every parent has either 0 or 1 child.</li>
    <li>Height: Height = number of nodes - 1 (like a linked list).</li>
    <li>Efficiency: Search, insertion, and deletion become O(n) instead of O(log n) like a balanced tree.</li>
</ul>

<h4>When it Occurs</h4>
<p>Happens when data is inserted in sorted order into a binary search tree (BST) without balancing.</p>

<h4>Example: Inserting 1, 2, 3, 4, 5 into a BST creates a degenerate tree</h4>
<pre><code>1
 \
  2
   \
    3
     \
      4
       \
        5</code></pre>

<h4>Textual Representation</h4>
<pre><code>Node: 1 -> Right Child: 2
Node: 2 -> Right Child: 3
Node: 3 -> Right Child: 4
Node: 4 -> Right Child: 5
Node: 5 -> No children (leaf)</code></pre>

<h4>C Code Implementation</h4>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct Node {
    int data;
    struct Node* left;
    struct Node* right;
};

// Create new node
struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

// Preorder traversal
void preorder(struct Node* root) {
    if(root == NULL) return;
    printf("%d ", root->data);
    preorder(root->left);
    preorder(root->right);
}

int main() {
    // Creating a degenerate tree by inserting sorted values
    struct Node* root = createNode(1);
    root->right = createNode(2);
    root->right->right = createNode(3);
    root->right->right->right = createNode(4);
    root->right->right->right->right = createNode(5);

    printf("Preorder Traversal of Degenerate Tree: ");
    preorder(root);
    printf("\n");

    return 0;
}</code></pre>

<p><strong>Output:</strong></p>
<pre><code>Preorder Traversal of Degenerate Tree: 1 2 3 4 5</code></pre>

<h4>Why It Matters</h4>
<ul>
    <li>Worst-case BST: This is exactly what happens if you insert sorted data into an unbalanced BST.</li>
    <li>Linked-list behavior: Operations like search, insert, delete all take O(n) instead of O(log n).</li>
    <li>Solution: Use AVL tree, Red-Black tree, or self-balancing BSTs to avoid degeneration.</li>
</ul>
<h1>Binary Search Tree (BST)</h1>

<p>A <strong>BST</strong> is a binary tree with a key ordering property:</p>
<p><code>Left child &lt; Parent &lt; Right child</code></p>
<p>This property must hold for every node in the tree. This ordering allows for efficient search, insertion, and deletion.</p>

<h2>BST Properties</h2>
<ul>
    <li>Each node has at most 2 children (left and right).</li>
    <li>The left subtree of a node contains values less than the node.</li>
    <li>The right subtree of a node contains values greater than the node.</li>
    <li>No duplicate keys (usually) – some implementations allow duplicates.</li>
    <li>Average height = O(log n), worst case (degenerate) = O(n).</li>
</ul>

<h2>Example BST</h2>
<div class="diagram">
        15
       /  \
     10    20
    / \    / \
   8  12  17 25
</div>

<h3>Traversals</h3>
<ul>
    <li><strong>Inorder Traversal:</strong> 8 10 12 15 17 20 25 (sorted)</li>
    <li><strong>Preorder Traversal:</strong> 15 10 8 12 20 17 25</li>
    <li><strong>Postorder Traversal:</strong> 8 12 10 17 25 20 15</li>
</ul>

<h2>BST Operations</h2>

<h3>1. Search</h3>
<ul>
    <li>Start from root.</li>
    <li>If key &lt; node → go left.</li>
    <li>If key &gt; node → go right.</li>
    <li>Repeat until found or leaf reached.</li>
</ul>

<h3>2. Insert</h3>
<ul>
    <li>Search for the position where the key should go.</li>
    <li>Insert as a leaf node maintaining BST property.</li>
</ul>

<h3>3. Delete</h3>
<ul>
    <li>Leaf node → delete directly.</li>
    <li>Node with one child → link parent to child.</li>
    <li>Node with two children → replace with inorder successor (smallest in right subtree) or inorder predecessor (largest in left subtree).</li>
</ul>

<h2>C Code Implementation</h2>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// Node structure
struct Node {
    int data;
    struct Node* left;
    struct Node* right;
};

// Create new node
struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

// Insert node in BST
struct Node* insert(struct Node* root, int data) {
    if(root == NULL) return createNode(data);
    if(data &lt; root-&gt;data)
        root-&gt;left = insert(root-&gt;left, data);
    else if(data &gt; root-&gt;data)
        root-&gt;right = insert(root-&gt;right, data);
    return root;
}

// Search in BST
struct Node* search(struct Node* root, int key) {
    if(root == NULL || root-&gt;data == key) return root;
    if(key &lt; root-&gt;data) return search(root-&gt;left, key);
    else return search(root-&gt;right, key);
}

// Find minimum value node
struct Node* findMin(struct Node* root) {
    while(root-&gt;left != NULL) root = root-&gt;left;
    return root;
}

// Delete node in BST
struct Node* deleteNode(struct Node* root, int key) {
    if(root == NULL) return root;

    if(key &lt; root-&gt;data)
        root-&gt;left = deleteNode(root-&gt;left, key);
    else if(key &gt; root-&gt;data)
        root-&gt;right = deleteNode(root-&gt;right, key);
    else {
        // Node found
        if(root-&gt;left == NULL) {
            struct Node* temp = root-&gt;right;
            free(root);
            return temp;
        } else if(root-&gt;right == NULL) {
            struct Node* temp = root-&gt;left;
            free(root);
            return temp;
        }
        // Node with two children
        struct Node* temp = findMin(root-&gt;right);
        root-&gt;data = temp-&gt;data;
        root-&gt;right = deleteNode(root-&gt;right, temp-&gt;data);
    }
    return root;
}

// Inorder traversal
void inorder(struct Node* root) {
    if(root == NULL) return;
    inorder(root-&gt;left);
    printf("%d ", root-&gt;data);
    inorder(root-&gt;right);
}

int main() {
    struct Node* root = NULL;

    // Insert nodes
    root = insert(root, 15);
    root = insert(root, 10);
    root = insert(root, 20);
    root = insert(root, 8);
    root = insert(root, 12);
    root = insert(root, 17);
    root = insert(root, 25);

    printf("Inorder Traversal: ");
    inorder(root);
    printf("\n");

    // Search example
    int key = 12;
    struct Node* found = search(root, key);
    if(found) printf("%d found in BST\n", key);
    else printf("%d not found in BST\n", key);

    // Delete example
    root = deleteNode(root, 20);
    printf("Inorder after deleting 20: ");
    inorder(root);
    printf("\n");

    return 0;
}
</pre>

<h2>Output</h2>
<pre>
Inorder Traversal: 8 10 12 15 17 20 25
12 found in BST
Inorder after deleting 20: 8 10 12 15 17 25
</pre>

<h2>Textual Diagram After Deletion (20)</h2>
<div class="diagram">
        15
       /  \
     10    25
    / \    /
   8  12  17
</div>

<p>Notice how inorder traversal remains sorted.</p>
   <h1>AVL Tree (Adelson-Velsky and Landis Tree)</h1>

    <p>An <strong>AVL Tree</strong> is a self-balancing Binary Search Tree (BST). For every node, the height difference between its left and right subtrees is at most 1. This difference is called the <strong>balance factor</strong>:</p>

    <p><strong>Balance Factor</strong> = height(left subtree) − height(right subtree)</p>

    <p>If the balance factor &notin; {-1, 0, 1}, the tree rotates to balance.</p>

    <h2>Why AVL?</h2>
    <p>Regular BSTs can degenerate into a linked list (O(n) search). AVL keeps O(log n) time complexity for <strong>search</strong>, <strong>insert</strong>, and <strong>delete</strong>.</p>

    <h2>Rotations in AVL Trees</h2>
    <p>To fix imbalance, we use 4 types of rotations:</p>

    <h3>Right Rotation (LL case)</h3>
    <div class="diagram">
        z                               y
       / \                            /   \
      y   T4     Right Rotate(z)      x     z
     / \       - - - - - - - ->    / \   / \
    x   T3                        T1  T2 T3 T4
   / \
 T1   T2
    </div>

    <h3>Left Rotation (RR case)</h3>
    <div class="diagram">
    z                                y
   / \                             /   \
  T1  y      Left Rotate(z)       z     x
     / \   - - - - - - - ->     / \   / \
    T2  x                       T1 T2 T3 T4
       / \
     T3  T4
    </div>

    <h3>Left-Right Rotation (LR case)</h3>
    <p>First left rotation on left child, then right rotation on root.</p>

    <h3>Right-Left Rotation (RL case)</h3>
    <p>First right rotation on right child, then left rotation on root.</p>

    <h2>AVL Tree Example</h2>
    <p>Insert the sequence: 10, 20, 30, 40, 50, 25</p>

    <h4>Step-by-step:</h4>
    <ul>
        <li>Insert 10 → Tree: 10</li>
        <li>Insert 20 → Tree:
            <div class="diagram">
               10
                 \
                 20
            </div>
        </li>
        <li>Insert 30 → imbalance at 10 (RR case), rotate left:
            <div class="diagram">
                  20
                 /  \
               10    30
            </div>
        </li>
        <li>Insert 40 → Tree:
            <div class="diagram">
                  20
                 /  \
               10    30
                        \
                        40
            </div>
        </li>
        <li>Insert 50 → imbalance at 20 (RR case), rotate left:
            <div class="diagram">
                    30
                   /  \
                 20    40
                /        \
              10          50
            </div>
        </li>
        <li>Insert 25 → imbalance at 30 (LR case), rotate left-right:
            <div class="diagram">
                    30
                   /  \
                 20    40
                /  \     \
              10   25    50
            </div>
        </li>
    </ul>

    <p><strong>Root:</strong> 30</p>
    <p><strong>Height:</strong> 3</p>
    <p><strong>Balance Factor:</strong> all nodes between -1 and 1</p>

    <h2>C Code Implementation (Insert, Search, Delete)</h2>
    <pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct Node {
    int key;
    struct Node *left;
    struct Node *right;
    int height;
};

// Utility functions
int height(struct Node* N) {
    return N ? N-&gt;height : 0;
}

int max(int a, int b) { return (a &gt; b) ? a : b; }

struct Node* createNode(int key) {
    struct Node* node = (struct Node*)malloc(sizeof(struct Node));
    node-&gt;key = key;
    node-&gt;left = node-&gt;right = NULL;
    node-&gt;height = 1;
    return node;
}

// Right rotate
struct Node* rightRotate(struct Node* y) {
    struct Node* x = y-&gt;left;
    struct Node* T2 = x-&gt;right;
    x-&gt;right = y;
    y-&gt;left = T2;
    y-&gt;height = max(height(y-&gt;left), height(y-&gt;right)) +1;
    x-&gt;height = max(height(x-&gt;left), height(x-&gt;right)) +1;
    return x;
}

// Left rotate
struct Node* leftRotate(struct Node* x) {
    struct Node* y = x-&gt;right;
    struct Node* T2 = y-&gt;left;
    y-&gt;left = x;
    x-&gt;right = T2;
    x-&gt;height = max(height(x-&gt;left), height(x-&gt;right)) +1;
    y-&gt;height = max(height(y-&gt;left), height(y-&gt;right)) +1;
    return y;
}

// Get balance factor
int getBalance(struct Node* N) {
    return N ? height(N-&gt;left) - height(N-&gt;right) : 0;
}

// Insert, Delete, Search functions (as in your code)
</code></pre>

<h2>Sample Output</h2>
<pre>
Inorder traversal: 10 20 25 30 40 50
After deleting 40: 10 20 25 30 50
Key 25 found in AVL Tree.
</pre>

<h2>Why AVL Trees?</h2>
<ul>
    <li>Guarantees O(log n) search, insertion, deletion.</li>
    <li>Prevents BST degeneration.</li>
    <li>Useful in databases, indexing, memory management.</li>
</ul>

    <h1>Red-Black Tree (RBT)</h1>

    <p>A Red-Black Tree is a self-balancing Binary Search Tree (BST). It ensures that the tree stays roughly balanced, guaranteeing <strong>O(log n)</strong> time for search, insert, and delete operations. It adds a splash of color (literally) to nodes to maintain balance.</p>

    <h2>Properties of RBT</h2>
    <ul>
        <li><strong>Node Color:</strong> Every node is either Red or Black.</li>
        <li><strong>Root Property:</strong> Root is always Black.</li>
        <li><strong>Leaf Property:</strong> All leaves (NIL nodes) are Black.</li>
        <li><strong>Red Property:</strong> Red nodes cannot have red children (no two reds in a row).</li>
        <li><strong>Black-Height Property:</strong> Every path from a node to its descendant NIL nodes has the same number of black nodes.</li>
    </ul>

    <h2>Why RBT?</h2>
    <ul>
        <li>Maintains balance automatically after insert/delete.</li>
        <li>Guarantees worst-case <strong>O(log n)</strong> operations.</li>
        <li>Used in STL map/set, Linux scheduler, databases, etc.</li>
    </ul>

    <h2>Basic Operations</h2>

    <h3>Insertion</h3>
    <ul>
        <li>Insert like BST, color node Red.</li>
        <li>Fix violations by rotations and recoloring.</li>
    </ul>

    <h3>Deletion</h3>
    <ul>
        <li>Delete like BST.</li>
        <li>Fix violations to maintain RBT properties.</li>
    </ul>

    <h3>Search</h3>
    <p>Same as BST (<strong>O(log n)</strong>).</p>

    <h2>Example RBT</h2>
    <div class="diagram">
         10(B)
        /     \
     5(R)     20(B)
    /   \     /   \
  2(B) 7(B) 15(R) 30(B)
    </div>

    <p><strong>Root:</strong> Black</p>
    <p><strong>No two consecutive red nodes</strong></p>
    <p><strong>Black height same for all paths</strong></p>

    <h2>Textual Representation</h2>
    <div class="diagram">
Node(Data, Color)
10(B)
├── 5(R)
│   ├── 2(B)
│   └── 7(B)
└── 20(B)
    ├── 15(R)
    └── 30(B)
    </div>

    <h2>C Implementation</h2>
    <pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

enum Color { RED, BLACK };

typedef struct Node {
    int data;
    int color;
    struct Node *left, *right, *parent;
} Node;

Node* createNode(int data) {
    Node* node = (Node*)malloc(sizeof(Node));
    node->data = data;
    node->color = RED;
    node->left = node->right = node->parent = NULL;
    return node;
}

// Left Rotation
void leftRotate(Node **root, Node *x) {
    Node *y = x-&gt;right;
    x-&gt;right = y-&gt;left;
    if(y-&gt;left) y-&gt;left-&gt;parent = x;
    y-&gt;parent = x-&gt;parent;
    if(!x-&gt;parent) *root = y;
    else if(x == x-&gt;parent-&gt;left) x-&gt;parent-&gt;left = y;
    else x-&gt;parent-&gt;right = y;
    y-&gt;left = x;
    x-&gt;parent = y;
}

// Right Rotation
void rightRotate(Node **root, Node *y) {
    Node *x = y-&gt;left;
    y-&gt;left = x-&gt;right;
    if(x-&gt;right) x-&gt;right-&gt;parent = y;
    x-&gt;parent = y-&gt;parent;
    if(!y-&gt;parent) *root = x;
    else if(y == y-&gt;parent-&gt;left) y-&gt;parent-&gt;left = x;
    else y-&gt;parent-&gt;right = x;
    x-&gt;right = y;
    y-&gt;parent = x;
}

// Fix Insertion
void fixInsert(Node **root, Node *z) {
    while(z-&gt;parent &amp;&amp; z-&gt;parent-&gt;color == RED) {
        Node *grand = z-&gt;parent-&gt;parent;
        if(z-&gt;parent == grand-&gt;left) {
            Node *uncle = grand-&gt;right;
            if(uncle &amp;&amp; uncle-&gt;color == RED) {
                z-&gt;parent-&gt;color = uncle-&gt;color = BLACK;
                grand-&gt;color = RED;
                z = grand;
            } else {
                if(z == z-&gt;parent-&gt;right) {
                    z = z-&gt;parent;
                    leftRotate(root, z);
                }
                z-&gt;parent-&gt;color = BLACK;
                grand-&gt;color = RED;
                rightRotate(root, grand);
            }
        } else {
            Node *uncle = grand-&gt;left;
            if(uncle &amp;&amp; uncle-&gt;color == RED) {
                z-&gt;parent-&gt;color = uncle-&gt;color = BLACK;
                grand-&gt;color = RED;
                z = grand;
            } else {
                if(z == z-&gt;parent-&gt;left) {
                    z = z-&gt;parent;
                    rightRotate(root, z);
                }
                z-&gt;parent-&gt;color = BLACK;
                grand-&gt;color = RED;
                leftRotate(root, grand);
            }
        }
    }
    (*root)-&gt;color = BLACK;
}

// Insert Node
void insert(Node **root, int data) {
    Node *z = createNode(data);
    Node *y = NULL;
    Node *x = *root;

    while(x) {
        y = x;
        if(z-&gt;data &lt; x-&gt;data) x = x-&gt;left;
        else x = x-&gt;right;
    }

    z-&gt;parent = y;
    if(!y) *root = z;
    else if(z-&gt;data &lt; y-&gt;data) y-&gt;left = z;
    else y-&gt;right = z;

    fixInsert(root, z);
}

// Inorder Traversal
void inorder(Node* root) {
    if(!root) return;
    inorder(root-&gt;left);
    printf("%d(%s) ", root-&gt;data, root-&gt;color == RED ? "R" : "B");
    inorder(root-&gt;right);
}

// Search
Node* search(Node* root, int key) {
    while(root) {
        if(key == root-&gt;data) return root;
        else if(key &lt; root-&gt;data) root = root-&gt;left;
        else root = root-&gt;right;
    }
    return NULL;
}

int main() {
    Node* root = NULL;
    int keys[] = {10, 20, 30, 15, 25, 5, 2};
    for(int i=0;i&lt;7;i++) insert(&amp;root, keys[i]);

    printf("Inorder Traversal of RBT:\n");
    inorder(root);
    printf("\n");

    int s = 15;
    Node* found = search(root, s);
    if(found) printf("Node %d found and is %s\n", s, found-&gt;color == RED ? "RED" : "BLACK");
    else printf("Node %d not found\n", s);

    return 0;
}
</code></pre>

<h2>Output Example</h2>
<p>2(B) 5(R) 10(B) 15(R) 20(B) 25(R) 30(B)</p>
<p>Node 15 found and is RED</p>

<h2>Important Notes</h2>
<ul>
    <li>Deletion in RBT is more complex because we need to maintain properties, usually handled with double-black fixes.</li>
    <li>RBT guarantees <strong>O(log n)</strong> search, insertion, deletion in all cases.</li>
</ul>
<h1>Graph (ADT) – In Depth</h1>

<p>A graph is an Abstract Data Type that represents relationships between objects. Objects are called <strong>vertices (nodes)</strong>, and relationships are called <strong>edges (links)</strong>.</p>

<p>Think of it as a network: cities connected by roads, people connected by friendships, or web pages connected by links.</p>

<h2>Key Components</h2>

<h3>Vertex (V)</h3>
<p>Represents an entity.<br>
Example: A, B, C, D</p>

<h3>Edge (E)</h3>
<p>Represents a connection between vertices.</p>
<ul>
    <li><strong>Directed:</strong> edge has direction (A → B)</li>
    <li><strong>Undirected:</strong> edge has no direction (A — B)</li>
</ul>

<h3>Weight (optional)</h3>
<p>Represents cost, distance, or capacity of the edge.</p>
<ul>
    <li>Weighted graph: edges have values</li>
    <li>Unweighted graph: edges just exist</li>
</ul>

<h2>Types of Graphs</h2>

<h3>Directed Graph (Digraph)</h3>
<p>A Directed Graph is a graph where each edge has a direction, pointing from one vertex to another.</p>

<ul>
    <li>Vertices (V): Objects/nodes</li>
    <li>Edges (E): Ordered pairs (u, v) meaning an edge from u to v</li>
</ul>

<p><strong>Key Points:</strong></p>
<ul>
    <li>Edge (u, v) ≠ (v, u)</li>
    <li>Can be weighted or unweighted</li>
    <li>Can have cycles or be acyclic (DAG)</li>
</ul>

<h3>Applications</h3>
<ul>
    <li>Task scheduling (DAG)</li>
    <li>Web page links</li>
    <li>Course prerequisite relationships</li>
    <li>State machines</li>
    <li>Dependency resolution</li>
</ul>

<h3>Representation of Directed Graph</h3>

<h4>1. Adjacency List</h4>
<p>Memory efficient. Each vertex stores a list of outgoing edges.</p>
<p>Example Graph:</p>
<ul>
    <li>Vertices: A, B, C, D</li>
    <li>Edges: A → B, A → C, B → C, C → D</li>
</ul>

<p>Adjacency List Representation:</p>
<pre class="diagram">
A → B, C
B → C
C → D
D → 
</pre>

<h4>2. Adjacency Matrix</h4>
<p>2D array matrix[V][V], 1 if edge exists, 0 otherwise.</p>
<pre class="diagram">
    A B C D
A [ 0 1 1 0 ]
B [ 0 0 1 0 ]
C [ 0 0 0 1 ]
D [ 0 0 0 0 ]
</pre>

<h3>Code Example in C (Using Adjacency List)</h3>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct Node {
    int vertex;
    struct Node* next;
};

struct Graph {
    int numVertices;
    struct Node** adjLists;
};

// Create node
struct Node* createNode(int v) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->vertex = v;
    newNode->next = NULL;
    return newNode;
}

// Create graph
struct Graph* createGraph(int vertices) {
    struct Graph* graph = (struct Graph*)malloc(sizeof(struct Graph));
    graph->numVertices = vertices;
    graph->adjLists = (struct Node**)malloc(vertices * sizeof(struct Node*));

    for(int i = 0; i &lt; vertices; i++)
        graph->adjLists[i] = NULL;

    return graph;
}

// Add edge (directed)
void addEdge(struct Graph* graph, int src, int dest) {
    // Add edge from src to dest
    struct Node* newNode = createNode(dest);
    newNode->next = graph->adjLists[src];
    graph->adjLists[src] = newNode;
}

// Print graph
void printGraph(struct Graph* graph) {
    for(int v = 0; v &lt; graph->numVertices; v++) {
        struct Node* temp = graph->adjLists[v];
        printf("%d -> ", v);
        while(temp) {
            printf("%d ", temp->vertex);
            temp = temp->next;
        }
        printf("\n");
    }
}

int main() {
    int V = 4;
    struct Graph* graph = createGraph(V);

    addEdge(graph, 0, 1); // A->B
    addEdge(graph, 0, 2); // A->C
    addEdge(graph, 1, 2); // B->C
    addEdge(graph, 2, 3); // C->D

    printGraph(graph);

    return 0;
}
</code></pre>

<p><strong>Output (Vertices numbered 0=A, 1=B, 2=C, 3=D):</strong></p>
<pre class="diagram">
0 -> 2 1
1 -> 2
2 -> 3
3 -> 
</pre>

<p>Notice: edges are directed, so B → A does not exist.</p>

<h3>Textual Diagram</h3>
<pre class="diagram">
A → B → C → D
 \       ^
  \_____/
</pre>

<p>A points to B and C<br>
B points to C<br>
C points to D<br>
D has no outgoing edges</p>

<h3>Undirected Graph</h3>
<p>An undirected graph is a graph where edges have no direction. That means if there’s an edge between vertex A and B, you can go both ways: A ↔ B.</p>

<p><strong>Definition:</strong><br>
A graph G = (V, E) where V is the set of vertices and E is a set of unordered pairs {u, v} representing edges.</p>

<h4>Characteristics</h4>
<ul>
    <li>Edges are bidirectional: {u, v} ≡ {v, u}</li>
    <li>Degree of a vertex: Number of edges incident to it</li>
    <li>No parallel edges or self-loops in simple graphs (optional in multigraphs)</li>
    <li>Connected / Disconnected: If a path exists between all vertices, it’s connected.</li>
</ul>

<h4>Representation</h4>

<h5>1. Adjacency Matrix</h5>
<p>matrix[i][j] = 1 if edge exists between i and j, 0 otherwise. Symmetric matrix because edges are bidirectional.</p>
<p>Example:</p>
<pre class="diagram">
Vertices: A, B, C, D
Edges: A-B, A-C, B-D, C-D

    A B C D
A [ 0 1 1 0 ]
B [ 1 0 0 1 ]
C [ 1 0 0 1 ]
D [ 0 1 1 0 ]
</pre>

<h5>2. Adjacency List</h5>
<p>Each vertex stores a list of neighbors. Memory efficient for sparse graphs.</p>
<pre class="diagram">
A → B, C
B → A, D
C → A, D
D → B, C
</pre>

<h4>Operations</h4>
<ul>
    <li>addVertex(v) → Add vertex v</li>
    <li>addEdge(u, v) → Add edge {u, v}</li>
    <li>removeEdge(u, v) → Remove edge</li>
    <li>getNeighbors(v) → List of connected vertices</li>
    <li>degree(v) → Count of edges incident to vertex v</li>
</ul>

<h4>Example in C (Adjacency List)</h4>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// Structure for adjacency list node
struct Node {
    int vertex;
    struct Node* next;
};

// Graph structure
struct Graph {
    int numVertices;
    struct Node** adjLists;
};

// Create a node
struct Node* createNode(int v) {
    struct Node* newNode = malloc(sizeof(struct Node));
    newNode->vertex = v;
    newNode->next = NULL;
    return newNode;
}

// Create a graph
struct Graph* createGraph(int vertices) {
    struct Graph* graph = malloc(sizeof(struct Graph));
    graph->numVertices = vertices;
    graph->adjLists = malloc(vertices * sizeof(struct Node*));

    for(int i = 0; i &lt; vertices; i++)
        graph->adjLists[i] = NULL;

    return graph;
}

// Add edge (undirected)
void addEdge(struct Graph* graph, int src, int dest) {
    // Add edge from src to dest
    struct Node* newNode = createNode(dest);
    newNode->next = graph->adjLists[src];
    graph->adjLists[src] = newNode;

    // Add edge from dest to src
    newNode = createNode(src);
    newNode->next = graph->adjLists[dest];
    graph->adjLists[dest] = newNode;
}

// Print graph
void printGraph(struct Graph* graph) {
    for(int v = 0; v &lt; graph->numVertices; v++) {
        struct Node* temp = graph->adjLists[v];
        printf("Vertex %d: ", v);
        while(temp) {
            printf("%d -> ", temp->vertex);
            temp = temp->next;
        }
        printf("NULL\n");
    }
}

int main() {
    int vertices = 4;
    struct Graph* graph = createGraph(vertices);

    addEdge(graph, 0, 1); // A-B
    addEdge(graph, 0, 2); // A-C
    addEdge(graph, 1, 3); // B-D
    addEdge(graph, 2, 3); // C-D

    printGraph(graph);

    return 0;
}
</code></pre>

<p><strong>Output:</strong></p>
<pre class="diagram">
Vertex 0: 2 -> 1 -> NULL
Vertex 1: 3 -> 0 -> NULL
Vertex 2: 3 -> 0 -> NULL
Vertex 3: 2 -> 1 -> NULL
</pre>

<h3>Textual Diagram (Adjacency List)</h3>
<pre class="diagram">
A(0) → B(1), C(2)
B(1) → A(0), D(3)
C(2) → A(0), D(3)
D(3) → B(1), C(2)
</pre>

<h3>Diagram (Visual Representation)</h3>
<pre class="diagram">
     A
    / \
   B---D
    \ /
     C
</pre>

<h3>Use Cases of Undirected Graphs</h3>
<ul>
    <li>Social networks (friendships)</li>
    <li>Undirected road maps</li>
    <li>Network topology</li>
    <li>Molecular structures in chemistry</li>
</ul>

<h2>Cyclic Graph</h2>
<p>A cyclic graph is a graph that contains at least one cycle.</p>
<p>A cycle is a path of distinct vertices that starts and ends at the same vertex.</p>

<p>If a graph does not contain any cycles, it is acyclic.</p>

<p><strong>Key Points:</strong></p>
<ul>
    <li>Can be directed or undirected.</li>
    <li>Cycle detection is critical in many applications like:</li>
    <ul>
        <li>Deadlock detection</li>
        <li>Task scheduling</li>
        <li>Network routing</li>
    </ul>
</ul>

<h3>Example (Undirected Cyclic Graph)</h3>
<ul>
    <li>Vertices: A, B, C, D</li>
    <li>Edges: A-B, B-C, C-A, C-D</li>
</ul>

<p>Adjacency List Representation</p>
<pre class="diagram">
A → B, C
B → A, C
C → A, B, D
D → C
</pre>

<p>Adjacency Matrix Representation</p>
<pre class="diagram">
    A B C D
A [ 0 1 1 0 ]
B [ 1 0 1 0 ]
C [ 1 1 0 1 ]
D [ 0 0 1 0 ]
</pre>

<p>Cycle Present: A → B → C → A</p>

<h3>Directed Cyclic Graph Example</h3>
<ul>
    <li>Vertices: 1, 2, 3</li>
    <li>Edges: 1 → 2, 2 → 3, 3 → 1</li>
</ul>

<p>Adjacency List</p>
<pre class="diagram">
1 → 2
2 → 3
3 → 1
</pre>

<p>Cycle Present: 1 → 2 → 3 → 1</p>

<h3>Detecting a Cycle in C (Undirected Graph using DFS)</h3>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;

#define V 4

bool visited[V];

int graph[V][V] = {
    {0, 1, 1, 0},
    {1, 0, 1, 0},
    {1, 1, 0, 1},
    {0, 0, 1, 0}
};

// DFS to detect cycle in undirected graph
bool isCyclicUtil(int v, int parent) {
    visited[v] = true;
    for(int i = 0; i &lt; V; i++) {
        if(graph[v][i]) {
            if(!visited[i]) {
                if(isCyclicUtil(i, v)) return true;
            }
            else if(i != parent) { // Back edge found
                return true;
            }
        }
    }
    return false;
}

bool isCyclic() {
    for(int i = 0; i &lt; V; i++) visited[i] = false;

    for(int i = 0; i &lt; V; i++) {
        if(!visited[i]) {
            if(isCyclicUtil(i, -1)) return true;
        }
    }
    return false;
}

int main() {
    if(isCyclic())
        printf("Graph contains a cycle\n");
    else
        printf("Graph does not contain a cycle\n");
    return 0;
}
</code></pre>

<p><strong>Output:</strong> Graph contains a cycle</p>

<h3>Use Cases</h3>
<ul>
    <li>Deadlock detection in operating systems</li>
    <li>Circular dependency detection in package managers</li>
    <li>Detecting feedback loops in networks</li>
</ul>

<h2>Acyclic Graph (AG) – In Depth</h2>
<p>An Acyclic Graph is a graph that contains no cycles.</p>

<p>Cycle: A path that starts and ends at the same vertex, visiting at least one edge in between.</p>
<p>Acyclic: No way to return to the starting vertex via edges.</p>
<p>Basically, if you start walking along edges, you’ll never loop back to where you began.</p>

<h3>Types of Acyclic Graphs</h3>

<h4>Directed Acyclic Graph (DAG)</h4>
<p>A directed graph with no cycles. Important in computer science for dependencies.</p>
<ul>
    <li>Examples: Task scheduling, build systems, version control, expression trees</li>
</ul>

<h4>Undirected Acyclic Graph</h4>
<p>Any undirected graph with no cycles is called a forest (collection of trees).</p>
<p>A connected undirected acyclic graph is a tree.</p>

<h3>Properties</h3>
<ul>
    <li>Topological ordering is possible only for DAGs</li>
    <li>No backtracking cycles → can be used for dependency resolution</li>
    <li>Can have multiple sources (vertices with indegree 0)</li>
</ul>

<h3>Example (DAG)</h3>
<ul>
    <li>Vertices: A, B, C, D, E</li>
    <li>Edges: A→B, A→C, B→D, C→D, D→E</li>
</ul>

<h4>Textual Diagram</h4>
<pre class="diagram">
    A
   / \
  B   C
   \ /
    D
    |
    E
</pre>

<p>No cycles exist.</p>
<p>Can perform topological sort: A, B, C, D, E (or A, C, B, D, E)</p>

<h4>Adjacency List Representation</h4>
<pre class="diagram">
A → B, C
B → D
C → D
D → E
E → 
</pre>

<h4>Adjacency Matrix Representation</h4>
<pre class="diagram">
    A B C D E
A [ 0 1 1 0 0 ]
B [ 0 0 0 1 0 ]
C [ 0 0 0 1 0 ]
D [ 0 0 0 0 1 ]
E [ 0 0 0 0 0 ]
</pre>

<h3>C Code Example for DAG Traversal (Topological Sort using DFS)</h3>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define MAX 5

// Graph using adjacency list
typedef struct Node {
    int vertex;
    struct Node* next;
} Node;

typedef struct Graph {
    int numVertices;
    Node* adjLists[MAX];
    int visited[MAX];
} Graph;

// Create node
Node* createNode(int v) {
    Node* newNode = malloc(sizeof(Node));
    newNode->vertex = v;
    newNode->next = NULL;
    return newNode;
}

// Create graph
Graph* createGraph(int vertices) {
    Graph* graph = malloc(sizeof(Graph));
    graph->numVertices = vertices;
    for (int i = 0; i &lt; vertices; i++) {
        graph->adjLists[i] = NULL;
        graph->visited[i] = 0;
    }
    return graph;
}

// Add edge
void addEdge(Graph* graph, int src, int dest) {
    Node* newNode = createNode(dest);
    newNode->next = graph->adjLists[src];
    graph->adjLists[src] = newNode;
}

// Stack for topological sort
typedef struct Stack {
    int items[MAX];
    int top;
} Stack;

void push(Stack* s, int value) { s->items[++s->top] = value; }
int pop(Stack* s) { return s->items[s->top--]; }
int isEmpty(Stack* s) { return s->top == -1; }

// DFS for topological sort
void topologicalSortUtil(Graph* graph, int v, Stack* stack) {
    graph->visited[v] = 1;
    Node* temp = graph->adjLists[v];
    while (temp) {
        if (!graph->visited[temp->vertex])
            topologicalSortUtil(graph, temp->vertex, stack);
        temp = temp->next;
    }
    push(stack, v);
}

void topologicalSort(Graph* graph) {
    Stack stack;
    stack.top = -1;
    for (int i = 0; i &lt; graph->numVertices; i++)
        if (!graph->visited[i])
            topologicalSortUtil(graph, i, &stack);

    printf("Topological Sort: ");
    while (!isEmpty(&stack))
        printf("%c ", pop(&stack) + 'A');
    printf("\n");
}

// Main
int main() {
    Graph* graph = createGraph(MAX);

    addEdge(graph, 0, 1); // A->B
    addEdge(graph, 0, 2); // A->C
    addEdge(graph, 1, 3); // B->D
    addEdge(graph, 2, 3); // C->D
    addEdge(graph, 3, 4); // D->E

    topologicalSort(graph);

    return 0;
}
</code></pre>

<p><strong>Output:</strong> Topological Sort: A C B D E</p>
<p>Topological sort is not unique, but always respects the dependencies.</p>

<h2>Connected Graph – Definition</h2>
<p>A connected graph is an undirected graph in which there is a path between every pair of vertices.</p>
<p>In simpler terms: no vertex is isolated. Every node can reach every other node, directly or indirectly.</p>

<h4>Disconnected graph</h4>
<p>At least one pair of vertices has no path connecting them.</p>

<h4>Key point</h4>
<p>“Connected” usually refers to undirected graphs. For directed graphs, the concept splits into:</p>
<ul>
    <li>Strongly connected: a path exists in both directions between every pair.</li>
    <li>Weakly connected: underlying undirected graph is connected.</li>
</ul>

<h4>Properties</h4>
<ul>
    <li>A connected graph has at least V-1 edges (where V = number of vertices).</li>
    <li>No vertex is isolated.</li>
    <li>Can have cycles or be acyclic.</li>
</ul>

<h4>Example</h4>
<ul>
    <li>Vertices: A, B, C, D</li>
    <li>Edges: A-B, B-C, C-D</li>
</ul>

<p>Every vertex is reachable from every other vertex. ✅ Connected</p>

<h4>Textual Diagram</h4>
<pre class="diagram">
A — B — C — D
</pre>

<p>If we remove edge B-C:</p>
<pre class="diagram">
A — B   C — D
</pre>

<p>A cannot reach C or D. ❌ Disconnected</p>

<h4>Adjacency List Representation</h4>
<pre class="diagram">
A → B
B → A, C
C → B, D
D → C
</pre>

<h4>Adjacency Matrix Representation</h4>
<pre class="diagram">
    A B C D
A [ 0 1 0 0 ]
B [ 1 0 1 0 ]
C [ 0 1 0 1 ]
D [ 0 0 1 0 ]
</pre>

<h4>How to Check if a Graph is Connected</h4>
<ul>
    <li>Use DFS or BFS:</li>
    <ul>
        <li>Pick a starting vertex.</li>
        <li>Traverse all reachable vertices.</li>
        <li>If all vertices are visited, the graph is connected. Otherwise, it’s disconnected.</li>
    </ul>
</ul>

<h4>C++ Code Example</h4>
<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

void DFS(int v, vector&lt;vector&lt;int&gt;&gt;&amp; adj, vector&lt;bool&gt;&amp; visited) {
    visited[v] = true;
    for(int u : adj[v]) {
        if(!visited[u])
            DFS(u, adj, visited);
    }
}

bool isConnected(vector&lt;vector&lt;int&gt;&gt;&amp; adj, int V) {
    vector&lt;bool&gt; visited(V, false);
    DFS(0, adj, visited); // start from vertex 0

    for(bool v : visited) {
        if(!v) return false;
    }
    return true;
}

int main() {
    int V = 4;
    vector&lt;vector&lt;int&gt;&gt; adj(V);

    // edges: A-B, B-C, C-D
    adj[0].push_back(1); // A-B
    adj[1].push_back(0); // B-A
    adj[1].push_back(2); // B-C
    adj[2].push_back(1); // C-B
    adj[2].push_back(3); // C-D
    adj[3].push_back(2); // D-C

    if(isConnected(adj, V))
        cout &lt;&lt; "Graph is connected\n";
    else
        cout &lt;&lt; "Graph is disconnected\n";

    return 0;
}
</code></pre>

<p><strong>Output:</strong> Graph is connected</p>

<h3>Applications of Connected Graphs</h3>
<ul>
    <li>Road networks where every city is reachable</li>
    <li>Communication networks (no isolated nodes)</li>
    <li>Network reliability analysis</li>
    <li>Social networks (everyone can indirectly reach everyone else)</li>
</ul>

<h2>Disconnected Graph</h2>
<p>A Disconnected Graph is a graph in which at least one pair of vertices has no path connecting them.</p>
<p>Opposite of a Connected Graph, where every vertex can reach every other vertex.</p>

<p>Can be directed or undirected. Often arises in networks with isolated components.</p>

<h4>Characteristics</h4>
<ul>
    <li>Not all vertices are reachable from every other vertex.</li>
    <li>Can have multiple connected components.</li>
    <li>Can be sparse or dense, weighted or unweighted.</li>
</ul>

<h4>Example</h4>
<ul>
    <li>Vertices: A, B, C, D, E</li>
    <li>Edges: A-B, B-C, D-E</li>
</ul>

<p>A-B-C forms one connected component.<br>
D-E forms another connected component.<br>
There is no path between these two components.</p>

<h4>Adjacency List Representation</h4>
<pre class="diagram">
A → B
B → A, C
C → B
D → E
E → D
</pre>

<h4>Adjacency Matrix Representation</h4>
<pre class="diagram">
    A B C D E
A [ 0 1 0 0 0 ]
B [ 1 0 1 0 0 ]
C [ 0 1 0 0 0 ]
D [ 0 0 0 0 1 ]
E [ 0 0 0 1 0 ]
</pre>

<h4>Textual Diagram</h4>
<pre class="diagram">
Component 1:        Component 2:
    A                   D
    |                   |
    B                   E
    |
    C
</pre>

<h4>Code Example (C++) – Using Adjacency List</h4>
<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

void dfs(int v, vector&lt;bool&gt; &amp;visited, vector&lt;vector&lt;int&gt;&gt; &amp;adj) {
    visited[v] = true;
    cout &lt;&lt; v &lt;&lt; " ";
    for (int u : adj[v]) {
        if (!visited[u])
            dfs(u, visited, adj);
    }
}

int main() {
    int V = 5; // Number of vertices
    vector&lt;vector&lt;int&gt;&gt; adj(V);

    // Edges: A-B, B-C, D-E
    adj[0] = {1};       // A -> B
    adj[1] = {0, 2};    // B -> A, C
    adj[2] = {1};       // C -> B
    adj[3] = {4};       // D -> E
    adj[4] = {3};       // E -> D

    vector&lt;bool&gt; visited(V, false);
    int components = 0;

    // Find connected components
    for (int i = 0; i &lt; V; i++) {
        if (!visited[i]) {
            cout &lt;&lt; "Component " &lt;&lt; components + 1 &lt;&lt; ": ";
            dfs(i, visited, adj);
            cout &lt;&lt; endl;
            components++;
        }
    }

    cout &lt;&lt; "Total components: " &lt;&lt; components &lt;&lt; endl;
    return 0;
}
</code></pre>

<p><strong>Output:</strong></p>
<pre class="diagram">
Component 1: 0 1 2 
Component 2: 3 4 
Total components: 2
</pre>

<p>Here, vertices are numbered 0:A, 1:B, 2:C, 3:D, 4:E. Shows clearly that there are two disconnected components.</p>

<h3>Applications / Use Cases</h3>
<ul>
    <li>Social networks with isolated clusters</li>
    <li>Computer networks with unreachable nodes</li>
    <li>Road networks with disconnected cities</li>
</ul>
<h2>Graph Representation</h2>

<h3>Adjacency Matrix (Graph Representation)</h3>
<p>An Adjacency Matrix is a 2D array used to represent a graph. It stores information about whether pairs of vertices are connected by an edge (and optionally the weight of that edge).</p>

<ul>
    <li><strong>Vertices:</strong> Represented by rows and columns</li>
    <li><strong>Edges:</strong> Represented by entries in the matrix</li>
</ul>

<h4>Key Points</h4>
<ul>
    <li><strong>Size:</strong> For a graph with V vertices, the matrix size is V × V.</li>
    <li><strong>Unweighted Graph:</strong>
        <ul>
            <li>matrix[i][j] = 1 if there is an edge from vertex i to vertex j</li>
            <li>matrix[i][j] = 0 if there is no edge</li>
        </ul>
    </li>
    <li><strong>Weighted Graph:</strong>
        <ul>
            <li>matrix[i][j] = weight if an edge exists</li>
            <li>matrix[i][j] = 0 or ∞ if no edge</li>
        </ul>
    </li>
    <li><strong>Memory Complexity:</strong> O(V<sup>2</sup>)</li>
    <li><strong>Edge Lookup:</strong> O(1) – super fast</li>
    <li><strong>Best for:</strong> Dense graphs</li>
    <li><strong>Not ideal for:</strong> Sparse graphs (most entries will be 0)</li>
</ul>

<h4>Example (Unweighted Undirected Graph)</h4>
<p>Graph:</p>
<ul>
    <li>Vertices: A, B, C, D</li>
    <li>Edges: A-B, A-C, B-D, C-D</li>
</ul>

<h4>Adjacency Matrix Representation</h4>
<pre>
    A B C D
A [ 0 1 1 0 ]
B [ 1 0 0 1 ]
C [ 1 0 0 1 ]
D [ 0 1 1 0 ]
</pre>

<h4>Explanation:</h4>
<ul>
    <li>Row A: 1 at columns B and C → edges A-B, A-C</li>
    <li>Row B: 1 at columns A and D → edges B-A, B-D</li>
    <li>Symmetric because the graph is undirected</li>
</ul>

<h4>Textual Diagram</h4>
<pre>
Vertices: A, B, C, D
Edges: 
A — B
A — C
B — D
C — D
Matrix:
      A B C D
    A 0 1 1 0
    B 1 0 0 1
    C 1 0 0 1
    D 0 1 1 0
</pre>

<h4>C Code Example</h4>
<pre>
#include &lt;stdio.h&gt;
#define V 4  // Number of vertices

int main() {
    int adjMatrix[V][V] = {0};

    // Add edges: A=0, B=1, C=2, D=3
    adjMatrix[0][1] = 1; // A-B
    adjMatrix[1][0] = 1; // B-A (undirected)
    
    adjMatrix[0][2] = 1; // A-C
    adjMatrix[2][0] = 1; // C-A

    adjMatrix[1][3] = 1; // B-D
    adjMatrix[3][1] = 1; // D-B

    adjMatrix[2][3] = 1; // C-D
    adjMatrix[3][2] = 1; // D-C

    // Print adjacency matrix
    printf("  A B C D\n");
    for(int i = 0; i &lt; V; i++) {
        printf("%c ", 'A' + i);
        for(int j = 0; j &lt; V; j++) {
            printf("%d ", adjMatrix[i][j]);
        }
        printf("\n");
    }

    return 0;
}
</pre>

<h4>Output</h4>
<pre>
  A B C D
A 0 1 1 0
B 1 0 0 1
C 1 0 0 1
D 0 1 1 0
</pre>

<h4>Advantages</h4>
<ul>
    <li>Simple and easy to implement</li>
    <li>Quick check if an edge exists (O(1))</li>
    <li>Easy for algorithms like Floyd-Warshall (all-pairs shortest path)</li>
</ul>

<h4>Disadvantages</h4>
<ul>
    <li>Wasteful for sparse graphs (O(V<sup>2</sup>) memory)</li>
    <li>Hard to iterate only over edges efficiently</li>
</ul>

<h3>Adjacency List – In Depth</h3>
<p>An Adjacency List represents a graph as an array (or list) of lists. Each vertex has a list of all vertices it is directly connected to.</p>

<ul>
    <li>Efficient for sparse graphs</li>
    <li>Saves memory compared to adjacency matrix (doesn’t store 0s for non-existent edges)</li>
    <li>Traversal operations like BFS/DFS are fast</li>
</ul>

<h4>Key Points</h4>
<ul>
    <li>Each vertex has a list of neighbors.</li>
    <li>Directed graph: list contains only outgoing edges.</li>
    <li>Undirected graph: each edge is represented twice (once for each vertex).</li>
    <li>Weighted graph: each list entry stores (neighbor, weight).</li>
</ul>

<h4>Example Graph</h4>
<ul>
    <li>Vertices: A, B, C, D</li>
    <li>Edges: A-B, A-C, B-D, C-D</li>
</ul>

<h4>Undirected Graph Adjacency List</h4>
<pre>
A → B, C
B → A, D
C → A, D
D → B, C
</pre>

<h4>Directed Graph Adjacency List (Edges: A→B, A→C, B→D, C→D)</h4>
<pre>
A → B, C
B → D
C → D
D → -
</pre>

<h4>Textual Diagram</h4>
<table>
    <tr>
        <th>Vertex</th>
        <th>Adjacent Vertices</th>
    </tr>
    <tr><td>A</td><td>B → C</td></tr>
    <tr><td>B</td><td>A → D</td></tr>
    <tr><td>C</td><td>A → D</td></tr>
    <tr><td>D</td><td>B → C</td></tr>
</table>

<h4>C Code Example (Undirected Graph)</h4>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// Node structure for adjacency list
struct Node {
    int dest;
    struct Node* next;
};

// Graph structure
struct Graph {
    int V;              // number of vertices
    struct Node** adj;  // array of pointers to Node
};

// Create a new node
struct Node* newNode(int dest) {
    struct Node* node = (struct Node*)malloc(sizeof(struct Node));
    node->dest = dest;
    node->next = NULL;
    return node;
}

// Create a graph with V vertices
struct Graph* createGraph(int V) {
    struct Graph* graph = (struct Graph*)malloc(sizeof(struct Graph));
    graph->V = V;
    graph->adj = (struct Node**)malloc(V * sizeof(struct Node*));
    for (int i = 0; i &lt; V; i++)
        graph->adj[i] = NULL;
    return graph;
}

// Add an edge (undirected)
void addEdge(struct Graph* graph, int src, int dest) {
    // Add edge from src to dest
    struct Node* node = newNode(dest);
    node->next = graph->adj[src];
    graph->adj[src] = node;

    // Add edge from dest to src (undirected)
    node = newNode(src);
    node->next = graph->adj[dest];
    graph->adj[dest] = node;
}

// Print adjacency list
void printGraph(struct Graph* graph) {
    for (int v = 0; v &lt; graph->V; v++) {
        struct Node* temp = graph->adj[v];
        printf("%d: ", v);
        while (temp) {
            printf("%d -> ", temp->dest);
            temp = temp->next;
        }
        printf("NULL\n");
    }
}

// Driver
int main() {
    int V = 4;
    struct Graph* graph = createGraph(V);
    addEdge(graph, 0, 1); // A-B
    addEdge(graph, 0, 2); // A-C
    addEdge(graph, 1, 3); // B-D
    addEdge(graph, 2, 3); // C-D

    printGraph(graph);
    return 0;
}
</pre>

<h4>Sample Output</h4>
<pre>
0: 2 -> 1 -> NULL
1: 3 -> 0 -> NULL
2: 3 -> 0 -> NULL
3: 2 -> 1 -> NULL
</pre>

<h4>Advantages</h4>
<ul>
    <li>Memory efficient for sparse graphs</li>
    <li>Easy to traverse neighbors</li>
    <li>Supports both directed and undirected graphs</li>
</ul>

<h4>Disadvantages</h4>
<ul>
    <li>Checking if an edge exists between two vertices can be slower (O(V) in worst case)</li>
</ul>

<h2>Graph Traversal</h2>

<h3>Breadth-First Search (BFS)</h3>
<p>BFS is a graph traversal algorithm that explores the graph level by level. Starts at a source vertex. Visits all neighbors before moving to the next level. Uses a queue to keep track of vertices to visit.</p>

<p>Think of it like spreading news in a town: the closest people hear it first, then their neighbors, and so on.</p>

<h4>Properties of BFS</h4>
<ul>
    <li>Visits each vertex once.</li>
    <li>Finds shortest path in unweighted graphs.</li>
    <li>Time complexity: O(V + E) (V = vertices, E = edges)</li>
    <li>Space complexity: O(V)</li>
</ul>

<h4>Steps of BFS</h4>
<ol>
    <li>Start at a source vertex, mark it visited.</li>
    <li>Enqueue it into the queue.</li>
    <li>While the queue is not empty:
        <ul>
            <li>Dequeue a vertex v.</li>
            <li>Visit all unvisited neighbors of v.</li>
            <li>Mark them as visited and enqueue them.</li>
        </ul>
    </li>
    <li>Repeat until queue is empty.</li>
</ol>

<h4>Example Graph</h4>
<ul>
    <li>Vertices: A, B, C, D, E</li>
    <li>Edges: A-B, A-C, B-D, C-D, D-E</li>
</ul>

<h4>Adjacency List</h4>
<pre>
A → B, C
B → A, D
C → A, D
D → B, C, E
E → D
</pre>

<h4>BFS Traversal from A</h4>
<pre>
Start at A → Queue: [A] → Visited: {A}
Dequeue A, enqueue neighbors B and C → Queue: [B, C] → Visited: {A, B, C}
Dequeue B, enqueue neighbor D (ignore A) → Queue: [C, D] → Visited: {A, B, C, D}
Dequeue C, neighbor D already visited → Queue: [D]
Dequeue D, enqueue neighbor E (ignore B, C) → Queue: [E] → Visited: {A, B, C, D, E}
Dequeue E, all neighbors visited → Queue empty → Done
BFS Order: A → B → C → D → E
</pre>

<h4>Textual Diagram of BFS</h4>
<pre>
Level 0: A
Level 1: B, C
Level 2: D
Level 3: E
</pre>

<h4>Queue changes over time (simplified):</h4>
<pre>
[A] -> Dequeue A, Enqueue B,C -> [B, C]
[B, C] -> Dequeue B, Enqueue D -> [C, D]
[C, D] -> Dequeue C -> [D]
[D] -> Dequeue D, Enqueue E -> [E]
[E] -> Dequeue E -> []
</pre>

<h4>BFS Implementation in C++</h4>
<pre>
#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
using namespace std;

void BFS(int start, vector&lt;vector&lt;int&gt;&gt;&amp; adj, vector&lt;bool&gt;&amp; visited) {
    queue&lt;int&gt; q;
    visited[start] = true;
    q.push(start);

    while(!q.empty()) {
        int v = q.front();
        q.pop();
        cout &lt;&lt; v &lt;&lt; " "; // Visit vertex

        for(int neighbor : adj[v]) {
            if(!visited[neighbor]) {
                visited[neighbor] = true;
                q.push(neighbor);
            }
        }
    }
}

int main() {
    int V = 5; // Number of vertices
    vector&lt;vector&lt;int&gt;&gt; adj(V);

    // Creating the graph
    adj[0] = {1, 2};     // A -> B, C
    adj[1] = {0, 3};     // B -> A, D
    adj[2] = {0, 3};     // C -> A, D
    adj[3] = {1, 2, 4};  // D -> B, C, E
    adj[4] = {3};        // E -> D

    vector&lt;bool&gt; visited(V, false);

    cout &lt;&lt; "BFS Traversal starting from vertex A(0): ";
    BFS(0, adj, visited);

    return 0;
}
</pre>

<h4>Output</h4>
<pre>
BFS Traversal starting from vertex A(0): 0 1 2 3 4
(0=A, 1=B, 2=C, 3=D, 4=E)
</pre>

<h3>Depth-First Search (DFS) – In Depth</h3>
<p>Definition: DFS is a graph traversal algorithm that starts at a source node and explores as far as possible along each branch before backtracking. Think of it like exploring a maze: you follow a path until you hit a dead-end, then backtrack to try other paths.</p>

<p>Uses stack (can be implicit with recursion or explicit with a stack data structure).</p>

<h4>Key Points</h4>
<ul>
    <li>Can be applied to directed/undirected graphs.</li>
    <li>Can handle connected/disconnected graphs.</li>
    <li>Useful for:
        <ul>
            <li>Pathfinding</li>
            <li>Detecting cycles</li>
            <li>Topological sorting</li>
            <li>Connected components</li>
        </ul>
    </li>
</ul>

<h4>DFS Algorithm (Recursive Version)</h4>
<pre>
DFS(G, v):
    mark v as visited
    for each neighbor u of v:
        if u is not visited:
            DFS(G, u)
</pre>

<h4>Explanation:</h4>
<ul>
    <li>Start at node v.</li>
    <li>Mark it as visited.</li>
    <li>For each neighbor, recursively visit unvisited nodes.</li>
</ul>

<h4>Example Graph</h4>
<ul>
    <li>Vertices: A, B, C, D, E</li>
    <li>Edges: A-B, A-C, B-D, C-E</li>
</ul>

<h4>Adjacency List</h4>
<pre>
A → B, C
B → A, D
C → A, E
D → B
E → C
</pre>

<h4>Textual Diagram (Graph & DFS Order)</h4>
<pre>
    A
   / \
  B   C
  |    \
  D     E
</pre>

<h4>DFS starting from A</h4>
<pre>
Visit A → mark visited
Go to B → mark visited
Go to D → mark visited
D has no unvisited neighbors → backtrack to B → then backtrack to A
Go to C → mark visited
Go to E → mark visited
DFS Visit Order: A → B → D → C → E
</pre>

<h4>C++ Code Example (Recursive DFS)</h4>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

void DFS(int v, vector&lt;vector&lt;int&gt;&gt; &amp;adj, vector&lt;bool&gt; &amp;visited) {
    visited[v] = true;
    cout &lt;&lt; v &lt;&lt; " "; // Visit the node
    
    for(int u : adj[v]) {
        if(!visited[u]) {
            DFS(u, adj, visited);
        }
    }
}

int main() {
    int V = 5; // Number of vertices (0-based indexing)
    vector&lt;vector&lt;int&gt;&gt; adj(V);
    
    // Adding edges
    adj[0] = {1, 2};  // A -> B, C
    adj[1] = {0, 3};  // B -> A, D
    adj[2] = {0, 4};  // C -> A, E
    adj[3] = {1};     // D -> B
    adj[4] = {2};     // E -> C
    
    vector&lt;bool&gt; visited(V, false);
    
    cout &lt;&lt; "DFS Traversal starting from vertex 0: ";
    DFS(0, adj, visited);
    
    return 0;
}
</pre>

<h4>Output</h4>
<pre>
DFS Traversal starting from vertex 0: 0 1 3 2 4
</pre>

<h4>DFS Using Stack (Iterative Version)</h4>
<p>Push the start node onto a stack. Pop, visit, push unvisited neighbors. Repeat until stack is empty. DFS is space-efficient for sparse graphs, but can go deep, so recursion may cause stack overflow on huge graphs.</p>
<h1>Algorithm Overview</h1>

<p>An algorithm is a step-by-step procedure or finite set of well-defined instructions to solve a specific problem or perform a computation.</p>
<p>It takes input(s), performs a sequence of operations, and produces output(s).</p>
<p>It must be finite, clear, and effective.</p>

<h2>Key Points:</h2>
<ul>
    <li><strong>Finiteness:</strong> Must terminate after a finite number of steps.</li>
    <li><strong>Input:</strong> Can have zero or more inputs.</li>
    <li><strong>Output:</strong> Produces at least one result.</li>
    <li><strong>Definiteness:</strong> Each step is precisely defined.</li>
    <li><strong>Effectiveness:</strong> Steps are simple enough to execute.</li>
</ul>

<h3>Example (Simple Algorithm – Adding Two Numbers):</h3>
<ol>
    <li>Read two numbers a and b.</li>
    <li>Compute sum = a + b.</li>
    <li>Print sum.</li>
</ol>
<p><strong>Input:</strong> 5, 7<br>
<strong>Output:</strong> 12</p>

<h2>Characteristics of a Good Algorithm</h2>

<h3>Finiteness</h3>
<p>The algorithm must terminate after a finite number of steps. No “infinite loops of despair.”</p>
<p><strong>Example:</strong> Binary Search always stops when the search space is exhausted.</p>

<h3>Input</h3>
<p>An algorithm may take zero or more inputs.</p>
<p><strong>Example:</strong> Factorial of a number takes n as input.</p>

<h3>Output</h3>
<p>Must produce at least one output.</p>
<p><strong>Example:</strong> Sorting algorithm outputs a sorted array.</p>

<h3>Definiteness (Unambiguous Steps)</h3>
<p>Each step must be clearly and precisely defined. No vague instructions like “do something clever here.” Computers aren’t psychic.</p>

<h3>Effectiveness</h3>
<p>Each step must be basic enough to be carried out in finite time. Must be practical, not just theoretically correct.</p>
<p><strong>Example:</strong> Adding two numbers is effective; “think really hard and magically decide” is not.</p>

<h3>Generality / Correctness</h3>
<p>Should solve all instances of the problem, not just a specific case.</p>
<p><strong>Example:</strong> Euclid’s algorithm works for any pair of positive integers, not just 8 and 12.</p>

<h3>Efficiency</h3>
<p>Uses minimum possible resources: time (speed) and space (memory).</p>
<p><strong>Example:</strong> Merge Sort is efficient for large datasets compared to Bubble Sort.</p>

<h2>Classification of Algorithms</h2>

<h3>Divide and Conquer (D&C) – In Depth</h3>
<p><strong>Definition:</strong> Divide and Conquer is an algorithm design paradigm that breaks a problem into smaller subproblems, solves each subproblem recursively, and then combines their results to solve the original problem.</p>
<p>Think of it like cleaning your messy room:</p>
<ul>
    <li><strong>Divide:</strong> Split the room into sections</li>
    <li><strong>Conquer:</strong> Clean each section</li>
    <li><strong>Combine:</strong> Put everything back neatly</li>
</ul>

<h4>Key Steps in D&C</h4>
<ol>
    <li><strong>Divide:</strong> Break the problem into smaller, manageable subproblems of the same type.</li>
    <li><strong>Conquer:</strong> Solve the subproblems recursively (or directly if small enough).</li>
    <li><strong>Combine:</strong> Merge the solutions of subproblems to get the final solution.</li>
</ol>

<p><strong>Characteristics:</strong> Works best when problem can be split into independent subproblems. Often uses recursion. Efficient for sorting, searching, and mathematical computations.</p>

<h3>Classic Examples</h3>

<h4>Merge Sort – In Depth</h4>
<p><strong>Definition:</strong> Merge Sort is a divide-and-conquer sorting algorithm that sorts an array by:</p>
<ul>
    <li>Dividing the array into two halves</li>
    <li>Recursively sorting each half</li>
    <li>Merging the sorted halves into a single sorted array</li>
</ul>
<p>It is a stable, comparison-based, and O(n log n) algorithm.</p>

<h4>Characteristics</h4>
<ul>
    <li><strong>Time Complexity:</strong> Best, Average, Worst: O(n log n)</li>
    <li><strong>Space Complexity:</strong> O(n) (requires temporary arrays for merging)</li>
    <li><strong>Stable:</strong> Yes (preserves relative order of equal elements)</li>
    <li><strong>Method:</strong> Recursive</li>
</ul>

<h4>Step-by-Step Example</h4>
<p>Array to sort: <code>arr = [38, 27, 43, 3, 9, 82, 10]</code></p>

<h5>Step 1: Divide</h5>
<p>Keep dividing the array into halves until each subarray has 1 element.</p>
<pre>
[38,27,43,3,9,82,10]
       /           \
[38,27,43,3]     [9,82,10]
   /      \       /      \
[38,27] [43,3]  [9,82]  [10]
 /   \   /  \    /  \
[38] [27][43][3][9][82][10]
</pre>

<h5>Step 2: Conquer (Sort)</h5>
<p>Each single-element array is considered sorted.</p>

<h5>Step 3: Merge</h5>
<p>Combine sorted arrays step by step:</p>
<pre>
Merge [38] and [27] → [27, 38]
Merge [43] and [3] → [3, 43]
Merge [27, 38] and [3, 43] → [3, 27, 38, 43]
Merge [9] and [82] → [9, 82]
Merge [9, 82] and [10] → [9, 10, 82]
Merge [3, 27, 38, 43] and [9, 10, 82] → [3, 9, 10, 27, 38, 43, 82]
</pre>

<p><strong>Sorted Array:</strong> [3, 9, 10, 27, 38, 43, 82]</p>

<h4>Textual Diagram of Merge Process</h4>
<pre>
Initial: [38,27,43,3,9,82,10]

Divide:
[38,27,43,3]      [9,82,10]
[38,27] [43,3]     [9,82] [10]
[38][27] [43][3]   [9][82] [10]

Merge:
[27,38] [3,43] → [3,27,38,43]
[9,82] [10] → [9,10,82]

Final Merge:
[3,27,38,43] [9,10,82] → [3,9,10,27,38,43,82]
</pre>

<h4>C++ Code Implementation</h4>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

// Merge two sorted subarrays arr[l..m] and arr[m+1..r]
void merge(vector&lt;int&gt; &amp;arr, int l, int m, int r) {
    int n1 = m - l + 1;
    int n2 = r - m;

    vector&lt;int&gt; L(n1), R(n2);
    for(int i = 0; i &lt; n1; i++) L[i] = arr[l + i];
    for(int i = 0; i &lt; n2; i++) R[i] = arr[m + 1 + i];

    int i = 0, j = 0, k = l;
    while(i &lt; n1 &amp;&amp; j &lt; n2) {
        if(L[i] &lt;= R[j]) arr[k++] = L[i++];
        else arr[k++] = R[j++];
    }

    while(i &lt; n1) arr[k++] = L[i++];
    while(j &lt; n2) arr[k++] = R[j++];
}

// Recursive Merge Sort function
void mergeSort(vector&lt;int&gt; &amp;arr, int l, int r) {
    if(l &lt; r) {
        int m = l + (r - l) / 2;
        mergeSort(arr, l, m);
        mergeSort(arr, m + 1, r);
        merge(arr, l, m, r);
    }
}

int main() {
    vector&lt;int&gt; arr = {38, 27, 43, 3, 9, 82, 10};
    mergeSort(arr, 0, arr.size() - 1);

    cout &lt;&lt; "Sorted Array: ";
    for(int x : arr) cout &lt;&lt; x &lt;&lt; " ";
    return 0;
}
</pre>

<p><strong>Output:</strong></p>
<pre>
Sorted Array: 3 9 10 27 38 43 82
</pre>

<h4>Summary</h4>
<p>Merge Sort uses divide-and-conquer. Always splits arrays, sorts recursively, and merges. Stable, O(n log n) time, O(n) space. Great for large datasets or linked lists (can do merge sort with O(1) extra space for linked lists).</p>

<h4>Quick Sort – In Depth</h4>
<p><strong>Definition:</strong> Quick Sort is a Divide and Conquer algorithm that sorts an array by:</p>
<ul>
    <li>Picking a pivot element.</li>
    <li>Partitioning the array so that all elements less than pivot are on the left and greater than pivot are on the right.</li>
    <li>Recursively sorting the left and right subarrays.</li>
</ul>
<p>Think of it like arranging books by repeatedly choosing a reference book and moving smaller books to the left and bigger ones to the right.</p>

<h4>Key Steps</h4>
<ul>
    <li><strong>Choose Pivot</strong> – Can be first element, last element, middle, or random.</li>
    <li><strong>Partitioning</strong> – Rearrange array elements around the pivot.</li>
    <li><strong>Recursive Sort</strong> – Apply Quick Sort on left and right subarrays.</li>
</ul>

<p>Pivot selection affects performance:</p>
<ul>
    <li>Best/random pivot → O(n log n)</li>
    <li>Worst (already sorted, bad pivot) → O(n²)</li>
</ul>

<h4>Textual Diagram</h4>
<pre>
Array: [10, 80, 30, 90, 40, 50, 70]
Step 1: Choose pivot = last element = 70

Partitioning:
Elements &lt;= 70 → left
Elements &gt; 70  → right
Left: 10 30 40 50
Pivot: 70
Right: 80 90

Step 2: Recursively sort subarrays
Left [10 30 40 50] pivot = 50 → partition → [10 30 40] 50 []
Left [10 30 40] pivot = 40 → partition → [10 30] 40 []
Left [10 30] pivot = 30 → partition → [10] 30 []

Right [80 90] pivot = 90 → [80] 90 []

Final Sorted Array:
10 30 40 50 70 80 90
</pre>

<h4>C++ Code: Quick Sort</h4>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

// Partition function
int partition(vector&lt;int&gt; &amp;arr, int low, int high) {
    int pivot = arr[high]; // pivot
    int i = low - 1;       // index of smaller element

    for(int j = low; j &lt; high; j++) {
        if(arr[j] &lt;= pivot) {
            i++;
            swap(arr[i], arr[j]);
        }
    }
    swap(arr[i+1], arr[high]);
    return i + 1;
}

// Quick Sort recursive function
void quickSort(vector&lt;int&gt; &amp;arr, int low, int high) {
    if(low &lt; high) {
        int pi = partition(arr, low, high);
        quickSort(arr, low, pi-1);   // left subarray
        quickSort(arr, pi+1, high);  // right subarray
    }
}

int main() {
    vector&lt;int&gt; arr = {10, 80, 30, 90, 40, 50, 70};
    quickSort(arr, 0, arr.size()-1);
    cout &lt;&lt; "Sorted Array: ";
    for(int x : arr) cout &lt;&lt; x &lt;&lt; " ";
    return 0;
}
</pre>

<p><strong>Output:</strong></p>
<pre>
Sorted Array: 10 30 40 50 70 80 90
</pre>

<h4>Time Complexity</h4>
<table>
    <tr><th>Case</th><th>Complexity</th></tr>
    <tr><td>Best / Average</td><td>O(n log n)</td></tr>
    <tr><td>Worst (sorted array + bad pivot)</td><td>O(n²)</td></tr>
</table>

<h4>Space Complexity</h4>
<p>O(log n) recursion stack on average. In-place algorithm (no extra array needed).</p>

<p>Quick Sort is faster than Merge Sort in practice because it doesn’t require extra arrays and partitions in-place, but pivot selection is critical.</p>

<h4>Binary Search – In Depth</h4>
<p><strong>Definition:</strong> Binary Search is a search algorithm that finds the position of a target element in a sorted array by repeatedly dividing the search interval in half.</p>
<p>Works only on sorted arrays. Time complexity: O(log n) – much faster than linear search for large datasets.</p>

<h4>Algorithm Steps</h4>
<ol>
    <li>Initialize low = 0 and high = n-1.</li>
    <li>While low &lt;= high:
        <ul>
            <li>Compute mid = (low + high)/2.</li>
            <li>If arr[mid] == target → element found.</li>
            <li>Else if arr[mid] &lt; target → search right half (low = mid + 1).</li>
            <li>Else → search left half (high = mid - 1).</li>
        </ul>
    </li>
    <li>If low &gt; high → element not found.</li>
</ol>

<h4>Textual Diagram</h4>
<pre>
Array (sorted): [2, 5, 8, 12, 16, 23, 38, 45, 56]
Target: 23

Step 1: Check middle element
Low=0, High=8 → Mid=(0+8)/2=4 → arr[4]=16
16 &lt; 23 → Search right half

Step 2: Right half → indices 5 to 8
Low=5, High=8 → Mid=(5+8)/2=6 → arr[6]=38
38 &gt; 23 → Search left half

Step 3: Left half of previous → indices 5 to 5
Low=5, High=5 → Mid=(5+5)/2=5 → arr[5]=23
Found!

Search path:
16 → 38 → 23
</pre>

<h4>C++ Implementation – Iterative</h4>
<pre>
#include &lt;iostream&gt;
using namespace std;

int binarySearch(int arr[], int n, int target) {
    int low = 0, high = n-1;
    while(low &lt;= high) {
        int mid = low + (high - low)/2;
        if(arr[mid] == target)
            return mid; // Element found
        else if(arr[mid] &lt; target)
            low = mid + 1; // Search right
        else
            high = mid - 1; // Search left
    }
    return -1; // Element not found
}

int main() {
    int arr[] = {2,5,8,12,16,23,38,45,56};
    int n = sizeof(arr)/sizeof(arr[0]);
    int target = 23;

    int result = binarySearch(arr, n, target);
    if(result != -1)
        cout &lt;&lt; "Element found at index " &lt;&lt; result;
    else
        cout &lt;&lt; "Element not found";

    return 0;
}
</pre>

<p><strong>Output:</strong></p>
<pre>
Element found at index 5
</pre>

<h4>C++ Implementation – Recursive</h4>
<pre>
int binarySearchRec(int arr[], int low, int high, int target) {
    if(low &gt; high) return -1;
    int mid = low + (high - low)/2;
    if(arr[mid] == target) return mid;
    else if(arr[mid] &lt; target) return binarySearchRec(arr, mid+1, high, target);
    else return binarySearchRec(arr, low, mid-1, target);
}
</pre>

<h4>Complexity Analysis</h4>
<table>
    <tr><th>Complexity</th><th>Value</th></tr>
    <tr><td>Best Case</td><td>O(1) (target is mid)</td></tr>
    <tr><td>Worst Case</td><td>O(log n)</td></tr>
    <tr><td>Average Case</td><td>O(log n)</td></tr>
</table>
<p><strong>Space Complexity:</strong> O(1) iterative, O(log n) recursive</p>
<p><strong>Key Points:</strong> Only works on sorted arrays. Extremely efficient for large datasets. Can be implemented iteratively or recursively. Often used in search problems, algorithm optimization, and binary search trees.</p>

<h4>Strassen’s Matrix Multiplication – In Depth</h4>
<p><strong>Definition:</strong> Strassen’s algorithm is a divide and conquer technique to multiply two square matrices faster than the standard O(n³) method.</p>
<p>Standard method: 8 multiplications for 2×2 blocks<br>
Strassen: Only 7 multiplications (plus some additions/subtractions)<br>
Complexity: O(n^2.81) instead of O(n³)<br>
It’s particularly useful for large matrices.</p>

<h4>Algorithm Steps (2×2 Example)</h4>
<p>Suppose we have two matrices:</p>
<pre>
A = | a b |
    | c d |

B = | e f |
    | g h |
</pre>

<p>Strassen splits matrices into 4 submatrices (for larger matrices, do recursively):</p>
<pre>
A11 = a, A12 = b, A21 = c, A22 = d
B11 = e, B12 = f, B21 = g, B22 = h
</pre>

<p>Compute 7 products (instead of 8):</p>
<pre>
M1 = (A11 + A22) * (B11 + B22)
M2 = (A21 + A22) * B11
M3 = A11 * (B12 - B22)
M4 = A22 * (B21 - B11)
M5 = (A11 + A12) * B22
M6 = (A21 - A11) * (B11 + B12)
M7 = (A12 - A22) * (B21 + B22)
</pre>

<p>Combine to get result matrix C:</p>
<pre>
C11 = M1 + M4 - M5 + M7
C12 = M3 + M5
C21 = M2 + M4
C22 = M1 - M2 + M3 + M6
</pre>

<h4>Textual Diagram (2x2 Example)</h4>
<pre>
Matrix A       Matrix B
[a b]          [e f]
[c d]          [g h]

Divide → Compute 7 M's → Combine

C = |C11 C12|
    |C21 C22|
</pre>

<h4>Example (2×2 matrices)</h4>
<pre>
A = |1 2|
    |3 4|

B = |5 6|
    |7 8|
</pre>

<h5>Step 1: Compute M1..M7</h5>
<pre>
M1 = (1+4)*(5+8) = 5*13 = 65
M2 = (3+4)*5 = 7*5 = 35
M3 = 1*(6-8) = 1*(-2) = -2
M4 = 4*(7-5) = 4*2 = 8
M5 = (1+2)*8 = 3*8 = 24
M6 = (3-1)*(5+6) = 2*11 = 22
M7 = (2-4)*(7+8) = -2*15 = -30
</pre>

<h5>Step 2: Combine</h5>
<pre>
C11 = M1 + M4 - M5 + M7 = 65 + 8 - 24 - 30 = 19
C12 = M3 + M5 = -2 + 24 = 22
C21 = M2 + M4 = 35 + 8 = 43
C22 = M1 - M2 + M3 + M6 = 65 - 35 -2 + 22 = 50

Result:
C = |19 22|
    |43 50|
</pre>

<h4>C++ Code (Recursive for n = 2^k matrices)</h4>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

typedef vector&lt;vector&lt;int&gt;&gt; matrix;

// Add two matrices
matrix add(matrix A, matrix B) {
    int n = A.size();
    matrix C(n, vector&lt;int&gt;(n));
    for(int i=0;i&lt;n;i++)
        for(int j=0;j&lt;n;j++)
            C[i][j] = A[i][j] + B[i][j];
    return C;
}

// Subtract two matrices
matrix subtract(matrix A, matrix B) {
    int n = A.size();
    matrix C(n, vector&lt;int&gt;(n));
    for(int i=0;i&lt;n;i++)
        for(int j=0;j&lt;n;j++)
            C[i][j] = A[i][j] - B[i][j];
    return C;
}

// Strassen's multiplication
matrix strassen(matrix A, matrix B) {
    int n = A.size();
    matrix C(n, vector&lt;int&gt;(n));
    
    if(n == 1) { // base case
        C[0][0] = A[0][0] * B[0][0];
        return C;
    }

    int k = n/2;
    // Divide matrices into submatrices
    matrix A11(k, vector&lt;int&gt;(k)), A12(k, vector&lt;int&gt;(k)), A21(k, vector&lt;int&gt;(k)), A22(k, vector&lt;int&gt;(k));
    matrix B11(k, vector&lt;int&gt;(k)), B12(k, vector&lt;int&gt;(k)), B21(k, vector&lt;int&gt;(k)), B22(k, vector&lt;int&gt;(k));
    
    for(int i=0;i&lt;k;i++)
        for(int j=0;j&lt;k;j++) {
            A11[i][j]=A[i][j]; A12[i][j]=A[i][j+k];
            A21[i][j]=A[i+k][j]; A22[i][j]=A[i+k][j+k];
            B11[i][j]=B[i][j]; B12[i][j]=B[i][j+k];
            B21[i][j]=B[i+k][j]; B22[i][j]=B[i+k][j+k];
        }
    
    // Compute M1..M7
    matrix M1 = strassen(add(A11,A22), add(B11,B22));
    matrix M2 = strassen(add(A21,A22), B11);
    matrix M3 = strassen(A11, subtract(B12,B22));
    matrix M4 = strassen(A22, subtract(B21,B11));
    matrix M5 = strassen(add(A11,A12), B22);
    matrix M6 = strassen(subtract(A21,A11), add(B11,B12));
    matrix M7 = strassen(subtract(A12,A22), add(B21,B22));
    
    // Combine results
    matrix C11 = add(subtract(add(M1,M4),M5), M7);
    matrix C12 = add(M3, M5);
    matrix C21 = add(M2, M4);
    matrix C22 = add(subtract(add(M1,M3),M2), M6);
    
    // Join submatrices into C
    for(int i=0;i&lt;k;i++)
        for(int j=0;j&lt;k;j++) {
            C[i][j] = C11[i][j];
            C[i][j+k] = C12[i][j];
            C[i+k][j] = C21[i][j];
            C[i+k][j+k] = C22[i][j];
        }
    
    return C;
}

int main() {
    matrix A = {{1,2},{3,4}};
    matrix B = {{5,6},{7,8}};
    
    matrix C = strassen(A,B);
    
    cout &lt;&lt; "Result Matrix:\n";
    for(auto &amp;row : C){
        for(auto val : row) cout &lt;&lt; val &lt;&lt; " ";
        cout &lt;&lt; "\n";
    }
    return 0;
}
</pre>

<p><strong>Output:</strong></p>
<pre>
Result Matrix:
19 22
43 50
</pre>

<h4>Time Complexity</h4>
<p>Standard multiplication: O(n³)<br>
Strassen: O(n^log2(7)) ≈ O(n^2.81)</p>

<h4>Space Complexity</h4>
<p>O(n²) for storing submatrices at each recursion.</p>


<h1>Dijkstra’s Shortest Path Algorithm</h1>

<h2>Definition:</h2>
<p>Find shortest paths from a source vertex to all vertices in a weighted graph with non-negative weights.</p>

<h3>Algorithm Steps:</h3>
<ol>
    <li>Initialize distance array: dist[source] = 0, others = ∞</li>
    <li>Mark all vertices as unvisited.</li>
    <li>Pick the unvisited vertex with the minimum distance.</li>
    <li>Update distances of adjacent vertices if a shorter path is found.</li>
    <li>Mark the picked vertex as visited.</li>
    <li>Repeat until all vertices are visited.</li>
</ol>

<h3>C++ Code</h3>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;climits&gt;
using namespace std;

int minDistance(const vector&lt;int&gt;&amp; dist, const vector&lt;bool&gt;&amp; sptSet) {
    int minVal = INT_MAX;
    int minIndex = -1;
    for(int v = 0; v &lt; dist.size(); v++) {
        if(!sptSet[v] &amp;&amp; dist[v] &lt; minVal) {
            minVal = dist[v];
            minIndex = v;
        }
    }
    return minIndex;
}

void dijkstra(const vector&lt;vector&lt;int&gt;&gt;&amp; graph, int src) {
    int V = graph.size();
    vector&lt;int&gt; dist(V, INT_MAX);
    vector&lt;bool&gt; sptSet(V, false);
    dist[src] = 0;

    for(int count = 0; count &lt; V-1; count++) {
        int u = minDistance(dist, sptSet);
        if(u == -1) break; // No reachable remaining vertex
        sptSet[u] = true;

        for(int v = 0; v &lt; V; v++) {
            if(graph[u][v] &gt; 0 &amp;&amp; !sptSet[v] &amp;&amp; dist[u] + graph[u][v] &lt; dist[v]) {
                dist[v] = dist[u] + graph[u][v];
            }
        }
    }

    cout &lt;&lt; "Vertex \tDistance from Source\n";
    for(int i = 0; i &lt; V; i++)
        cout &lt;&lt; i &lt;&lt; "\t" &lt;&lt; dist[i] &lt;&lt; endl;
}

int main() {
    vector&lt;vector&lt;int&gt;&gt; graph = {
        {0,10,0,0,0,0,0,8,0},
        {10,0,10,0,0,0,0,11,0},
        {0,10,0,18,0,0,0,0,0},
        {0,0,18,0,0,0,0,0,0},
        {0,0,0,0,0,0,0,0,0},
        {0,0,0,0,0,0,0,0,0},
        {0,0,0,0,0,0,0,0,0},
        {8,11,0,0,0,0,0,0,7},
        {0,0,0,0,0,0,0,7,0}
    };

    dijkstra(graph, 0);
    return 0;
}
</pre>

<h1>Dynamic Programming – In Depth</h1>

<h2>Definition</h2>
<p>Dynamic Programming is a method for solving problems by breaking them into overlapping subproblems, solving each subproblem once, and storing its solution for future use (memoization).</p>
<p><strong>Key idea:</strong> Avoid recomputation</p>
<p>Uses recursion + storage (array/table)</p>

<h2>1. Optimal Substructure</h2>
<p><strong>Definition:</strong> A problem has optimal substructure if the solution to the overall problem can be constructed from solutions of its subproblems.</p>
<p>In other words, solving smaller pieces correctly guarantees the big problem is correct.</p>
<p>Without this, DP won’t work.</p>

<h3>Example:</h3>
<ul>
    <li>Fibonacci numbers: <code>fib(n) = fib(n-1) + fib(n-2)</code></li>
    <li>Shortest path in graph: Shortest path from A to C can be built from shortest path A→B + B→C</li>
</ul>

<h2>2. Overlapping Subproblems</h2>
<p><strong>Definition:</strong> A problem has overlapping subproblems if the same subproblems are solved multiple times during recursion.</p>
<p>Brute force will recompute the same thing over and over. DP solves each subproblem once and stores it (memoization or tabulation).</p>

<h3>Example:</h3>
<p>Fibonacci numbers:</p>
<pre>
fib(5) = fib(4) + fib(3)
fib(4) = fib(3) + fib(2)

fib(3) is calculated twice in naive recursion → DP fixes this.
</pre>

<h2>3. Recursive Relation / State Transition</h2>
<p>DP problems can be expressed in terms of previous subproblems. This is also called state transition.</p>

<h3>Example:</h3>
<ul>
    <li>Fibonacci: <code>fib(n) = fib(n-1) + fib(n-2)</code></li>
    <li>0/1 Knapsack: <code>dp[i][w] = max(dp[i-1][w], dp[i-1][w-weight[i]] + value[i])</code></li>
</ul>

<h2>4. Small Number of Distinct Subproblems</h2>
<p>If the number of unique subproblems is small enough, we can store their solutions in a table/array. Otherwise, memoization table becomes too large.</p>

<h3>Example:</h3>
<p>Fibonacci DP: Only n+1 distinct subproblems (fib(0) to fib(n)), even though recursion explores exponentially many calls.</p>

<h2>Summary Table</h2>
<table>
    <tr>
        <th>Characteristic</th>
        <th>Meaning</th>
        <th>Example</th>
    </tr>
    <tr>
        <td>Optimal Substructure</td>
        <td>Big problem can be solved from small subproblems</td>
        <td>Fibonacci, Shortest Path</td>
    </tr>
    <tr>
        <td>Overlapping Subproblems</td>
        <td>Same subproblem occurs multiple times</td>
        <td>Fibonacci recursion</td>
    </tr>
    <tr>
        <td>Recursive Relation</td>
        <td>There’s a formula linking subproblems</td>
        <td>fib(n) = fib(n-1) + fib(n-2)</td>
    </tr>
    <tr>
        <td>Small Distinct Subproblems</td>
        <td>Number of unique subproblems is manageable</td>
        <td>0/1 Knapsack, LCS</td>
    </tr>
</table>

<h2>Top-Down DP (Memoization) – In Depth</h2>
<p><strong>Definition:</strong> Top-Down DP is a technique where you:</p>
<ul>
    <li>Write the problem as a recursive solution.</li>
    <li>Store (memoize) the results of subproblems in a table (array/map).</li>
    <li>When the same subproblem is needed again, reuse the stored result instead of recalculating.</li>
</ul>

<p><strong>Key Idea:</strong> Solve only what’s needed, in a recursive manner, but avoid recomputation.</p>

<h3>Characteristics</h3>
<ul>
    <li>Recursive approach – naturally uses call stack.</li>
    <li>Memory storage – usually array or hash map for storing computed subproblems.</li>
    <li>Avoids redundant computation – solves overlapping subproblems once.</li>
    <li>Useful when subproblem solutions repeat.</li>
</ul>

<h3>Example Problem: Fibonacci Numbers</h3>
<p><strong>Recursive Formula:</strong></p>
<pre>
fib(n) = fib(n-1) + fib(n-2)
fib(0) = 0
fib(1) = 1
</pre>

<h4>Step 1: Recursive Tree (Without Memoization)</h4>
<pre>
fib(5)
├─ fib(4)
│  ├─ fib(3)
│  │  ├─ fib(2)
│  │  │  ├─ fib(1)=1
│  │  │  └─ fib(0)=0
│  │  └─ fib(1)=1
│  └─ fib(2)
│     ├─ fib(1)=1
│     └─ fib(0)=0
└─ fib(3)
   ├─ fib(2)
   │  ├─ fib(1)=1
   │  └─ fib(0)=0
   └─ fib(1)=1
</pre>
<p>Notice how fib(3) and fib(2) are computed multiple times.</p>
<p><strong>Time complexity:</strong> O(2^n) – exponential.</p>

<h4>Step 2: Apply Memoization (Top-Down DP)</h4>
<p>Idea: Store computed results in a dp[] array. Before computing a subproblem, check if it’s already computed.</p>

<h5>C++ Code:</h5>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

int fib(int n, vector&lt;int&gt; &amp;dp) {
    if(n &lt;= 1) return n;         // Base cases
    if(dp[n] != -1) return dp[n];  // Return if already computed
    
    dp[n] = fib(n-1, dp) + fib(n-2, dp); // Compute and store
    return dp[n];
}

int main() {
    int n = 10;
    vector&lt;int&gt; dp(n+1, -1); // Initialize DP table with -1
    
    cout &lt;&lt; "Fib(" &lt;&lt; n &lt;&lt; ") = " &lt;&lt; fib(n, dp) &lt;&lt; endl;
    return 0;
}
</pre>

<p><strong>Output:</strong></p>
<pre>
Fib(10) = 55
</pre>

<h4>Step 3: Memoization Table (Textual Diagram)</h4>
<pre>
n:    0   1   2   3   4   5   6   7   8   9   10
fib:  0   1   1   2   3   5   8  13  21  34   55
</pre>

<p>Each fib[i] is computed only once. Subsequent calls reuse stored values.</p>
<p><strong>Time complexity:</strong> O(n)</p>
<p><strong>Space complexity:</strong> O(n) (for DP table + recursion stack)</p>

<h4>Step 4: Advantages of Top-Down / Memoization</h4>
<ul>
    <li>Simple to write – naturally recursive.</li>
    <li>Avoids redundant work – saves computation.</li>
    <li>Lazy computation – only computes subproblems needed by the original call.</li>
    <li>Good for problems where not all subproblems are needed.</li>
</ul>

<h2>Bottom-Up / Tabulation Approach – In Depth</h2>
<p><strong>Definition:</strong> Bottom-Up DP, also called tabulation, solves all subproblems iteratively, starting from the smallest subproblems and combining them to solve larger ones.</p>
<ul>
    <li>No recursion needed</li>
    <li>Uses a table (array/matrix) to store intermediate results</li>
    <li>Usually faster and safer than top-down recursion with memoization</li>
</ul>

<h3>Characteristics</h3>
<ul>
    <li>Iterative: Starts from base cases, builds up solutions.</li>
    <li>Table-based: Stores results of smaller subproblems in an array or matrix.</li>
    <li>Optimal substructure: Larger solution depends on smaller solutions in the table.</li>
    <li>Space-time tradeoff: May use extra memory to store the table, but reduces time complexity.</li>
</ul>

<h3>Example: Fibonacci Numbers (Bottom-Up)</h3>
<p><strong>Problem:</strong> Compute fib(n) where</p>
<pre>
fib(0) = 0
fib(1) = 1
fib(n) = fib(n-1) + fib(n-2)
</pre>

<h4>Step-by-Step Approach</h4>
<ol>
    <li>Create a DP table (array) of size n+1.</li>
    <li>Initialize base cases: dp[0] = 0, dp[1] = 1</li>
    <li>Iterate from 2 to n and fill table: dp[i] = dp[i-1] + dp[i-2]</li>
    <li>Final answer: dp[n]</li>
</ol>

<h5>C++ Code:</h5>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

int fib(int n) {
    vector&lt;int&gt; dp(n+1, 0); // Table to store Fibonacci values
    dp[0] = 0;
    if(n &gt;= 1) dp[1] = 1;

    for(int i = 2; i &lt;= n; i++) {
        dp[i] = dp[i-1] + dp[i-2];
    }

    return dp[n];
}

int main() {
    int n = 10;
    cout &lt;&lt; "Fib(" &lt;&lt; n &lt;&lt; ") = " &lt;&lt; fib(n) &lt;&lt; endl;
    return 0;
}
</pre>

<p><strong>Output:</strong></p>
<pre>
Fib(10) = 55
</pre>

<h4>Textual Diagram – Fibonacci Table</h4>
<pre>
i   : 0   1   2   3   4   5   6   7   8   9  10
dp[i]:0   1   1   2   3   5   8  13  21  34  55
</pre>

<p>Each value in dp[i] is built from dp[i-1] and dp[i-2]. Table stores all intermediate results → no recomputation.</p>

<h4>Advantages of Bottom-Up / Tabulation</h4>
<ul>
    <li>No recursion → no stack overflow.</li>
    <li>Often slightly faster than top-down DP (avoids function call overhead).</li>
    <li>Easy to trace and debug.</li>
    <li>Can optimize space by storing only needed previous states.</li>
</ul>

<h4>Space Optimization Example for Fibonacci:</h4>
<pre>
int fib(int n) {
    if(n == 0) return 0;
    int a = 0, b = 1, c;
    for(int i = 2; i &lt;= n; i++) {
        c = a + b;
        a = b;
        b = c;
    }
    return b;
}
</pre>

<p>Uses O(1) space instead of O(n)</p>









</body>
</html>
