<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Computer Network</title>
    <style>
       
body {
    font-family: "Segoe UI", Roboto, Arial, sans-serif;
    background: #ffffff; /* white background */
    color: #000000;      /* black text */
    margin: 0;
    padding: 20px;
    line-height: 1.7;
}

/* Container */
.container {
    max-width: 1000px;
    margin: auto;
    padding: 40px;
}

/* Headings */
h1, h2, h3 {
    color: #000000; /* black headings */
    margin-top: 30px;
}

h1 {
    font-size: 2.5rem;
    border-bottom: 2px solid #000000;
    padding-bottom: 10px;
}

h2 {
    font-size: 1.9rem;
}

h3 {
    font-size: 1.4rem;
    color: #000000;
}

/* Paragraphs and lists */
p {
    font-size: 1.05rem;
    margin: 15px 0;
}

ul, ol {
    margin-left: 25px;
    margin-bottom: 15px;
}

li {
    margin: 8px 0;
}

/* Boxes for examples or notes */
.box, .example {
    background: #f0f0f0; /* light gray background */
    border-left: 5px solid #000000;
    padding: 20px;
    margin: 25px 0;
    border-radius: 6px;
    color: #000000;
}

/* Code and diagram blocks */
.diagram, .code, pre {
    background: #e5e5e5; /* slightly darker gray for code/diagrams */
    padding: 20px;
    font-family: "Courier New", monospace;
    white-space: pre;
    border-radius: 6px;
    margin: 20px 0;
    color: #000000;
    overflow-x: auto;
}

code {
    font-family: monospace;
    background-color: #f4f4f4;
    padding: 2px 4px;
    border-radius: 4px;
    color: #000000;
}

/* Tables */
table {
    width: 100%;
    border-collapse: collapse;
    margin: 20px 0;
}

table th, table td {
    border: 1px solid #cccccc;
    padding: 10px;
    text-align: left;
    color: #000000;
}

table th {
    background: #e0e0e0;
    color: #000000;
}

/* Highlighted text */
.highlight {
    color: #ff6600; /* orange for highlights */
}

/* Footer */
footer {
    text-align: center;
    padding: 20px;
    color: #ffffff;
    background-color: #000000; /* black footer background */
    margin-top: 20px;
}

    </style>
</head>
<body>

    <table>
        <caption>OSI Model (Open Systems Interconnection)</caption>
        <thead>
            <tr>
                <th>Layer</th>
                <th>Number</th>
                <th>Function / Role</th>
                <th>Devices / Protocols</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Application Layer</td>
                <td>7</td>
                <td>Interface for applications to access network services.</td>
                <td>HTTP, FTP, SMTP, DNS</td>
            </tr>
            <tr>
                <td>Presentation Layer</td>
                <td>6</td>
                <td>Formats data, encryption/decryption, compression.</td>
                <td>JPEG, MPEG, SSL/TLS</td>
            </tr>
            <tr>
                <td>Session Layer</td>
                <td>5</td>
                <td>Manages sessions between applications (start, maintain, terminate).</td>
                <td>NetBIOS, PPTP</td>
            </tr>
            <tr>
                <td>Transport Layer</td>
                <td>4</td>
                <td>Ensures reliable data transfer, error detection, flow control.</td>
                <td>TCP, UDP</td>
            </tr>
            <tr>
                <td>Network Layer</td>
                <td>3</td>
                <td>Determines path for data delivery (routing).</td>
                <td>IP, ICMP, Routers</td>
            </tr>
            <tr>
                <td>Data Link Layer</td>
                <td>2</td>
                <td>Handles error-free delivery over a physical link; frames data.</td>
                <td>Ethernet, MAC, Switches</td>
            </tr>
            <tr>
                <td>Physical Layer</td>
                <td>1</td>
                <td>Transmits raw bits over physical medium.</td>
                <td>Cables, Hubs, NICs, Wi-Fi signals</td>
            </tr>
        </tbody>
    </table>
    <table>
        <caption>TCP/IP Model</caption>
        <thead>
            <tr>
                <th>Layer</th>
                <th>Function / Role</th>
                <th>Protocols / Devices</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Application Layer</td>
                <td>Application + Presentation + Session combined.</td>
                <td>HTTP, FTP, SMTP, DNS, Telnet</td>
            </tr>
            <tr>
                <td>Transport Layer</td>
                <td>Reliable or unreliable delivery.</td>
                <td>TCP (reliable), UDP (unreliable)</td>
            </tr>
            <tr>
                <td>Internet Layer</td>
                <td>Routing and addressing.</td>
                <td>IP, ICMP, Routers</td>
            </tr>
            <tr>
                <td>Network Access / Link Layer</td>
                <td>Physical + Data Link combined.</td>
                <td>Ethernet, Wi-Fi, Switches, Hubs</td>
            </tr>
        </tbody>
    </table>
      <h1>Application Layer</h1>

    <h2>1. What is the Application Layer?</h2>
    <p>
        The Application Layer provides the interface between the user/application software and the network.
        It does not mean applications like Word or Excel, but network services used by these applications.
    </p>
    <p>It is responsible for network services directly to end-users and interacts with software like web browsers, email clients, or file transfer programs.</p>

    <h2>2. Main Functions of the Application Layer</h2>
    <ul>
        <li><strong>Network Virtualization for Applications:</strong> Lets applications send and receive data over a network without worrying about physical connections.</li>
        <li><strong>Resource Sharing and Communication:</strong> Supports email, file transfer, remote login, messaging, etc.</li>
        <li><strong>Data Representation / Encoding:</strong> Often works with Presentation Layer tasks like encryption or data format translation in OSI.</li>
        <li><strong>Identifying Communication Partners:</strong> Uses hostnames, domain names, or IP addresses to locate resources.</li>
        <li><strong>Protocol Support:</strong> Provides standard protocols for services like web, email, or file transfer.</li>
    </ul>

    <h2>3. Common Protocols at the Application Layer</h2>
    <table>
        <thead>
            <tr>
                <th>Protocol</th>
                <th>Purpose</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>HTTP / HTTPS</td>
                <td>Web browsing</td>
            </tr>
            <tr>
                <td>FTP / SFTP</td>
                <td>File transfer</td>
            </tr>
            <tr>
                <td>SMTP</td>
                <td>Sending emails</td>
            </tr>
            <tr>
                <td>POP3 / IMAP</td>
                <td>Receiving emails</td>
            </tr>
            <tr>
                <td>DNS</td>
                <td>Translating domain names to IP addresses</td>
            </tr>
            <tr>
                <td>Telnet / SSH</td>
                <td>Remote login to servers</td>
            </tr>
            <tr>
                <td>SNMP</td>
                <td>Network management</td>
            </tr>
        </tbody>
    </table>

    <h2>4. Example of Application Layer in Action</h2>
    <p><strong>Scenario:</strong> You open a browser and type <em>www.google.com</em>:</p>
    <ol>
        <li>Browser uses HTTP/HTTPS (Application Layer) to request a webpage.</li>
        <li>Browser passes the request to the Transport Layer (TCP) for reliable delivery.</li>
        <li>TCP passes it to the Network Layer (IP) to find the route to Google server.</li>
        <li>Data travels across the Internet and is reversed on Google’s server.</li>
        <li>The response comes back, and the browser renders the webpage.</li>
    </ol>

    <h2>1.Main Functions of the Application Layer</h2>

    <ul>
        <li>
            <strong>Providing Network Services to Applications:</strong>  
            Acts as a bridge between user applications and the network.  
            <div class="example">Example: Web browsers, email clients, and file transfer programs use this layer to communicate over the network.</div>
        </li>

        <li>
            <strong>Identifying Communication Partners:</strong>  
            Determines which device or service on the network you want to communicate with using hostnames, domain names, or IP addresses.  
            <div class="example">Example: Translating www.google.com to an IP address using DNS.</div>
        </li>

        <li>
            <strong>Resource Sharing:</strong>  
            Enables sharing of files, printers, databases, or other network resources among multiple devices.  
            <div class="example">Example: Accessing a shared folder on a network drive.</div>
        </li>

        <li>
            <strong>Remote Access Services:</strong>  
            Supports remote login and control of devices or servers.  
            <div class="example">Example: SSH, Telnet, Remote Desktop.</div>
        </li>

        <li>
            <strong>File Transfer, Email, and Messaging:</strong>  
            Provides standard protocols for sending/receiving data and messages.  
            <div class="example">Example: FTP for files, SMTP/IMAP for email, HTTP for web content.</div>
        </li>

        <li>
            <strong>Data Representation & Encoding Support:</strong>  
            Ensures that data is in a format that the receiving application can understand, often overlapping with Presentation Layer functions like encryption, compression, or character conversion.
        </li>

        <li>
            <strong>Network Transparency for Applications:</strong>  
            Hides the complexity of the network from applications. Applications do not need to know about routing, IP addresses, or physical data transmission.
        </li>
    </ul>

    <h1>HTTP (HyperText Transfer Protocol)</h1>

    <h2>1. What is HTTP?</h2>
    <p>
        HTTP is used for communication between a web client (browser) and a web server.  
        It allows web pages, images, videos, and other resources to be requested and delivered over the Internet.  
        HTTP works on a <strong>request-response model</strong>.
    </p>

    <h2>2. How HTTP Works</h2>
    <ul>
        <li>
            <strong>Client Request:</strong> Browser sends an HTTP request to the server, including method, URL, headers, and optionally data (for POST).  
            <div class="example">Example: You type www.google.com → Browser sends: GET / HTTP/1.1 to www.google.com.</div>
        </li>
        <li>
            <strong>Server Response:</strong> Server processes the request and sends back an HTTP response, including status code, headers, and requested content.  
            <div class="example">Example: Server responds with HTML page of Google homepage.</div>
        </li>
    </ul>

    <h2>3. HTTP Methods</h2>
    <table>
        <thead>
            <tr>
                <th>Method</th>
                <th>Purpose</th>
            </tr>
        </thead>
        <tbody>
            <tr><td>GET</td><td>Retrieve data from server.</td></tr>
            <tr><td>POST</td><td>Send data to server (e.g., form submission).</td></tr>
            <tr><td>PUT</td><td>Update existing data on server.</td></tr>
            <tr><td>DELETE</td><td>Delete data on server.</td></tr>
            <tr><td>HEAD</td><td>Get headers only (no body).</td></tr>
            <tr><td>PATCH</td><td>Partially update data on server.</td></tr>
        </tbody>
    </table>

    <h2>4. HTTP Status Codes</h2>
    <table>
        <thead>
            <tr>
                <th>Code</th>
                <th>Meaning</th>
            </tr>
        </thead>
        <tbody>
            <tr><td>200</td><td>OK – Request succeeded</td></tr>
            <tr><td>301</td><td>Moved Permanently – Resource moved</td></tr>
            <tr><td>400</td><td>Bad Request – Client error</td></tr>
            <tr><td>401</td><td>Unauthorized – Need authentication</td></tr>
            <tr><td>403</td><td>Forbidden – Access denied</td></tr>
            <tr><td>404</td><td>Not Found – Resource does not exist</td></tr>
            <tr><td>500</td><td>Internal Server Error – Server problem</td></tr>
            <tr><td>503</td><td>Service Unavailable – Server overloaded</td></tr>
        </tbody>
    </table>

    <h2>5. HTTP vs HTTPS</h2>
    <ul>
        <li><strong>HTTP:</strong> Unencrypted, data sent as plain text → Not secure. Uses port 80.</li>
        <li><strong>HTTPS:</strong> Encrypted using SSL/TLS → Secure data transmission. Uses port 443.</li>
    </ul>

    <h2>6. Real-World Example</h2>
    <p>
        Open browser → Enter <em>https://example.com</em>  
        Browser sends HTTPS request → Server processes → Browser displays webpage.  
        Browser may load additional resources (images, CSS, JS) via separate HTTP requests.
    </p>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            line-height: 1.6;
        }
        h1, h2, h3 {
            color: #2a5d9f;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 10px 0 20px 0;
        }
        th, td {
            border: 1px solid #333;
            padding: 8px 12px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
        }
        pre {
            background-color: #f4f4f4;
            padding: 10px;
            border-left: 3px solid #2a5d9f;
            overflow-x: auto;
        }
        ul, ol {
            margin-left: 20px;
            margin-bottom: 15px;
        }
        .note {
            font-style: italic;
            color: #555;
            margin-left: 20px;
        }
    </style>
</head>
<body>

    <h1>HTTP/0.9 – In-Depth Overview</h1>

    <h2>1. Historical Context</h2>
    <ul>
        <li><strong>Year Introduced:</strong> 1991</li>
        <li><strong>Inventor:</strong> Tim Berners-Lee (for first web browser WorldWideWeb, later Nexus)</li>
        <li><strong>Purpose:</strong> Fetch HTML documents from web servers. Early web pages were simple text and hyperlinks.</li>
    </ul>

    <h2>2. Design Philosophy</h2>
    <ul>
        <li><strong>Minimalism:</strong> Only essential functionality to fetch documents.</li>
        <li><strong>Simplicity:</strong> No headers, status codes, or metadata.</li>
        <li><strong>Stateless:</strong> Each request is independent.</li>
        <li><strong>Single-purpose:</strong> Focused only on GET requests for HTML content.</li>
    </ul>

    <h2>3. Key Features</h2>
    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr><td>Methods</td><td>Only GET supported</td></tr>
            <tr><td>Headers</td><td>None (no Content-Type, Content-Length, or metadata)</td></tr>
            <tr><td>Request Format</td><td>GET /path/to/file (no HTTP version)</td></tr>
            <tr><td>Response Format</td><td>Only raw HTML content, no headers or status codes</td></tr>
            <tr><td>Connection</td><td>Single TCP connection per request, closed after response</td></tr>
            <tr><td>Stateless</td><td>Server does not remember previous requests</td></tr>
            <tr><td>Content Type</td><td>Assumed HTML by default; no MIME type</td></tr>
        </tbody>
    </table>

    <h2>4. HTTP/0.9 Request and Response Example</h2>
    <pre>
Request:
GET /index.html

Response:
&lt;html&gt;
  &lt;head&gt;&lt;title&gt;My First Page&lt;/title&gt;&lt;/head&gt;
  &lt;body&gt;
    Welcome to my website!
  &lt;/body&gt;
&lt;/html&gt;
    </pre>
    <div class="note">
        Key Notes: No HTTP version, no headers, no status code.
    </div>

    <h2>5. Limitations of HTTP/0.9</h2>
    <ul>
        <li>No Metadata / Headers – cannot tell file type or encoding.</li>
        <li>No Status Codes – cannot distinguish errors.</li>
        <li>Single TCP Connection per Request – inefficient for multiple resources.</li>
        <li>Limited to Text/HTML – cannot handle images, videos, or other types.</li>
        <li>No Security or Encryption – SSL/TLS not supported.</li>
    </ul>

    <h2>6. Importance of HTTP/0.9</h2>
    <ul>
        <li>Foundation of the Web – allowed early browsers to retrieve HTML.</li>
        <li>Proof of Concept – showed hypertext transfer over TCP/IP.</li>
        <li>Inspired HTTP/1.0 – led to headers, status codes, and multiple methods.</li>
    </ul>

    <h2>7. Technical Details</h2>
    <ul>
        <li><strong>Transport Layer:</strong> TCP/IP</li>
        <li><strong>Default Port:</strong> 80</li>
        <li><strong>Request Line:</strong> GET /file-path (no HTTP version, no headers)</li>
        <li><strong>Response Format:</strong> Raw HTML content</li>
        <li><strong>Connection Handling:</strong> Client opens TCP → sends GET → server responds → connection closes</li>
        <li><strong>Stateless:</strong> Server does not retain information between requests</li>
    </ul>

    <h2>8. Example Workflow</h2>
    <ol>
        <li>Browser requests /index.html.</li>
        <li>Server sends raw HTML.</li>
        <li>Browser renders the page.</li>
        <li>Browser requests /about.html → new TCP connection.</li>
        <li>Problem: 10 images → 11 separate TCP connections → slow.</li>
    </ol>

    <h2>9. Key Differences Between HTTP/0.9 and HTTP/1.x</h2>
    <table>
        <thead>
            <tr>
                <th>Feature</th>
                <th>HTTP/0.9</th>
                <th>HTTP/1.0 / 1.1</th>
            </tr>
        </thead>
        <tbody>
            <tr><td>Methods</td><td>GET only</td><td>GET, POST, HEAD, PUT, DELETE</td></tr>
            <tr><td>Headers</td><td>None</td><td>Content-Type, Content-Length, Host, etc.</td></tr>
            <tr><td>Status Codes</td><td>None</td><td>200, 404, 500, etc.</td></tr>
            <tr><td>TCP Connections</td><td>One per request</td><td>Persistent connections in 1.1</td></tr>
            <tr><td>Content Types</td><td>HTML only</td><td>Any MIME type</td></tr>
            <tr><td>Security</td><td>None</td><td>HTTPS/SSL support later</td></tr>
        </tbody>
    </table>

    <h2>10. Key Takeaways</h2>
    <ul>
        <li>HTTP/0.9 = simple, minimal, stateless protocol for HTML transfer</li>
        <li>Designed for early browsers with basic HTML</li>
        <li>Obsolete now, replaced by HTTP/1.x, HTTP/2, HTTP/3</li>
        <li>Historically important as foundation of the World Wide Web</li>
    </ul>
        <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            line-height: 1.6;
        }
        h1, h2 {
            color: #2a5d9f;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 10px 0 20px 0;
        }
        th, td {
            border: 1px solid #333;
            padding: 8px 12px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
        }
        pre {
            background-color: #f4f4f4;
            padding: 10px;
            border-left: 3px solid #2a5d9f;
            overflow-x: auto;
        }
        ul, ol {
            margin-left: 20px;
            margin-bottom: 15px;
        }
        .note {
            font-style: italic;
            color: #555;
            margin-left: 20px;
        }
    </style>
</head>
<body>

    <h1>HTTP/1.0 – Detailed Overview</h1>

    <h2>1. Introduction</h2>
    <ul>
        <li><strong>Year Introduced:</strong> 1996</li>
        <li><strong>Purpose:</strong> Overcome limitations of HTTP/0.9 and support complex web applications.</li>
        <li><strong>Significance:</strong> Introduced HTTP headers, multiple methods, and status codes—the foundation of modern web communication.</li>
    </ul>

    <h2>2. Key Features of HTTP/1.0</h2>

    <h3>a. Support for Multiple Methods</h3>
    <table>
        <thead>
            <tr>
                <th>Method</th>
                <th>Purpose</th>
            </tr>
        </thead>
        <tbody>
            <tr><td>GET</td><td>Retrieve a resource (e.g., web page)</td></tr>
            <tr><td>POST</td><td>Send data to the server (e.g., form submission)</td></tr>
            <tr><td>HEAD</td><td>Request headers only, without the body</td></tr>
        </tbody>
    </table>
    <p><strong>Note:</strong> PUT and DELETE were not standardized in 1.0; became common in later versions.</p>

    <h3>b. HTTP Headers</h3>
    <ul>
        <li>Introduced request and response headers to provide metadata.</li>
        <li><strong>Request Headers:</strong> Sent by client (e.g., User-Agent, Accept)</li>
        <li><strong>Response Headers:</strong> Sent by server (e.g., Content-Type, Content-Length, Date)</li>
    </ul>
    <pre>
Example Request:
GET /index.html HTTP/1.0
Host: www.example.com
User-Agent: Mozilla/5.0

Example Response:
HTTP/1.0 200 OK
Date: Thu, 16 Oct 2025 14:00:00 GMT
Content-Type: text/html
Content-Length: 1024

&lt;html&gt;
<head>&lt;title&gt;Example&lt;/title&gt;</head>
<body>Hello World!</body>
&lt;/html&gt;
    </pre>

    <h3>c. Status Codes</h3>
    <table>
        <thead>
            <tr><th>Code</th><th>Meaning</th></tr>
        </thead>
        <tbody>
            <tr><td>200</td><td>OK – Request succeeded</td></tr>
            <tr><td>301</td><td>Moved Permanently – Resource moved</td></tr>
            <tr><td>302</td><td>Found (Temporary Redirect)</td></tr>
            <tr><td>400</td><td>Bad Request – Client sent invalid request</td></tr>
            <tr><td>401</td><td>Unauthorized – Authentication required</td></tr>
            <tr><td>403</td><td>Forbidden – Access denied</td></tr>
            <tr><td>404</td><td>Not Found – Resource does not exist</td></tr>
            <tr><td>500</td><td>Internal Server Error</td></tr>
            <tr><td>503</td><td>Service Unavailable</td></tr>
        </tbody>
    </table>

    <h3>d. MIME Types</h3>
    <ul>
        <li>Supports MIME types in Content-Type header to tell browser how to process content.</li>
        <li>Examples:</li>
        <ul>
            <li>text/html → HTML page</li>
            <li>image/jpeg → JPEG image</li>
            <li>application/json → JSON data</li>
        </ul>
    </ul>

    <h3>e. Stateless Protocol</h3>
    <p>Every request is independent; server does not remember previous requests.</p>
    <div class="note">Example: Logging in on one page does not persist without cookies or sessions.</div>

    <h3>f. TCP Connections</h3>
    <p>HTTP/1.0 opens a new TCP connection for each request.</p>
    <div class="note">Example: Web page with 5 images → 6 TCP connections (1 HTML + 5 images)</div>

    <h3>g. Limitations of HTTP/1.0</h3>
    <ul>
        <li>No persistent connections (fixed in HTTP/1.1)</li>
        <li>Inefficient for multiple resources due to multiple TCP connections</li>
        <li>No host header initially → virtual hosting difficult</li>
        <li>Statelessness requires workarounds (cookies, hidden fields) for sessions</li>
    </ul>

    <h2>3. Example of HTTP/1.0 Flow</h2>
    <pre>
Request HTML page:
GET /index.html HTTP/1.0
Host: www.example.com

Server Response:
HTTP/1.0 200 OK
Content-Type: text/html
Content-Length: 512

&lt;html&gt;
&lt;body&gt;
&lt;img src="image.jpg"&gt;
&lt;/body&gt;
&lt;/html&gt;

Request Image (new TCP connection):
GET /image.jpg HTTP/1.0
Host: www.example.com

Server Response:
HTTP/1.0 200 OK
Content-Type: image/jpeg
Content-Length: 20480
(binary data)
    </pre>
    <div class="note">Observation: Two separate TCP connections, one per resource.</div>

    <h2>4. Advantages of HTTP/1.0</h2>
    <ul>
        <li>Introduced headers and status codes → structured communication</li>
        <li>Supported multiple methods (GET, POST, HEAD)</li>
        <li>Allowed browsers to understand content type (MIME types)</li>
    </ul>

    <h2>5. Transition to HTTP/1.1</h2>
    <ul>
        <li>Persistent connections fixed connection inefficiency</li>
        <li>Added more methods (PUT, DELETE, OPTIONS)</li>
        <li>Introduced caching, host headers, chunked transfers → more efficient</li>
    </ul>

    <h2>Summary Table – HTTP/0.9 vs HTTP/1.0</h2>
    <table>
        <thead>
            <tr><th>Feature</th><th>HTTP/0.9</th><th>HTTP/1.0</th></tr>
        </thead>
        <tbody>
            <tr><td>Methods</td><td>GET only</td><td>GET, POST, HEAD</td></tr>
            <tr><td>Headers</td><td>None</td><td>Request & Response Headers</td></tr>
            <tr><td>Status Codes</td><td>None</td><td>200, 404, 500, etc.</td></tr>
            <tr><td>TCP Connection</td><td>New per request</td><td>New per request (no persistent connections)</td></tr>
            <tr><td>MIME Support</td><td>No</td><td>Yes (Content-Type)</td></tr>
            <tr><td>Efficiency</td><td>Very basic</td><td>More structured but still limited</td></tr>
        </tbody>
    </table>

    <h1>HTTP/1.1 – Detailed Overview</h1>

<h2>1. Introduction</h2>
<ul>
    <li><strong>Year Introduced:</strong> 1997 (RFC 2068, updated RFC 2616, now RFC 7230-7235)</li>
    <li><strong>Purpose:</strong> Improve HTTP/1.0 by adding persistent connections, caching, host headers, and additional methods.</li>
    <li><strong>Port:</strong> 80 (HTTP), 443 (HTTPS)</li>
    <li><strong>Nature:</strong> Text-based, request-response protocol</li>
</ul>

<h2>2. Key Features of HTTP/1.1</h2>

<h3>A. Persistent Connections</h3>
<p>HTTP/1.0: Each request required a new TCP connection → high overhead.</p>
<p>HTTP/1.1: Default is persistent connection (keep-alive). Multiple requests/responses can be sent over a single TCP connection, reducing latency.</p>
<pre>
Header Example:
Connection: keep-alive
</pre>

<h3>B. Chunked Transfer Encoding</h3>
<p>Allows sending data in chunks when the server doesn’t know content length in advance. Useful for dynamic content.</p>
<pre>
Example Response:
HTTP/1.1 200 OK
Transfer-Encoding: chunked

7
Mozilla
9
Developer
7
Network
0
</pre>

<h3>C. Host Header</h3>
<p>Supports multiple domains on a single IP (virtual hosting). Client must send Host header in every request.</p>
<pre>
GET /index.html HTTP/1.1
Host: www.example.com
</pre>

<h3>D. Additional Methods</h3>
<table>
    <thead>
        <tr><th>Method</th><th>Purpose</th></tr>
    </thead>
    <tbody>
        <tr><td>GET</td><td>Retrieve resource</td></tr>
        <tr><td>POST</td><td>Submit data to server</td></tr>
        <tr><td>HEAD</td><td>Retrieve headers only</td></tr>
        <tr><td>PUT</td><td>Update existing resource</td></tr>
        <tr><td>DELETE</td><td>Remove resource</td></tr>
        <tr><td>OPTIONS</td><td>Check available methods for a resource</td></tr>
        <tr><td>TRACE</td><td>Echo request for testing</td></tr>
        <tr><td>CONNECT</td><td>Tunnel through a proxy</td></tr>
    </tbody>
</table>

<h3>E. HTTP Headers</h3>
<p><strong>Request Headers:</strong> Provide info about the request or client.</p>
<ul>
    <li>User-Agent → identifies client browser</li>
    <li>Accept → content types the client can handle</li>
    <li>Host → domain of the server</li>
    <li>Cookie → client-side stored data</li>
</ul>
<p><strong>Response Headers:</strong> Provide info about the server or response.</p>
<ul>
    <li>Content-Type → type of resource (text/html, image/png)</li>
    <li>Content-Length → size of resource</li>
    <li>Cache-Control → caching instructions</li>
    <li>Set-Cookie → store cookies in client</li>
</ul>

<h3>F. Status Codes</h3>
<table>
    <thead>
        <tr><th>Code</th><th>Meaning</th></tr>
    </thead>
    <tbody>
        <tr><td>100</td><td>Continue</td></tr>
        <tr><td>200</td><td>OK</td></tr>
        <tr><td>201</td><td>Created</td></tr>
        <tr><td>204</td><td>No Content</td></tr>
        <tr><td>301</td><td>Moved Permanently</td></tr>
        <tr><td>302</td><td>Found (Temporary Redirect)</td></tr>
        <tr><td>304</td><td>Not Modified</td></tr>
        <tr><td>400</td><td>Bad Request</td></tr>
        <tr><td>401</td><td>Unauthorized</td></tr>
        <tr><td>403</td><td>Forbidden</td></tr>
        <tr><td>404</td><td>Not Found</td></tr>
        <tr><td>500</td><td>Internal Server Error</td></tr>
        <tr><td>503</td><td>Service Unavailable</td></tr>
    </tbody>
</table>

<h3>G. Caching Support</h3>
<ul>
    <li>Expires: Absolute expiry time.</li>
    <li>Cache-Control: Detailed caching directives (no-cache, max-age=3600).</li>
    <li>ETag: Entity tag to validate cached content.</li>
    <li>If-Modified-Since / If-None-Match: Conditional requests to reduce bandwidth.</li>
</ul>

<h3>H. Content Negotiation</h3>
<p>Server can provide different versions of content based on client preferences:</p>
<ul>
    <li>Language (Accept-Language)</li>
    <li>Format (Accept)</li>
    <li>Encoding (Accept-Encoding)</li>
</ul>

<h3>I. Pipelining (Optional)</h3>
<p>Allows sending multiple requests without waiting for each response. Not widely used due to head-of-line blocking.</p>

<h2>3. HTTP/1.1 Request-Response Example</h2>
<pre>
Request:
GET /index.html HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0
Accept: text/html
Connection: keep-alive

Response:
HTTP/1.1 200 OK
Date: Wed, 16 Oct 2025 16:00:00 GMT
Server: Apache/2.4.41 (Unix)
Content-Type: text/html
Content-Length: 1256
Connection: keep-alive

<html>
<head><title>Example Page</title></head>
<body>Hello HTTP/1.1!</body>
</html>
</pre>

<h2>4. Advantages over HTTP/1.0</h2>
<ul>
    <li>Persistent connections → fewer TCP connections</li>
    <li>Host header → multiple websites on same IP</li>
    <li>Chunked transfer → send dynamic content efficiently</li>
    <li>Expanded methods → more flexible web interactions</li>
    <li>Better caching → reduced bandwidth and faster load times</li>
</ul>

<h2>5. Limitations</h2>
<ul>
    <li>Text-based → headers repeated in each request (inefficient)</li>
    <li>Head-of-line blocking → requests processed sequentially per connection</li>
    <li>No multiplexing → solved in HTTP/2</li>
</ul>
<h1>HTTP/2 – Detailed Overview</h1>

<h2>1. Introduction</h2>
<ul>
    <li><strong>Standardized:</strong> 2015 by the IETF (RFC 7540)</li>
    <li><strong>Goal:</strong> Improve web performance by reducing latency and optimizing data transfer between client and server.</li>
    <li><strong>Backward Compatibility:</strong> Fully compatible with HTTP/1.1 – existing applications work without modification.</li>
</ul>

<h2>2. Key Goals of HTTP/2</h2>
<ul>
    <li>Reduce latency – Deliver web pages faster.</li>
    <li>Minimize overhead – Reduce repetitive headers and connection delays.</li>
    <li>Enable multiplexing – Send multiple requests simultaneously over a single connection.</li>
    <li>Improve security – Typically used with HTTPS (TLS), though can technically work without encryption.</li>
</ul>

<h2>3. Major Features of HTTP/2</h2>

<h3>A. Binary Protocol</h3>
<p>HTTP/2 is binary, unlike HTTP/1.x which is text-based.</p>
<ul>
    <li>Easier for computers to parse</li>
    <li>Reduces errors and improves performance</li>
    <li>Data is sent as frames rather than plain text</li>
</ul>

<h3>B. Multiplexing</h3>
<p>Multiple requests and responses can be sent simultaneously over a single TCP connection, eliminating head-of-line blocking at the HTTP layer.</p>
<p><strong>Example:</strong> Loading a page with multiple images, CSS, JS files – all requests are sent in parallel over one connection.</p>

<h3>C. Header Compression (HPACK)</h3>
<p>HTTP/2 compresses headers to reduce data sent over the network.</p>
<ul>
    <li>Cookies and repeated headers are compressed and reused.</li>
</ul>

<h3>D. Server Push</h3>
<p>The server can proactively send resources before the client requests them, reducing round-trip time.</p>
<p><strong>Example:</strong> Client requests <code>index.html</code>; server pushes <code>style.css</code> and <code>script.js</code> immediately.</p>

<h3>E. Stream Prioritization</h3>
<p>Clients can prioritize important resources, e.g., main HTML content loads first, then images and ads.</p>

<h3>F. Persistent Connections</h3>
<p>Like HTTP/1.1, TCP connections remain alive. Multiplexing allows multiple resources to share the same connection efficiently.</p>

<h2>4. How HTTP/2 Works</h2>
<ol>
    <li>Client and server negotiate HTTP/2 via ALPN (Application-Layer Protocol Negotiation) during TLS handshake.</li>
    <li>HTTP/2 establishes a single TCP connection.</li>
    <li>All data is split into binary frames tagged with a stream ID.</li>
    <li>Multiplexing and header compression occur.</li>
    <li>Server may push additional resources if needed.</li>
</ol>

<h2>5. Advantages of HTTP/2</h2>
<table>
    <thead>
        <tr><th>Advantage</th><th>Explanation</th></tr>
    </thead>
    <tbody>
        <tr><td>Faster Web Pages</td><td>Multiplexing reduces waiting time for multiple requests.</td></tr>
        <tr><td>Lower Latency</td><td>Header compression and server push reduce overhead.</td></tr>
        <tr><td>Better Use of Single Connection</td><td>Fewer TCP connections needed → efficient use of network resources.</td></tr>
        <tr><td>Backward Compatible</td><td>Works with existing HTTP/1.1 applications.</td></tr>
        <tr><td>Improved Security</td><td>Usually paired with HTTPS, enhancing data confidentiality and integrity.</td></tr>
    </tbody>
</table>

<h2>6. Limitations</h2>
<ul>
    <li>Relies on TCP, so packet loss affects all streams (head-of-line blocking at TCP level).</li>
    <li>Server push must be carefully used to avoid wasting bandwidth.</li>
    <li>More complex than HTTP/1.x (binary framing, HPACK compression).</li>
</ul>

<h2>7. Ports</h2>
<ul>
    <li>HTTP/2 over TLS: Port 443 (HTTPS) – most common.</li>
    <li>HTTP/2 without TLS: Port 80 (rare, not recommended).</li>
</ul>

<h2>8. Real-World Example</h2>
<p>Browser requests <code>https://example.com/index.html</code>. Server responds with <code>index.html</code>. HTTP/2 server pushes <code>style.css</code> and <code>script.js</code> automatically. Browser renders page faster because multiple resources were delivered in parallel.</p>

<h2>9. Comparison with HTTP/1.1</h2>
<table>
    <thead>
        <tr><th>Feature</th><th>HTTP/1.1</th><th>HTTP/2</th></tr>
    </thead>
    <tbody>
        <tr><td>Protocol Type</td><td>Text</td><td>Binary</td></tr>
        <tr><td>Multiplexing</td><td>No</td><td>Yes</td></tr>
        <tr><td>Header Compression</td><td>No</td><td>HPACK</td></tr>
        <tr><td>Server Push</td><td>No</td><td>Yes</td></tr>
        <tr><td>Connection</td><td>One request per connection (persistent optional)</td><td>Single connection for multiple requests</td></tr>
        <tr><td>Performance</td><td>Slower with many resources</td><td>Faster, efficient, low latency</td></tr>
    </tbody>
</table>
<h1>HTTP/3 – The Complete Deep Dive</h1>

<h2>1. Introduction to HTTP/3</h2>
<ul>
    <li><strong>Full Name:</strong> HyperText Transfer Protocol version 3</li>
    <li><strong>Standardized By:</strong> IETF in 2020</li>
    <li><strong>Underlying Protocol:</strong> QUIC (Quick UDP Internet Connections)</li>
    <li><strong>Purpose:</strong> Designed for low latency, high reliability, multiplexing, and encryption, addressing limitations of HTTP/2 over TCP.</li>
</ul>

<h2>2. Why HTTP/3 Was Needed</h2>
<ul>
    <li><strong>Head-of-Line (HOL) Blocking in TCP:</strong> Packet loss blocks all streams in HTTP/2.</li>
    <li><strong>Slow Connection Establishment:</strong> TCP + TLS handshakes increase latency.</li>
    <li><strong>Network Changes Break Connections:</strong> Switching networks breaks HTTP/2 connections.</li>
    <li><strong>Inefficient Recovery from Packet Loss:</strong> TCP retransmits lost packets for all streams → reduces throughput.</li>
</ul>
<p>HTTP/3 solves these issues by moving from TCP to QUIC (over UDP).</p>

<h2>3. QUIC Protocol – The Foundation of HTTP/3</h2>
<p>HTTP/3 is implemented on QUIC, which combines transport and security layers.</p>
<table>
    <thead>
        <tr><th>Feature</th><th>Description</th></tr>
    </thead>
    <tbody>
        <tr><td>Based on UDP</td><td>Uses UDP to bypass TCP limitations.</td></tr>
        <tr><td>Multiplexed Streams</td><td>Multiple independent streams per connection; lost packets affect only that stream.</td></tr>
        <tr><td>0-RTT / 1-RTT Handshake</td><td>Reduces latency by allowing returning clients to send data immediately.</td></tr>
        <tr><td>Integrated TLS 1.3</td><td>Encryption is mandatory and built into the protocol.</td></tr>
        <tr><td>Connection Migration</td><td>Connection continues even if the client IP changes.</td></tr>
        <tr><td>Forward Error Correction (FEC)</td><td>Optional; reduces retransmissions in high-loss networks.</td></tr>
    </tbody>
</table>

<p><strong>Architecture:</strong></p>
<pre>
+------------------+  <-- HTTP Layer
|  HTTP/3 Streams  |
+------------------+
|    QUIC Layer    |  <-- Transport + Security
+------------------+
|    UDP Layer     |  <-- Internet Layer
+------------------+
| Network / IP     |
+------------------+
</pre>

<h2>4. HTTP/3 Features in Detail</h2>

<h3>4.1 Multiplexing Without Head-of-Line Blocking</h3>
<p>Each stream in QUIC is independent. Packet loss in one stream does not block others.</p>

<h3>4.2 0-RTT Connection Setup</h3>
<p>Returning clients can resume previous sessions. Browser sends data immediately without waiting for handshake.</p>

<h3>4.3 Built-in Encryption (TLS 1.3)</h3>
<p>All communication is secure and private; no separate TLS handshake over TCP is needed.</p>

<h3>4.4 Connection Migration</h3>
<p>QUIC uses connection IDs rather than IP addresses. Changing IP (Wi-Fi → mobile) does not drop the connection.</p>

<h3>4.5 Stream Prioritization & Flow Control</h3>
<p>HTTP/3 allows prioritizing streams to load important resources first. Flow control prevents a single stream from monopolizing bandwidth.</p>

<h3>4.6 Reduced Latency</h3>
<ul>
    <li>Fewer handshakes</li>
    <li>0-RTT resumption</li>
    <li>Multiplexed streams</li>
    <li>Particularly beneficial for mobile networks with high packet loss or jitter</li>
</ul>

<h2>5. HTTP/3 Request-Response Workflow</h2>
<ol>
    <li>Client initiates QUIC connection (0-RTT if resuming) and sends HTTP/3 request over a QUIC stream.</li>
    <li>Server responds over independent streams; multiple resources are delivered simultaneously.</li>
    <li>QUIC connection persists; streams can be added dynamically without opening new connections.</li>
</ol>

<p><strong>Diagram:</strong></p>
<pre>
Client Browser
   | HTTP/3 Request (QUIC Stream 1)
   |------------------------------>|
   | HTTP/3 Request (QUIC Stream 2)
   |------------------------------>|
Server
   | Response Stream 1 (HTML)
   |<------------------------------|
   | Response Stream 2 (CSS, JS)
   |<------------------------------|
</pre>

<h2>6. Comparison with HTTP/1.1 and HTTP/2</h2>
<table>
    <thead>
        <tr><th>Feature</th><th>HTTP/1.1</th><th>HTTP/2</th><th>HTTP/3</th></tr>
    </thead>
    <tbody>
        <tr><td>Transport</td><td>TCP</td><td>TCP</td><td>QUIC (UDP)</td></tr>
        <tr><td>Encryption</td><td>Optional</td><td>Optional</td><td>Mandatory (TLS 1.3)</td></tr>
        <tr><td>Multiplexing</td><td>No</td><td>Yes (TCP)</td><td>Yes (QUIC, independent streams)</td></tr>
        <tr><td>Head-of-Line Blocking</td><td>Yes</td><td>Yes (TCP-level)</td><td>No</td></tr>
        <tr><td>Connection Migration</td><td>No</td><td>No</td><td>Yes</td></tr>
        <tr><td>Latency</td><td>High</td><td>Medium</td><td>Low</td></tr>
        <tr><td>Stream Prioritization</td><td>No</td><td>Yes</td><td>Yes</td></tr>
    </tbody>
</table>

<h2>7. Advantages of HTTP/3</h2>
<ul>
    <li>Faster page load times, especially on mobile or unreliable networks.</li>
    <li>No head-of-line blocking; lost packets affect only one stream.</li>
    <li>Always encrypted → better security and privacy.</li>
    <li>Connection migration → seamless network switching.</li>
    <li>Efficient multiplexing → reduces overhead and improves throughput.</li>
    <li>0-RTT → faster reconnections.</li>
    <li>Better support for real-time applications (video, gaming, streaming).</li>
</ul>

<h2>8. Challenges of HTTP/3</h2>
<ul>
    <li>Firewall and NAT compatibility: Some networks block or throttle UDP traffic.</li>
    <li>Server adoption: Older servers and load balancers may not fully support QUIC.</li>
    <li>Complexity: QUIC is more complex than TCP, requiring sophisticated implementation.</li>
    <li>Debugging tools: Harder to inspect and troubleshoot due to encryption and multiplexing.</li>
</ul>

<h2>9. Real-World Use Cases</h2>
<ul>
    <li>Video Streaming: YouTube, Netflix → smoother streaming with HTTP/3.</li>
    <li>Gaming: Cloud gaming services like Stadia → low-latency input and streaming.</li>
    <li>Mobile Browsing: Faster page loads on cellular networks.</li>
    <li>Enterprise Applications: SaaS apps with multiple resources benefit from multiplexing and low latency.</li>
</ul>

<h2>10. Key Takeaways</h2>
<ul>
    <li>HTTP/3 is designed for speed, reliability, and security.</li>
    <li>It replaces TCP with QUIC to solve latency and packet loss issues.</li>
    <li>All communication is encrypted by default.</li>
    <li>HTTP/3 improves mobile performance, real-time applications, and high-traffic websites.</li>
</ul>
<h1>Browser & Network Protocols Overview</h1>

<h2>1. HTTP / HTTPS</h2>
<ul>
    <li><strong>Full Form:</strong> HyperText Transfer Protocol / Secure HTTP</li>
    <li><strong>Layer:</strong> Application Layer</li>
    <li><strong>Purpose:</strong> Access websites, web pages, and resources</li>
    <li><strong>Ports:</strong> HTTP → 80, HTTPS → 443</li>
    <li><strong>Features:</strong> HTTP/1.1, HTTP/2, HTTP/3; HTTPS uses TLS/SSL for encryption</li>
    <li><strong>Example:</strong> <a href="https://www.google.com">https://www.google.com</a></li>
</ul>

<h2>2. FTP / SFTP</h2>
<ul>
    <li><strong>Full Form:</strong> File Transfer Protocol / Secure File Transfer Protocol</li>
    <li><strong>Layer:</strong> Application Layer</li>
    <li><strong>Purpose:</strong> Download/upload files from/to servers</li>
    <li><strong>Ports:</strong> FTP → 21, SFTP → 22</li>
    <li><strong>Example:</strong> Uploading website files to a hosting server</li>
</ul>

<h2>3. DNS (Domain Name System)</h2>
<ul>
    <li><strong>Layer:</strong> Application Layer</li>
    <li><strong>Purpose:</strong> Converts domain names to IP addresses</li>
    <li><strong>Ports:</strong> 53 (UDP for queries, TCP for zone transfers)</li>
    <li><strong>Example:</strong> www.youtube.com → 142.250.190.78</li>
</ul>

<h2>4. WebSocket</h2>
<ul>
    <li><strong>Layer:</strong> Application Layer</li>
    <li><strong>Purpose:</strong> Full-duplex communication between client and server in real-time</li>
    <li><strong>Ports:</strong> 80 (ws), 443 (wss - secure)</li>
    <li><strong>Example:</strong> Chat applications, live notifications, online gaming</li>
</ul>

<h2>5. QUIC</h2>
<ul>
    <li><strong>Layer:</strong> Transport Layer (UDP-based)</li>
    <li><strong>Purpose:</strong> Underlying transport protocol for HTTP/3</li>
    <li><strong>Ports:</strong> 443 (used with HTTP/3)</li>
    <li><strong>Example:</strong> Faster, multiplexed, encrypted connections for modern web pages</li>
</ul>

<h2>6. TLS / SSL</h2>
<ul>
    <li><strong>Full Form:</strong> Transport Layer Security / Secure Sockets Layer</li>
    <li><strong>Layer:</strong> Presentation / Security Layer</li>
    <li><strong>Purpose:</strong> Encrypts communication between browser and server</li>
    <li><strong>Ports:</strong> Typically piggybacks on HTTPS → 443</li>
    <li><strong>Example:</strong> HTTPS websites, banking apps, e-commerce</li>
</ul>

<h2>7. SMTP / IMAP / POP3 (Mail Protocols)</h2>
<ul>
    <li><strong>Layer:</strong> Application Layer</li>
    <li><strong>Purpose:</strong> Sending/receiving emails from browser-based email clients</li>
    <li><strong>Ports:</strong> 
        <ul>
            <li>SMTP → 25 / 587 / 465</li>
            <li>IMAP → 143 / 993 (secure)</li>
            <li>POP3 → 110 / 995 (secure)</li>
        </ul>
    </li>
    <li><strong>Example:</strong> Gmail, Outlook webmail</li>
</ul>

<h2>8. WebRTC (Web Real-Time Communication)</h2>
<ul>
    <li><strong>Layer:</strong> Application Layer</li>
    <li><strong>Purpose:</strong> Real-time audio, video, and data sharing directly between browsers</li>
    <li><strong>Ports:</strong> Uses UDP (via ICE/STUN/TURN)</li>
    <li><strong>Example:</strong> Video calls (Google Meet, Zoom web), P2P file transfer</li>
</ul>

<h2>9. MQTT / AMQP (IoT / Messaging Protocols)</h2>
<ul>
    <li><strong>Layer:</strong> Application Layer</li>
    <li><strong>Purpose:</strong> Lightweight messaging protocol for IoT or web apps</li>
    <li><strong>Ports:</strong> MQTT → 1883, 8883 (secure)</li>
    <li><strong>Example:</strong> Web-based dashboards showing live sensor data</li>
</ul>

<h2>10. SIP (Session Initiation Protocol)</h2>
<ul>
    <li><strong>Layer:</strong> Application Layer</li>
    <li><strong>Purpose:</strong> Establish, manage, and terminate real-time communication sessions</li>
    <li><strong>Ports:</strong> 5060 (UDP/TCP), 5061 (TLS)</li>
    <li><strong>Example:</strong> Web-based VoIP calls</li>
</ul>

<h2>11. NTP (Network Time Protocol)</h2>
<ul>
    <li><strong>Layer:</strong> Application Layer</li>
    <li><strong>Purpose:</strong> Syncs browser/device clock with server time</li>
    <li><strong>Ports:</strong> 123 (UDP)</li>
    <li><strong>Example:</strong> Security certificates, online transactions, timestamping</li>
</ul>

<h2>12. ICMP / Ping (Indirectly Used by Browsers)</h2>
<ul>
    <li><strong>Layer:</strong> Network Layer</li>
    <li><strong>Purpose:</strong> Browser doesn’t directly use ICMP, but network diagnostics (ping/traceroute) rely on it</li>
    <li><strong>Example:</strong> Detecting network reachability for AJAX calls or APIs</li>
</ul>

<h2>13. Other Protocols</h2>
<ul>
    <li>WebDAV: File editing/management over HTTP</li>
    <li>SPDY: Predecessor to HTTP/2 (obsolete)</li>
    <li>CoAP (Constrained Application Protocol): Lightweight protocol for IoT via browsers</li>
</ul>

<h2>Summary Table: Browser Protocols</h2>
<table border="1" cellspacing="0" cellpadding="5">
    <thead>
        <tr>
            <th>Protocol</th>
            <th>Layer</th>
            <th>Purpose</th>
            <th>Ports</th>
            <th>Example</th>
        </tr>
    </thead>
    <tbody>
        <tr><td>HTTP / HTTPS</td><td>Application</td><td>Web pages</td><td>80 / 443</td><td>www.google.com</td></tr>
        <tr><td>FTP / SFTP</td><td>Application</td><td>File transfer</td><td>21 / 22</td><td>Upload files to server</td></tr>
        <tr><td>DNS</td><td>Application</td><td>Resolve domain → IP</td><td>53</td><td>www.youtube.com</td></tr>
        <tr><td>WebSocket</td><td>Application</td><td>Real-time two-way communication</td><td>80 / 443</td><td>Chat apps</td></tr>
        <tr><td>QUIC</td><td>Transport</td><td>HTTP/3 transport</td><td>443</td><td>Fast web pages</td></tr>
        <tr><td>TLS / SSL</td><td>Security</td><td>Encryption</td><td>443</td><td>HTTPS</td></tr>
        <tr><td>SMTP / IMAP / POP3</td><td>Application</td><td>Email</td><td>25 / 587 / 465 / 143 / 993 / 110 / 995</td><td>Gmail</td></tr>
        <tr><td>WebRTC</td><td>Application</td><td>Real-time media</td><td>UDP</td><td>Video calls</td></tr>
        <tr><td>MQTT / AMQP</td><td>Application</td><td>IoT messaging</td><td>1883 / 8883</td><td>Live dashboards</td></tr>
        <tr><td>SIP</td><td>Application</td><td>VoIP signaling</td><td>5060 / 5061</td><td>Web VoIP calls</td></tr>
        <tr><td>NTP</td><td>Application</td><td>Time sync</td><td>123</td><td>Certificates, timestamps</td></tr>
    </tbody>
</table>
<h1>Transport Layer Overview</h1>

  <h2>1. What is the Transport Layer?</h2>
  <ul>
    <li>Provides <strong>reliable or unreliable communication</strong> between processes on different hosts.</li>
    <li>Acts as a bridge between the <strong>Application Layer</strong> and <strong>Network Layer</strong>.</li>
    <li>Uses <strong>ports</strong> to differentiate applications on the same host.</li>
    <li><strong>Key Idea:</strong> While the Network Layer delivers packets host-to-host, the Transport Layer ensures <strong>process-to-process delivery</strong>.</li>
  </ul>

  <h2>2. Main Functions of the Transport Layer</h2>
  <h3>a) Segmentation & Reassembly</h3>
  <p>Breaks large messages into smaller <strong>segments</strong> for transmission and reassembles them at the receiver.</p>

  <h3>b) Connection Establishment & Termination</h3>
  <p>Manages TCP connections using a <strong>3-way handshake</strong> and ensures reliable connection setup and teardown.</p>

  <h3>c) Flow Control</h3>
  <p>Prevents fast sender from overwhelming slow receiver. Example: <strong>TCP sliding window</strong>.</p>

  <h3>d) Error Detection & Recovery</h3>
  <p>Uses checksums to detect errors and retransmits lost or corrupted segments (TCP).</p>

  <h3>e) Multiplexing & Demultiplexing</h3>
  <p>Uses port numbers to deliver data to the correct application. Example: Web browser (port 80) vs Email client (port 25).</p>

  <h3>f) Reliability</h3>
  <p>TCP provides reliable, ordered delivery; UDP provides unreliable, best-effort delivery.</p>

  <h2>3. Transport Layer Protocols</h2>
  <table>
    <tr>
      <th>Protocol</th>
      <th>Type</th>
      <th>Features</th>
      <th>Port Example</th>
    </tr>
    <tr>
      <td>TCP</td>
      <td>Connection-oriented</td>
      <td>Reliable, ordered, error-checked, flow control</td>
      <td>HTTP: 80, HTTPS: 443</td>
    </tr>
    <tr>
      <td>UDP</td>
      <td>Connectionless</td>
      <td>Fast, minimal overhead, no reliability</td>
      <td>DNS: 53, DHCP: 67/68</td>
    </tr>
    <tr>
      <td>SCTP</td>
      <td>Connection-oriented</td>
      <td>Multi-stream, reliable, supports message boundaries</td>
      <td>VoIP, telecom</td>
    </tr>
    <tr>
      <td>DCCP</td>
      <td>Connection-oriented</td>
      <td>Reliable delivery with congestion control, for streaming</td>
      <td>Multimedia streaming</td>
    </tr>
  </table>

  <h2>4. TCP vs UDP</h2>
  <table>
    <tr>
      <th>Feature</th>
      <th>TCP</th>
      <th>UDP</th>
    </tr>
    <tr>
      <td>Connection</td>
      <td>Connection-oriented</td>
      <td>Connectionless</td>
    </tr>
    <tr>
      <td>Reliability</td>
      <td>Yes, retransmission on loss</td>
      <td>No, best-effort</td>
    </tr>
    <tr>
      <td>Flow Control</td>
      <td>Yes (sliding window)</td>
      <td>No</td>
    </tr>
    <tr>
      <td>Ordering</td>
      <td>Guarantees order</td>
      <td>No guarantee</td>
    </tr>
    <tr>
      <td>Header Size</td>
      <td>20–60 bytes</td>
      <td>8 bytes</td>
    </tr>
    <tr>
      <td>Use Case</td>
      <td>Web, Email, File Transfer</td>
      <td>DNS, Video streaming, VoIP</td>
    </tr>
  </table>

  <h2>5. TCP Connection Establishment (3-Way Handshake)</h2>
  <pre><code>SYN: Client → Server (Request connection)
SYN-ACK: Server → Client (Acknowledges SYN)
ACK: Client → Server (Acknowledges SYN-ACK, connection established)

Termination: Usually 4-way handshake with FIN and ACK messages.</code></pre>

  <h2>6. Flow Control (TCP Sliding Window)</h2>
  <ul>
    <li>Ensures sender does not overwhelm receiver.</li>
    <li>Receiver advertises a <strong>window size</strong> (how much data it can accept).</li>
    <li>Sender sends only that much data at a time.</li>
  </ul>

  <h2>7. Multiplexing & Demultiplexing</h2>
  <ul>
    <li><strong>Multiplexing:</strong> Multiple applications share the same network connection.</li>
    <li><strong>Demultiplexing:</strong> Uses port numbers to deliver data to the correct application.</li>
    <li>Example: HTTP (80) & SMTP (25) both use TCP → Transport layer delivers segments based on <strong>destination port</strong>.</li>
  </ul>

  <h2>8. Error Detection & Reliability</h2>
  <ul>
    <li><strong>Checksum:</strong> Detects errors in transmitted segments.</li>
    <li><strong>Acknowledgment (ACK):</strong> Confirms receipt of data.</li>
    <li><strong>Retransmission:</strong> Lost/corrupted segments are resent.</li>
    <li><strong>Sequence Numbers:</strong> Ensure data arrives in order.</li>
  </ul>

  <h2>9. Real-World Example</h2>
  <pre><code>1. Open https://www.google.com in a browser.
2. HTTP request sent from Application Layer → Transport Layer (TCP).
3. TCP breaks data into segments, adds sequence numbers, sends to Network Layer (IP).
4. Server reassembles segments and responds with HTTP response.</code></pre>


  <h1>Transmission Control Protocol (TCP) – Full Depth</h1>

  <h2>1. Introduction</h2>
  <ul>
    <li>Full Name: <strong>Transmission Control Protocol</strong></li>
    <li>Layer: <strong>Transport Layer (Layer 4, OSI model)</strong></li>
    <li>Type: Connection-oriented, reliable, full-duplex protocol</li>
    <li>Purpose: Ensures process-to-process delivery of data between hosts on a network.</li>
    <li>Key Idea: TCP is like a reliable virtual pipe between two applications.</li>
  </ul>

  <h2>2. Features of TCP</h2>
  <ul>
    <li>Connection-Oriented: 3-way handshake before data transfer.</li>
    <li>Reliable: Guarantees delivery using acknowledgments and retransmissions.</li>
    <li>Ordered: Bytes arrive in the same order as sent.</li>
    <li>Full-Duplex: Both sender and receiver can transmit simultaneously.</li>
    <li>Flow Control: Sliding window prevents overwhelming receiver.</li>
    <li>Congestion Control: Slow start, congestion avoidance, fast retransmit/recovery.</li>
    <li>Error Detection: Uses checksum to detect corrupted segments.</li>
    <li>Multiplexing/Demultiplexing: Uses ports to deliver data to correct applications.</li>
    <li>Variable Segment Size: Supports Maximum Segment Size (MSS).</li>
  </ul>

  <h2>3. TCP Segment Structure</h2>
  <p>Header (minimum 20 bytes) + Data</p>
  <table>
    <tr>
      <th>Field</th>
      <th>Size</th>
      <th>Description</th>
    </tr>
    <tr><td>Source Port</td><td>16 bits</td><td>Sending application port</td></tr>
    <tr><td>Destination Port</td><td>16 bits</td><td>Receiving application port</td></tr>
    <tr><td>Sequence Number</td><td>32 bits</td><td>Position of first byte in segment</td></tr>
    <tr><td>Acknowledgment Number</td><td>32 bits</td><td>Next expected byte from sender</td></tr>
    <tr><td>Data Offset</td><td>4 bits</td><td>Header length</td></tr>
    <tr><td>Reserved</td><td>6 bits</td><td>Reserved for future use</td></tr>
    <tr><td>Flags (Control Bits)</td><td>6 bits</td><td>SYN, ACK, FIN, RST, PSH, URG</td></tr>
    <tr><td>Window Size</td><td>16 bits</td><td>Sliding window for flow control</td></tr>
    <tr><td>Checksum</td><td>16 bits</td><td>Error detection</td></tr>
    <tr><td>Urgent Pointer</td><td>16 bits</td><td>Marks urgent data</td></tr>
    <tr><td>Options</td><td>Variable</td><td>Optional features (timestamps, MSS, etc.)</td></tr>
    <tr><td>Data</td><td>Variable</td><td>Actual application data</td></tr>
  </table>

  <h2>4. TCP Control Flags</h2>
  <table>
    <tr><th>Flag</th><th>Description</th></tr>
    <tr><td>SYN</td><td>Synchronize sequence numbers (connection setup)</td></tr>
    <tr><td>ACK</td><td>Acknowledgment field is valid</td></tr>
    <tr><td>FIN</td><td>Sender has finished sending data (connection termination)</td></tr>
    <tr><td>RST</td><td>Reset connection (abort)</td></tr>
    <tr><td>PSH</td><td>Push data immediately to the application</td></tr>
    <tr><td>URG</td><td>Urgent pointer valid, indicates urgent data</td></tr>
  </table>

  <h2>5. TCP Connection Management</h2>
  <h3>5.1 Connection Establishment – 3-Way Handshake</h3>
  <pre><code>Client -> Server: SYN (seq=x)
Server -> Client: SYN-ACK (seq=y, ack=x+1)
Client -> Server: ACK (ack=y+1)</code></pre>
  <p>Purpose: Synchronize sequence numbers, establish reliable, full-duplex connection.</p>

  <h3>5.2 Connection Termination – 4-Way Handshake</h3>
  <pre><code>FIN -> ACK -> FIN -> ACK</code></pre>

  <h2>6. TCP States</h2>
  <table>
    <tr><th>State</th><th>Description</th></tr>
    <tr><td>CLOSED</td><td>No connection</td></tr>
    <tr><td>LISTEN</td><td>Waiting for connection (server)</td></tr>
    <tr><td>SYN-SENT</td><td>SYN sent, waiting for SYN-ACK</td></tr>
    <tr><td>SYN-RECEIVED</td><td>SYN received, sent SYN-ACK</td></tr>
    <tr><td>ESTABLISHED</td><td>Connection open, data transfer</td></tr>
    <tr><td>FIN-WAIT-1</td><td>Waiting for ACK of FIN sent</td></tr>
    <tr><td>FIN-WAIT-2</td><td>FIN acknowledged, waiting FIN from other side</td></tr>
    <tr><td>CLOSE-WAIT</td><td>Received FIN, waiting application to close</td></tr>
    <tr><td>CLOSING</td><td>Both sides sent FIN, waiting ACK</td></tr>
    <tr><td>LAST-ACK</td><td>Waiting final ACK to terminate</td></tr>
    <tr><td>TIME-WAIT</td><td>Wait 2*MSL to ensure ACK received</td></tr>
  </table>

  <h2>7. TCP Reliability Mechanisms</h2>
  <ul>
    <li><strong>Sequence Numbers:</strong> Each byte has a unique number, helps reassemble data in order.</li>
    <li><strong>ACK:</strong> Receiver sends ACK with next expected byte.</li>
    <li><strong>Retransmission:</strong> Lost segments are resent (timeout or duplicate ACK triggers retransmission).</li>
    <li><strong>Checksum:</strong> Detects errors in header and data.</li>
  </ul>

  <h2>8. Flow Control</h2>
  <p>Sliding Window: Window size = bytes receiver can accept. Sender sends only within advertised window.</p>

  <h2>9. Congestion Control</h2>
  <table>
    <tr><th>Algorithm</th><th>Purpose</th></tr>
    <tr><td>Slow Start</td><td>Gradually increases sending rate</td></tr>
    <tr><td>Congestion Avoidance</td><td>Detects congestion, avoids overloading</td></tr>
    <tr><td>Fast Retransmit</td><td>Quickly retransmit lost segments on duplicate ACKs</td></tr>
    <tr><td>Fast Recovery</td><td>Resume sending after retransmission without starting slow</td></tr>
  </table>

  <h2>10. TCP Segment Example</h2>
  <pre><code>Message = 4000 bytes
MSS = 1000 bytes
TCP breaks into 4 segments, adds sequence numbers, sends
Receiver ACKs each segment and reassembles</code></pre>

  <h2>11. TCP Multiplexing & Demultiplexing</h2>
  <p>Port Numbers identify sending/receiving applications. Socket = (IP, Port).</p>
  <ul>
    <li>Web server HTTP → port 80</li>
    <li>Email server SMTP → port 25</li>
  </ul>

  <h2>12. TCP Options</h2>
  <ul>
    <li>Maximum Segment Size (MSS)</li>
    <li>Window Scaling</li>
    <li>Timestamps (RTT measurement)</li>
    <li>Selective Acknowledgment (SACK)</li>
  </ul>

  <h2>13. TCP vs UDP</h2>
  <table>
    <tr><th>Feature</th><th>TCP</th><th>UDP</th></tr>
    <tr><td>Connection</td><td>Yes</td><td>No</td></tr>
    <tr><td>Reliability</td><td>Yes</td><td>No</td></tr>
    <tr><td>Ordering</td><td>Yes</td><td>No</td></tr>
    <tr><td>Flow Control</td><td>Yes</td><td>No</td></tr>
    <tr><td>Congestion Control</td><td>Yes</td><td>No</td></tr>
    <tr><td>Speed</td><td>Slower</td><td>Faster</td></tr>
    <tr><td>Header Size</td><td>20-60 bytes</td><td>8 bytes</td></tr>
  </table>

  <h2>14. Real-World Applications of TCP</h2>
  <ul>
    <li>Web Browsing: HTTP/HTTPS</li>
    <li>Email: SMTP, IMAP, POP3</li>
    <li>File Transfer: FTP, SFTP</li>
    <li>Remote Login: Telnet, SSH</li>
    <li>Databases: MySQL, PostgreSQL client-server communication</li>
  </ul>

  <h2>15. Summary</h2>
  <p>TCP provides reliable, ordered, error-checked, full-duplex communication between applications. Key mechanisms include:</p>
  <ul>
    <li>3-way handshake (connection setup)</li>
    <li>4-way termination handshake</li>
    <li>Flow control (sliding window)</li>
    <li>Congestion control</li>
    <li>Sequence numbers, ACKs, checksum, retransmission</li>
    <li>Multiplexing using ports</li>
  </ul>
  <h1>User Datagram Protocol (UDP) – Full Depth</h1>

  <h2>1. Introduction</h2>
  <ul>
    <li>Full Name: <strong>User Datagram Protocol</strong></li>
    <li>Layer: <strong>Transport Layer (Layer 4 in OSI)</strong></li>
    <li>Type: Connectionless, unreliable protocol</li>
    <li>Purpose: Fast, lightweight, low-overhead communication without guaranteeing delivery or order.</li>
    <li>Key Idea: UDP is “send and forget”—no connection, no delivery check.</li>
  </ul>

  <h2>2. Key Features of UDP</h2>
  <ul>
    <li>Connectionless: No handshake before sending data.</li>
    <li>Unreliable / Best-Effort Delivery: No ACK, retransmission, or sequencing.</li>
    <li>No Flow Control: Sender can send at any rate; receiver may drop packets.</li>
    <li>Low Overhead: Small 8-byte header → minimal processing.</li>
    <li>Supports Multiplexing: Uses port numbers to direct datagrams.</li>
    <li>Suitable for Real-Time Applications: Audio/video streaming, gaming, VoIP.</li>
  </ul>

  <h2>3. UDP Datagram Structure</h2>
  <p>A UDP datagram consists of header + data (header = 8 bytes)</p>
  <table>
    <tr><th>Field</th><th>Size</th><th>Purpose</th></tr>
    <tr><td>Source Port</td><td>16 bits</td><td>Port of sending application (optional)</td></tr>
    <tr><td>Destination Port</td><td>16 bits</td><td>Port of receiving application</td></tr>
    <tr><td>Length</td><td>16 bits</td><td>Length of header + data</td></tr>
    <tr><td>Checksum</td><td>16 bits</td><td>Error detection for header + data</td></tr>
    <tr><td>Data</td><td>Variable</td><td>Actual application data</td></tr>
  </table>

  <h2>4. How UDP Works</h2>
  <ol>
    <li>Application sends data to UDP layer.</li>
    <li>UDP adds source/destination port, length, checksum.</li>
    <li>UDP sends datagram to IP layer.</li>
    <li>Receiver UDP delivers data to application via port number.</li>
    <li>No guarantee of delivery—packets may be lost, duplicated, or arrive out of order.</li>
  </ol>
  <p><strong>Flow:</strong> Application → UDP → IP → Network → IP → UDP → Application</p>

  <h2>5. Advantages of UDP</h2>
  <ul>
    <li>Fast: No connection setup or ACK.</li>
    <li>Low Overhead: Small header, minimal processing.</li>
    <li>Supports Broadcast & Multicast: Efficient one-to-many communication.</li>
    <li>Real-Time Applications: Ideal for streaming, VoIP, gaming.</li>
    <li>Simple Implementation: Less complex than TCP.</li>
  </ul>

  <h2>6. Disadvantages of UDP</h2>
  <ul>
    <li>Unreliable: No guarantees for delivery or order.</li>
    <li>No Congestion Control: Can overload networks.</li>
    <li>Error Recovery Handled by Application: Lost/corrupted packets must be managed by app.</li>
  </ul>

  <h2>7. UDP vs TCP</h2>
  <table>
    <tr><th>Feature</th><th>TCP</th><th>UDP</th></tr>
    <tr><td>Connection</td><td>Connection-oriented</td><td>Connectionless</td></tr>
    <tr><td>Reliability</td><td>Reliable, retransmits lost segments</td><td>Unreliable, no retransmission</td></tr>
    <tr><td>Flow Control</td><td>Yes (sliding window)</td><td>No</td></tr>
    <tr><td>Ordering</td><td>Guaranteed</td><td>No guarantee</td></tr>
    <tr><td>Header Size</td><td>20-60 bytes</td><td>8 bytes</td></tr>
    <tr><td>Speed</td><td>Slower</td><td>Fast</td></tr>
    <tr><td>Use Case</td><td>Web, Email, File Transfer</td><td>Streaming, Gaming, VoIP, DNS</td></tr>
  </table>

  <h2>8. Common UDP Applications / Protocols</h2>
  <ul>
    <li>DNS: Port 53, fast query resolution</li>
    <li>DHCP: Ports 67/68, IP assignment</li>
    <li>VoIP / Video Calls: Skype, Google Meet</li>
    <li>Streaming: YouTube live, IPTV</li>
    <li>Online Gaming: Real-time multiplayer games</li>
    <li>SNMP: Port 161, network monitoring</li>
  </ul>

  <h2>9. UDP Packet Example</h2>
  <pre><code>Client sends: "Hello, Server" → UDP adds ports and checksum → sends as datagram
Server receives: UDP reads destination port → passes data to application → no ACK sent back</code></pre>

  <h2>10. When to Use UDP</h2>
  <ul>
    <li>Speed is critical and occasional packet loss is acceptable.</li>
    <li>Real-time applications where retransmission would cause delays.</li>
    <li>Broadcast or multicast scenarios.</li>
    <li>Simple request-response applications (like DNS).</li>
  </ul>

  <h2>Summary</h2>
  <ul>
    <li>Connectionless → no handshake</li>
    <li>Unreliable → no guarantees for delivery, ordering, or duplication</li>
    <li>Low overhead → small header (8 bytes)</li>
    <li>Fast and lightweight → suitable for real-time apps</li>
  </ul>

  <h1>Multiplexing & Demultiplexing – Transport Layer</h1>

  <h2>1. What is Multiplexing?</h2>
  <ul>
    <li><strong>Definition:</strong> Combining data from multiple applications (processes) into a single stream for transmission.</li>
    <li><strong>Purpose:</strong> Allows multiple applications to share the same transport and network layer resources.</li>
    <li><strong>Example:</strong> Browser (HTTP) and Email client (SMTP) sending data simultaneously from the same computer.</li>
    <li><strong>How it Works:</strong> Transport Layer adds port numbers; combination of source IP, source port, destination IP, destination port uniquely identifies each session.</li>
  </ul>

  <h2>2. What is Demultiplexing?</h2>
  <ul>
    <li><strong>Definition:</strong> Delivering incoming segments/datagrams to the correct application on the receiving host.</li>
    <li><strong>Purpose:</strong> Ensures data sent from multiple sources reaches the correct application.</li>
    <li><strong>Example:</strong>
      <ul>
        <li>TCP segments on port 80 → delivered to web server</li>
        <li>TCP segments on port 25 → delivered to mail server</li>
      </ul>
    </li>
    <li><strong>How it Works:</strong> Uses destination port in transport header + checks IP address to route to correct application.</li>
  </ul>

  <h2>3. Transport Layer Identifiers</h2>
  <table>
    <tr><th>Term</th><th>Meaning</th></tr>
    <tr><td>Port Number</td><td>Identifies a specific application/process on a host</td></tr>
    <tr><td>Well-Known Ports</td><td>Standard services: HTTP → 80, HTTPS → 443, SMTP → 25</td></tr>
    <tr><td>Dynamic/Private Ports</td><td>49152–65535, used dynamically by client applications</td></tr>
  </table>

  <h2>4. TCP/UDP Demultiplexing</h2>
  <h3>TCP (Connection-Oriented)</h3>
  <ul>
    <li>Uses 4-tuple to identify a connection: Source IP, Source Port, Destination IP, Destination Port</li>
    <li>Example: Client IP 192.168.1.5, Port 50000 → Server IP 10.0.0.1, Port 80</li>
    <li>Allows multiple clients to connect to same server port without confusion.</li>
  </ul>

  <h3>UDP (Connectionless)</h3>
  <ul>
    <li>Uses 2-tuple or 4-tuple depending on implementation: Destination IP + Destination Port (sometimes source IP + source port)</li>
    <li>Example: DNS query from client port 54321 → server port 53 → response sent back to client IP + port 54321</li>
  </ul>

  <h2>5. Example Scenario</h2>
  <pre><code>Multiplexing:
Computer A runs two applications:
- Web browser → HTTP request
- Email client → SMTP request

Transport Layer attaches port numbers:
- HTTP: source port 50001 → dest port 80
- SMTP: source port 50002 → dest port 25

Demultiplexing on Server:
- Segment to port 80 → web server process
- Segment to port 25 → mail server process
</code></pre>

  <h2>6. Why It’s Important</h2>
  <ul>
    <li>Without multiplexing/demultiplexing, only one application could send/receive data at a time.</li>
    <li>Transport layer could not differentiate between multiple sessions.</li>
    <li>Ensures simultaneous communication of multiple applications efficiently.</li>
  </ul>

  <h2>Summary</h2>
  <table>
    <tr><th>Concept</th><th>Definition</th><th>Key Mechanism</th></tr>
    <tr><td>Multiplexing</td><td>Combine data from multiple applications into one transport stream</td><td>Source port numbers</td></tr>
    <tr><td>Demultiplexing</td><td>Deliver received segments to correct application</td><td>Destination port numbers</td></tr>
  </table>
  <h1>Error Detection & Reliability – Transport Layer (TCP)</h1>

  <h2>1. Why Error Detection & Reliability is Needed</h2>
  <ul>
    <li>Networks are unreliable: packets may be lost, corrupted, duplicated, or arrive out of order.</li>
    <li>Transport layer (TCP) ensures end-to-end reliable delivery between applications.</li>
  </ul>

  <h2>2. Checksum</h2>
  <ul>
    <li><strong>Purpose:</strong> Detect errors in transmitted segments.</li>
    <li><strong>How it Works:</strong>
      <ol>
        <li>Sender computes checksum based on header + data.</li>
        <li>Receiver recomputes checksum and compares with received checksum.</li>
        <li>If mismatch → segment discarded, may trigger retransmission.</li>
      </ol>
    </li>
    <li><strong>Example:</strong>
      <pre><code>Data: 10101010
Checksum: 11001100
Receiver computes checksum → matches? → Yes → OK / No → discard
</code></pre>
    </li>
  </ul>

  <h2>3. Acknowledgment (ACK)</h2>
  <ul>
    <li><strong>Purpose:</strong> Confirms receipt of data.</li>
    <li><strong>How it Works:</strong> Receiver sends ACK after receiving data correctly; TCP uses cumulative acknowledgment.</li>
    <li><strong>Example:</strong> Sender sends bytes 1–100 → Receiver ACKs 101</li>
  </ul>

  <h2>4. Retransmission</h2>
  <ul>
    <li><strong>Purpose:</strong> Resend lost or corrupted segments.</li>
    <li><strong>Trigger:</strong> No ACK within timeout, or duplicate ACKs indicate missing segment.</li>
    <li><strong>Mechanisms:</strong> Timeout-based retransmission, Fast retransmit (after 3 duplicate ACKs).</li>
    <li><strong>Example:</strong>
      <pre><code>Sender sends segment #5
ACK not received → timeout → resend segment #5
</code></pre>
    </li>
  </ul>

  <h2>5. Sequence Numbers</h2>
  <ul>
    <li><strong>Purpose:</strong> Ensure data arrives in order.</li>
    <li><strong>How it Works:</strong> Each byte assigned a sequence number; receiver uses them to reassemble and detect duplicates/missing segments.</li>
    <li><strong>Example:</strong>
      <pre><code>Sender sends 3 segments:
Segment1: bytes 1–100
Segment2: bytes 101–200
Segment3: bytes 201–300

Receiver may receive: Segment1, Segment3, Segment2
TCP reorders using sequence numbers → 1–300 correctly
</code></pre>
    </li>
  </ul>

  <h2>6. Putting It All Together</h2>
  <pre><code>Sender attaches sequence numbers + checksum
Receiver checks checksum → if valid, sends ACK
Sender waits for ACK → if timeout → retransmit segment
Receiver reassembles using sequence numbers
</code></pre>
  <pre><code>Example Workflow:
Sender: Sends segment #1 (bytes 1–100, checksum)
Network: Segment lost
Sender: Timeout → retransmit #1
Receiver: Receives #1 → checksum OK → sends ACK 101
Sender: ACK received → send next segment
</code></pre>

  <h2>7. Visual Summary</h2>
  <table>
    <tr>
      <th>Mechanism</th>
      <th>Purpose</th>
      <th>Example</th>
    </tr>
    <tr>
      <td>Checksum</td>
      <td>Detect errors</td>
      <td>Receiver discards corrupted segment</td>
    </tr>
    <tr>
      <td>ACK</td>
      <td>Confirm receipt</td>
      <td>Receiver sends ACK 101 for bytes 1–100</td>
    </tr>
    <tr>
      <td>Retransmission</td>
      <td>Resend lost/corrupted data</td>
      <td>Timeout triggers resend of segment</td>
    </tr>
    <tr>
      <td>Sequence Numbers</td>
      <td>Maintain order</td>
      <td>Reassemble segments 1–300 correctly</td>
    </tr>
  </table>
  <h1>TCP Connection Handshake</h1>

  <h2>1. TCP Connection Establishment – 3-Way Handshake</h2>
  <p>TCP is connection-oriented, meaning a reliable channel must be established before data transfer. The 3-way handshake ensures both client and server are synchronized.</p>

  <h3>Steps</h3>
  <ol>
    <li><strong>SYN (Synchronize) – Client → Server:</strong>
      <ul>
        <li>Client wants to start a connection.</li>
        <li>Sends a SYN packet with initial sequence number (ISN), say x.</li>
        <li>SYN indicates client wants to synchronize sequence numbers.</li>
      </ul>
    </li>
    <li><strong>SYN-ACK (Synchronize-Acknowledge) – Server → Client:</strong>
      <ul>
        <li>Server receives SYN, reserves resources, and responds.</li>
        <li>Sends SYN to synchronize its sequence number y and ACK = x+1 to acknowledge client’s SYN.</li>
      </ul>
    </li>
    <li><strong>ACK (Acknowledge) – Client → Server:</strong>
      <ul>
        <li>Client acknowledges server’s SYN by sending ACK = y+1.</li>
        <li>Connection established, data transfer can start.</li>
      </ul>
    </li>
  </ol>

  <h3>Diagram</h3>
  <pre><code>Client                        Server
  | SYN (Seq=x)               ->|
  |                            <-| SYN-ACK (Seq=y, Ack=x+1)
  | ACK (Ack=y+1)             ->|
Connection Established
</code></pre>

  <h3>Key Points</h3>
  <ul>
    <li>Both sides know each other’s initial sequence numbers.</li>
    <li>Full-duplex communication is ready.</li>
  </ul>

  <h2>2. TCP Connection Termination – 4-Way Handshake</h2>
  <p>TCP uses a 4-step process to terminate a connection cleanly because each side may finish sending at different times.</p>

  <h3>Steps</h3>
  <ol>
    <li><strong>FIN – Initiator → Receiver:</strong> Side wanting to close sends FIN.</li>
    <li><strong>ACK – Receiver → Initiator:</strong> Receiver acknowledges FIN.</li>
    <li><strong>FIN – Receiver → Initiator:</strong> Receiver sends its own FIN when finished sending data.</li>
    <li><strong>ACK – Initiator → Receiver:</strong> Initiator acknowledges receiver’s FIN.</li>
  </ol>

  <h3>Diagram</h3>
  <pre><code>Client                        Server
  | FIN                       ->|
  |                            <-| ACK
  |                            <-| FIN
  | ACK                       ->|
Connection Closed
</code></pre>

  <h3>Key Points</h3>
  <ul>
    <li>Both sides can finish sending independently.</li>
    <li>TCP enters TIME-WAIT state for 2*MSL to ensure last ACK is received.</li>
  </ul>

  <h2>3. Why 3-Way Handshake?</h2>
  <ul>
    <li>Two-way handshake is insufficient; server would not know if client’s SYN arrived.</li>
    <li>3-way handshake ensures both sides are ready and synchronized.</li>
  </ul>

  <h2>4. Important Notes</h2>
  <ul>
    <li><strong>Sequence Numbers:</strong> Ensure reliable and ordered delivery.</li>
    <li><strong>Full Duplex:</strong> After handshake, data flows both ways simultaneously.</li>
    <li><strong>Timeouts & Retransmissions:</strong> Lost segments are retransmitted.</li>
    <li><strong>State Tracking:</strong> TCP maintains connection state in a table for each active connection.</li>
  </ul>
  <h1>TCP Sliding Window</h1>

  <h2>1. What is Sliding Window?</h2>
  <p><strong>Definition:</strong> Sliding Window is a flow control mechanism in TCP that regulates the amount of data the sender can transmit before needing an acknowledgment (ACK) from the receiver.</p>
  <p><strong>Purpose:</strong></p>
  <ul>
    <li>Prevents the sender from overwhelming the receiver.</li>
    <li>Ensures efficient and continuous data transfer.</li>
  </ul>
  <p><strong>Key Concept:</strong> Both sender and receiver maintain a window of bytes that can be sent or received.</p>

  <h2>2. How Sliding Window Works</h2>
  <ul>
    <li>Window size is advertised by the receiver.</li>
    <li>Sender can send all bytes within the window without waiting for ACKs.</li>
    <li>As ACKs are received, the window “slides forward,” allowing sender to send more data.</li>
  </ul>
  <p><strong>Terminology:</strong></p>
  <ul>
    <li><strong>Window Size (rwnd):</strong> Bytes receiver is willing to accept.</li>
    <li><strong>Sequence Numbers:</strong> Each byte has a unique number.</li>
    <li><strong>Acknowledgment (ACK):</strong> Receiver acknowledges next expected byte.</li>
  </ul>

  <h2>3. Example</h2>
  <p><strong>Initial Setup:</strong></p>
  <ul>
    <li>Window size = 5 bytes</li>
    <li>Sender data: 1 2 3 4 5 6 7 8 9 10</li>
    <li>Receiver can buffer 5 bytes</li>
  </ul>

  <p><strong>Step 1:</strong> Sender sends first 5 bytes</p>
  <pre><code>Sender Window: 1 2 3 4 5
Receiver receives 1-5, sends ACK=6</code></pre>

  <p><strong>Step 2:</strong> Window slides</p>
  <pre><code>Receiver ACK=6 → sender can send bytes 6 7 8 9 10
Sender Window: 6 7 8 9 10</code></pre>

  <p><strong>Step 3:</strong> Continuous sliding</p>
  <p>As ACKs arrive, window slides forward until all data is delivered. Only unacknowledged data stays in the window.</p>

  <h2>4. Flow Control Using Sliding Window</h2>
  <ul>
    <li><strong>Receiver Advertises rwnd:</strong> Number of bytes it can receive.</li>
    <li><strong>Sender Restricts Transmission:</strong> Never sends more than the window.</li>
    <li><strong>Dynamic Adjustment:</strong> Window size can increase or decrease based on network and receiver capacity.</li>
  </ul>

  <h2>5. Advantages of Sliding Window</h2>
  <ul>
    <li>Efficient bandwidth usage – multiple segments in flight.</li>
    <li>Reduces waiting time for ACKs.</li>
    <li>Supports full-duplex communication.</li>
    <li>Enables error recovery – lost segments retransmitted without stopping flow.</li>
  </ul>

  <h2>6. Types of Sliding Window</h2>
  <table>
    <tr>
      <th>Type</th>
      <th>Description</th>
    </tr>
    <tr>
      <td>Go-Back-N ARQ</td>
      <td>All subsequent segments retransmitted if a segment is lost; simpler but less efficient.</td>
    </tr>
    <tr>
      <td>Selective Repeat ARQ</td>
      <td>Only lost segments retransmitted; more efficient; used in TCP.</td>
    </tr>
  </table>

  <h2>7. Visual Representation</h2>
  <pre><code>Sender Side (Window size = 4)
Seq: 1  2  3  4  5  6  7  8
      [1  2  3  4]  <- Sent
      ACK=3 received
Seq: 3  4  5  6  7  8
      [5  6  7  8]  <- New window after sliding

Window “slides” forward as ACKs are received.
Unacknowledged data remains in window.</code></pre>

  <h2>8. Sliding Window in TCP</h2>
  <ul>
    <li>TCP uses dynamic window size based on receiver buffer (rwnd).</li>
    <li>TCP also uses congestion window (cwnd) to avoid network congestion.</li>
    <li><strong>Actual window:</strong> min(rwnd, cwnd) → ensures both flow control and congestion control.</li>
  </ul>

  <h2>9. Summary</h2>
  <ul>
    <li>Sliding Window is a flow control and reliable delivery mechanism.</li>
    <li>Key concepts: window size, sequence numbers, ACKs, sliding forward.</li>
    <li>Ensures continuous and reliable transmission without overwhelming receiver.</li>
    <li>TCP implements Selective Repeat ARQ using sliding window.</li>
  </ul>

  <h1>Network Layer</h1>

  <h2>1. What is the Network Layer?</h2>
  <p><strong>Layer:</strong> 3rd layer of OSI, also exists in TCP/IP model.</p>
  <p><strong>Purpose:</strong> Delivers packets from source host to destination host, possibly across multiple networks (end-to-end delivery).</p>
  <p><strong>Key Function:</strong> Routing and addressing.</p>
  <p><strong>Example:</strong> Sending an email from your computer in India to a server in the USA.</p>

  <h2>2. Main Functions of Network Layer</h2>
  <ul>
    <li><strong>Logical Addressing:</strong> Assigns IP addresses to devices to uniquely identify hosts (IPv4: 32 bits, IPv6: 128 bits).</li>
    <li><strong>Routing:</strong> Determines the best path for a packet to reach the destination (OSPF, RIP, BGP).</li>
    <li><strong>Packet Forwarding:</strong> Moves packets through routers using routing tables.</li>
    <li><strong>Fragmentation & Reassembly:</strong> Breaks large packets into smaller fragments to fit MTU, reassembles at destination.</li>
    <li><strong>Error Handling & Diagnostics:</strong> Detects errors in header (ICMP used for ping/traceroute).</li>
  </ul>

  <h2>3. Key Concepts</h2>
  
  <h3>3.1 Logical Addressing (IP Address)</h3>
  <p>Unique identifier for a host on a network.</p>
  <ul>
    <li>IPv4: 32 bits, e.g., 192.168.1.10</li>
    <li>IPv6: 128 bits, e.g., 2001:0db8:85a3::8a2e:0370:7334</li>
    <li>Subnetting: Divides IP into network and host portions.</li>
  </ul>

  <h3>3.2 Packet</h3>
  <p>Data unit at network layer containing:</p>
  <ul>
    <li><strong>Header:</strong> Source/destination IP, TTL, protocol, etc.</li>
    <li><strong>Payload:</strong> Data from transport layer.</li>
  </ul>

  <h3>3.3 Routing</h3>
  <ul>
    <li><strong>Static Routing:</strong> Manually configured routes.</li>
    <li><strong>Dynamic Routing:</strong> Protocols update routes automatically (RIP, OSPF, BGP).</li>
    <li><strong>Routing Tables:</strong> Stores next hop for each destination network.</li>
  </ul>

  <h3>3.4 Fragmentation & Reassembly</h3>
  <p>Networks have different MTUs. Large packets are split and reassembled at destination.</p>
  <p>IPv4 allows fragmentation; IPv6 does not allow intermediate fragmentation.</p>

  <h3>3.5 Time to Live (TTL)</h3>
  <p>Field in IP header preventing packets from looping indefinitely. Decremented at each hop; discarded when TTL = 0.</p>

  <h3>3.6 Protocols in Network Layer</h3>
  <table>
    <tr>
      <th>Protocol</th>
      <th>Purpose</th>
      <th>Notes</th>
    </tr>
    <tr>
      <td>IP (IPv4/IPv6)</td>
      <td>Addressing and packet delivery</td>
      <td>Core protocol</td>
    </tr>
    <tr>
      <td>ICMP</td>
      <td>Diagnostics, error reporting</td>
      <td>ping, traceroute</td>
    </tr>
    <tr>
      <td>ARP</td>
      <td>Map IP → MAC address</td>
      <td>Works in local network</td>
    </tr>
    <tr>
      <td>RARP</td>
      <td>Map MAC → IP address</td>
      <td>Rarely used now</td>
    </tr>
    <tr>
      <td>IGMP</td>
      <td>Multicast group management</td>
      <td>Video streaming, IPTV</td>
    </tr>
    <tr>
      <td>IPsec</td>
      <td>Security & encryption at IP layer</td>
      <td>VPNs</td>
    </tr>
  </table>

  <h3>3.7 ICMP (Internet Control Message Protocol)</h3>
  <p>Used for error reporting and network diagnostics:</p>
  <ul>
    <li><strong>Ping:</strong> Checks if host is reachable.</li>
    <li><strong>Traceroute:</strong> Shows path packets take to destination.</li>
  </ul>
  <p>ICMP messages are encapsulated in IP packets.</p>

  <h2>4. Packet Structure (IP Header)</h2>
  <table>
    <tr>
      <th>Field</th>
      <th>Size</th>
      <th>Purpose</th>
    </tr>
    <tr><td>Version</td><td>4 bits</td><td>IPv4 (4) or IPv6 (6)</td></tr>
    <tr><td>IHL</td><td>4 bits</td><td>Header length</td></tr>
    <tr><td>Type of Service</td><td>8 bits</td><td>Priority/DSCP</td></tr>
    <tr><td>Total Length</td><td>16 bits</td><td>Packet size</td></tr>
    <tr><td>Identification</td><td>16 bits</td><td>Fragment ID</td></tr>
    <tr><td>Flags</td><td>3 bits</td><td>Fragmentation control</td></tr>
    <tr><td>Fragment Offset</td><td>13 bits</td><td>Position of fragment</td></tr>
    <tr><td>TTL</td><td>8 bits</td><td>Time to Live</td></tr>
    <tr><td>Protocol</td><td>8 bits</td><td>Encapsulated protocol (TCP=6, UDP=17)</td></tr>
    <tr><td>Header Checksum</td><td>16 bits</td><td>Error detection</td></tr>
    <tr><td>Source IP</td><td>32 bits</td><td>Sender address</td></tr>
    <tr><td>Destination IP</td><td>32 bits</td><td>Receiver address</td></tr>
    <tr><td>Options</td><td>Variable</td><td>Optional features</td></tr>
  </table>

  <h2>5. Routing Concepts</h2>
  <ul>
    <li><strong>Static Routing:</strong> Manually configured paths.</li>
    <li><strong>Dynamic Routing Protocols:</strong>
      <ul>
        <li>RIP: Distance-vector, hop count metric</li>
        <li>OSPF: Link-state, cost metric</li>
        <li>BGP: Path-vector, used between ISPs</li>
      </ul>
    </li>
  </ul>

  <h2>6. Address Resolution</h2>
  <ul>
    <li>ARP (Address Resolution Protocol): Converts IP → MAC for local delivery.</li>
    <li>RARP (Reverse ARP): Converts MAC → IP (rarely used).</li>
  </ul>

  <h2>7. Summary of Network Layer Functions</h2>
  <ul>
    <li>Logical Addressing (IP) → Unique identification of hosts.</li>
    <li>Routing → Determines best path across networks.</li>
    <li>Forwarding → Sends packets via routers toward destination.</li>
    <li>Fragmentation & Reassembly → Adapts packets to MTU.</li>
    <li>Error Handling → ICMP for network errors.</li>
    <li>Security → IPsec for encryption/authentication.</li>
  </ul>

  <h1>Logical Addressing</h1>

  <h2>1. What is Logical Addressing?</h2>
  <p>Definition: Logical addressing assigns a unique identifier to each host on a network, enabling end-to-end communication across multiple networks.</p>
  <p><strong>Purpose:</strong></p>
  <ul>
    <li>Identifies a device uniquely in an internetwork.</li>
    <li>Helps routers forward packets from source to destination.</li>
    <li>Supports hierarchical addressing to simplify routing.</li>
  </ul>
  <p><strong>Key Idea:</strong> Unlike MAC addresses (physical addresses) which are fixed, logical addresses (IP addresses) can change and are hierarchical.</p>

  <h2>2. Types of Addressing</h2>
  <ul>
    <li><strong>Physical Addressing (MAC):</strong> Layer 2, unique per NIC, fixed.</li>
    <li><strong>Logical Addressing (IP):</strong> Layer 3, hierarchical, assigned by admin or DHCP.</li>
  </ul>

  <h2>3. IP Address</h2>
  <ul>
    <li><strong>Definition:</strong> Numeric identifier assigned to each host.</li>
    <li><strong>IPv4:</strong> 32-bit, e.g., 192.168.1.1, decimal notation, 4 octets.</li>
    <li><strong>IPv6:</strong> 128-bit, e.g., 2001:0db8:85a3::8a2e:0370:7334, hexadecimal, supports many devices.</li>
  </ul>

  <h2>4. Structure of IP Address</h2>
  <h3>IPv4</h3>
  <ul>
    <li>Network Portion: Identifies network.</li>
    <li>Host Portion: Identifies host.</li>
    <li>Example: 192.168.1.10/24 → Network: 192.168.1.0, Host: 10, Subnet Mask: 255.255.255.0</li>
  </ul>
  <h3>IPv6</h3>
  <ul>
    <li>Network prefix + Interface Identifier</li>
    <li>Example: 2001:db8::1/64 → Network: 64 bits, Host ID: 64 bits</li>
  </ul>

  <h2>5. Subnetting</h2>
  <p>Purpose: Divide a large network into smaller subnetworks.</p>
  <ul>
    <li>Efficient IP usage</li>
    <li>Better security</li>
    <li>Easier management</li>
  </ul>
  <p>Example: 192.168.1.0/24 → 256 IPs → Divide into 4 subnets → /26 → 64 IPs each</p>

  <h2>6. IP Address Classes (IPv4)</h2>
  <table>
    <tr>
      <th>Class</th>
      <th>Range</th>
      <th>Use</th>
    </tr>
    <tr><td>A</td><td>1.0.0.0 – 126.255.255.255</td><td>Large networks</td></tr>
    <tr><td>B</td><td>128.0.0.0 – 191.255.255.255</td><td>Medium networks</td></tr>
    <tr><td>C</td><td>192.0.0.0 – 223.255.255.255</td><td>Small networks</td></tr>
    <tr><td>D</td><td>224.0.0.0 – 239.255.255.255</td><td>Multicast</td></tr>
    <tr><td>E</td><td>240.0.0.0 – 255.255.255.255</td><td>Reserved</td></tr>
  </table>

  <h2>7. Address Types</h2>
  <ul>
    <li>Unicast: One-to-one delivery</li>
    <li>Broadcast (IPv4 only): One-to-all hosts</li>
    <li>Multicast: One-to-many (selected hosts)</li>
    <li>Anycast (IPv6): One-to-nearest host</li>
  </ul>

  <h2>8. How Logical Addressing Works</h2>
  <ul>
    <li>Sender knows the destination IP.</li>
    <li>Network layer uses routing tables to find next hop.</li>
    <li>Packet forwarded through routers to destination network.</li>
    <li>ARP maps destination IP → MAC for final LAN delivery.</li>
  </ul>
  <p><strong>Flow:</strong> Application → Transport → Network → Data Link → Physical</p>
  <p>IP address identifies destination host; MAC used for local delivery.</p>

  <h2>9. Difference Between Logical and Physical Address</h2>
  <table>
    <tr>
      <th>Feature</th>
      <th>Logical Address</th>
      <th>Physical Address</th>
    </tr>
    <tr><td>Layer</td><td>Network (L3)</td><td>Data Link (L2)</td></tr>
    <tr><td>Type</td><td>Hierarchical</td><td>Flat/Unique</td></tr>
    <tr><td>Example</td><td>IP (192.168.1.10)</td><td>MAC (00:1A:2B:3C:4D:5E)</td></tr>
    <tr><td>Assignment</td><td>Configured manually/DHCP</td><td>Assigned by manufacturer</td></tr>
    <tr><td>Scope</td><td>Global (across networks)</td><td>Local (LAN only)</td></tr>
  </table>

  <h2>10. Key Points</h2>
  <ul>
    <li>Logical addressing enables end-to-end communication.</li>
    <li>Supports hierarchical routing to scale large networks.</li>
    <li>IP addresses can change; MAC addresses are permanent.</li>
    <li>Subnetting and address classes allow efficient IP management.</li>
  </ul>
  <h1>IPv4 (Internet Protocol Version 4)</h1>

  <h2>1. Overview</h2>
  <ul>
    <li><strong>Full Name:</strong> Internet Protocol Version 4</li>
    <li><strong>Layer:</strong> Network Layer (Layer 3, OSI)</li>
    <li><strong>Purpose:</strong> Provides logical addressing and packet delivery from source to destination across multiple networks.</li>
    <li><strong>Address Size:</strong> 32 bits → allows ~4.3 billion unique addresses</li>
  </ul>

  <h2>2. IPv4 Address Format</h2>
  <ul>
    <li><strong>Binary:</strong> <code>11000000 10101000 00000001 00001010</code></li>
    <li><strong>Decimal:</strong> <code>192.168.1.10</code></li>
  </ul>
  <h1>IPv4 Packet Structure</h1>

  <h2>Overview</h2>
  <ul>
    <li>An IPv4 packet consists of two parts:
      <ul>
        <li><strong>Header:</strong> Contains control and addressing information.</li>
        <li><strong>Data (Payload):</strong> Contains the segment from the transport layer (TCP/UDP).</li>
      </ul>
    </li>
    <li>Minimum header size: 20 bytes (without options)</li>
    <li>Maximum header size: 60 bytes (with options)</li>
  </ul>

  <h2>1. IPv4 Header Fields</h2>
  <table>
    <tr>
      <th>Field</th>
      <th>Size</th>
      <th>Description</th>
    </tr>
    <tr><td>Version</td><td>4 bits</td><td>IP version (IPv4 = 4)</td></tr>
    <tr><td>IHL (Internet Header Length)</td><td>4 bits</td><td>Header length in 32-bit words (min 5 → 20 bytes)</td></tr>
    <tr><td>Type of Service (ToS) / DSCP</td><td>8 bits</td><td>Priority and QoS info</td></tr>
    <tr><td>Total Length</td><td>16 bits</td><td>Total size of IP packet (header + data)</td></tr>
    <tr><td>Identification</td><td>16 bits</td><td>Unique ID for fragmentation/reassembly</td></tr>
    <tr><td>Flags</td><td>3 bits</td><td>Controls fragmentation: 0 = reserved, DF = Don't Fragment, MF = More Fragments</td></tr>
    <tr><td>Fragment Offset</td><td>13 bits</td><td>Position of fragment in original data</td></tr>
    <tr><td>Time to Live (TTL)</td><td>8 bits</td><td>Max hops packet can traverse</td></tr>
    <tr><td>Protocol</td><td>8 bits</td><td>Encapsulated protocol (TCP=6, UDP=17, ICMP=1)</td></tr>
    <tr><td>Header Checksum</td><td>16 bits</td><td>Error detection for header</td></tr>
    <tr><td>Source IP Address</td><td>32 bits</td><td>Sender's IP address</td></tr>
    <tr><td>Destination IP Address</td><td>32 bits</td><td>Receiver's IP address</td></tr>
    <tr><td>Options</td><td>Variable (0–40 bytes)</td><td>Optional features (security, timestamps, record route)</td></tr>
    <tr><td>Data (Payload)</td><td>Variable</td><td>Transport layer segment (TCP/UDP)</td></tr>
  </table>

  <h2>2. Key Field Explanations</h2>
  <ul>
    <li><strong>Version:</strong> Identifies IP version (4 for IPv4).</li>
    <li><strong>IHL:</strong> Header length in 32-bit words (min 5 → 20 bytes; max 15 → 60 bytes).</li>
    <li><strong>ToS / DSCP:</strong> Priority and QoS info.</li>
    <li><strong>Total Length:</strong> Packet size including header and data.</li>
    <li><strong>Identification:</strong> Unique for each packet; used in fragmentation.</li>
    <li><strong>Flags:</strong> Controls fragmentation (DF, MF).</li>
    <li><strong>Fragment Offset:</strong> Helps reassemble fragments in order.</li>
    <li><strong>TTL:</strong> Prevents packet loops; decremented at each hop.</li>
    <li><strong>Protocol:</strong> Specifies upper-layer protocol (TCP, UDP, ICMP).</li>
    <li><strong>Header Checksum:</strong> Ensures header integrity.</li>
    <li><strong>Source/Destination IP:</strong> Sender and receiver addresses.</li>
    <li><strong>Options:</strong> Optional features like record route, timestamps.</li>
    <li><strong>Data (Payload):</strong> Transport layer segment.</li>
  </ul>

  <h2>3. Fragmentation in IPv4</h2>
  <ul>
    <li>Packets larger than MTU are split into fragments.</li>
    <li>Each fragment keeps the same Identification, Fragment Offset, and MF flag (except last fragment).</li>
    <li>Fragments are reassembled at the destination.</li>
  </ul>

  <h2>4. Visual Representation of IPv4 Packet</h2>
  <pre>
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|Version| IHL |Type of Service|        Total Length             |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|       Identification          |Flags|   Fragment Offset      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Time to Live |   Protocol    |       Header Checksum       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                     Source IP Address                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                  Destination IP Address                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
| Options (if any) ...                                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                          Data (Payload)                     |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  </pre>

  <h2>5. Key Points</h2>
  <ul>
    <li>IPv4 header minimum 20 bytes, optional up to 60 bytes.</li>
    <li>Provides logical addressing, fragmentation, error detection, and routing support.</li>
    <li>Works with transport layer protocols (TCP/UDP) for end-to-end communication.</li>
    <li>Fragmentation allows IPv4 to traverse networks with different MTUs.</li>
  </ul>
 <h1>IPv4 Address Basics</h1>

  <h2>1. Overview</h2>
  <ul>
    <li><strong>Length:</strong> 32 bits → ~4.3 billion addresses.</li>
    <li><strong>Notation:</strong> Dotted decimal – 4 octets (8 bits each) separated by dots.
      <pre>Example: 192.168.1.10 → binary: 11000000.10101000.00000001.00001010</pre>
    </li>
    <li><strong>Purpose:</strong> Uniquely identifies a host in an internetwork.</li>
  </ul>

  <h2>2. Network and Host Portions</h2>
  <ul>
    <li>IPv4 address is divided into:
      <ul>
        <li><strong>Network Portion:</strong> Identifies the network.</li>
        <li><strong>Host Portion:</strong> Identifies the device within that network.</li>
      </ul>
    </li>
    <li>Example:
      <pre>IP: 192.168.1.10
Subnet mask: 255.255.255.0</pre>
    </li>
  </ul>

  <h3>Subnet Mask</h3>
  <ul>
    <li>Determines which bits belong to network and host.</li>
    <li>Example: 255.255.255.0 → binary: 11111111.11111111.11111111.00000000</li>
    <li>First 24 bits → network, Last 8 bits → host</li>
  </ul>

  <h3>Network and Broadcast Addresses</h3>
  <ul>
    <li><strong>Network Address:</strong> Set all host bits to 0 → identifies network.
      <pre>Example: 192.168.1.0</pre>
    </li>
    <li><strong>Broadcast Address:</strong> Set all host bits to 1 → send to all hosts.
      <pre>Example: 192.168.1.255</pre>
    </li>
  </ul>

  <h2>3. CIDR Notation</h2>
  <ul>
    <li>Stands for <strong>Classless Inter-Domain Routing</strong>.</li>
    <li>Represents network prefix: <code>IP_address / prefix_length</code></li>
    <li>Example: 192.168.1.10/24 → 24 bits network, 8 bits host</li>
    <li><strong>Number of hosts formula:</strong> 2^(host bits) - 2
      <ul>
        <li>Subtract 2 for network & broadcast addresses.</li>
      </ul>
    </li>
    <li>Example: /24 → 2^8 - 2 = 254 hosts per subnet</li>
  </ul>

  <h2>4. Examples</h2>
  <table>
    <tr>
      <th>IP</th>
      <th>Network</th>
      <th>Broadcast</th>
      <th>Host Range</th>
    </tr>
    <tr>
      <td>192.168.10.5 /24</td>
      <td>192.168.10.0</td>
      <td>192.168.10.255</td>
      <td>192.168.10.1 – 192.168.10.254</td>
    </tr>
    <tr>
      <td>10.0.5.7 /16</td>
      <td>10.0.0.0</td>
      <td>10.0.255.255</td>
      <td>10.0.0.1 – 10.0.255.254</td>
    </tr>
  </table>

  <h2>5. Key Points</h2>
  <ul>
    <li>IPv4 addresses are hierarchical → helps routing.</li>
    <li>Subnet mask divides network and host portions.</li>
    <li>CIDR allows flexible subnetting, not limited by class.</li>
    <li>Always reserve network and broadcast addresses; rest are usable hosts.</li>
  </ul>
   <h1>IPv4 Address Classes</h1>

  <h2>1. Class A</h2>
  <ul>
    <li><strong>Range:</strong> 1.0.0.0 – 126.255.255.255</li>
    <li><strong>Network Bits:</strong> 8</li>
    <li><strong>Host Bits:</strong> 24</li>
    <li><strong>Default Subnet Mask:</strong> 255.0.0.0</li>
    <li><strong>Purpose:</strong> Large networks (up to ~16 million hosts per network)</li>
    <li><strong>Example:</strong> 10.0.0.1</li>
    <li><strong>Notes:</strong> First bit always 0; supports 128 networks (0 and 127 reserved)</li>
  </ul>

  <h2>2. Class B</h2>
  <ul>
    <li><strong>Range:</strong> 128.0.0.0 – 191.255.255.255</li>
    <li><strong>Network Bits:</strong> 16</li>
    <li><strong>Host Bits:</strong> 16</li>
    <li><strong>Default Subnet Mask:</strong> 255.255.0.0</li>
    <li><strong>Purpose:</strong> Medium-sized networks (~65,000 hosts per network)</li>
    <li><strong>Example:</strong> 172.16.0.1</li>
    <li><strong>Notes:</strong> First two bits 10; supports 16,384 networks</li>
  </ul>

  <h2>3. Class C</h2>
  <ul>
    <li><strong>Range:</strong> 192.0.0.0 – 223.255.255.255</li>
    <li><strong>Network Bits:</strong> 24</li>
    <li><strong>Host Bits:</strong> 8</li>
    <li><strong>Default Subnet Mask:</strong> 255.255.255.0</li>
    <li><strong>Purpose:</strong> Small networks (up to 254 hosts per network)</li>
    <li><strong>Example:</strong> 192.168.1.1</li>
    <li><strong>Notes:</strong> First three bits 110; supports 2 million networks</li>
  </ul>

  <h2>4. Class D</h2>
  <ul>
    <li><strong>Range:</strong> 224.0.0.0 – 239.255.255.255</li>
    <li><strong>Purpose:</strong> Multicast addresses (one-to-many)</li>
    <li><strong>Example:</strong> 224.0.0.1</li>
    <li><strong>Notes:</strong> First four bits 1110; not used for standard host-to-host communication</li>
  </ul>

  <h2>5. Class E</h2>
  <ul>
    <li><strong>Range:</strong> 240.0.0.0 – 255.255.255.255</li>
    <li><strong>Purpose:</strong> Experimental / reserved</li>
    <li><strong>Example:</strong> Rarely used</li>
    <li><strong>Notes:</strong> First four bits 1111; reserved for research/future use</li>
  </ul>

  <h2>Visual Summary</h2>
  <table>
    <tr>
      <th>Class</th>
      <th>Range</th>
      <th>Network Bits</th>
      <th>Host Bits</th>
      <th>Subnet Mask</th>
      <th>Purpose</th>
    </tr>
    <tr>
      <td>A</td>
      <td>1.0.0.0 – 126.255.255.255</td>
      <td>8</td>
      <td>24</td>
      <td>255.0.0.0</td>
      <td>Large networks</td>
    </tr>
    <tr>
      <td>B</td>
      <td>128.0.0.0 – 191.255.255.255</td>
      <td>16</td>
      <td>16</td>
      <td>255.255.0.0</td>
      <td>Medium networks</td>
    </tr>
    <tr>
      <td>C</td>
      <td>192.0.0.0 – 223.255.255.255</td>
      <td>24</td>
      <td>8</td>
      <td>255.255.255.0</td>
      <td>Small networks</td>
    </tr>
    <tr>
      <td>D</td>
      <td>224.0.0.0 – 239.255.255.255</td>
      <td>-</td>
      <td>-</td>
      <td>-</td>
      <td>Multicast</td>
    </tr>
    <tr>
      <td>E</td>
      <td>240.0.0.0 – 255.255.255.255</td>
      <td>-</td>
      <td>-</td>
      <td>-</td>
      <td>Experimental</td>
    </tr>
  </table>
  <h1>Special IPv4 Addresses</h1>

  <h2>1. Private Addresses (RFC 1918)</h2>
  <ul>
    <li><strong>Definition:</strong> Reserved for private networks; not routable on public Internet.</li>
    <li><strong>Purpose:</strong> Enable LAN communication, conserve public IPv4 addresses.</li>
    <li><strong>Ranges by Class:</strong>
      <ul>
        <li>Class A: 10.0.0.0 – 10.255.255.255 → Large private networks</li>
        <li>Class B: 172.16.0.0 – 172.31.255.255 → Medium private networks</li>
        <li>Class C: 192.168.0.0 – 192.168.255.255 → Small private networks, common in home routers</li>
      </ul>
    </li>
    <li><strong>Example:</strong> Home router assigns 192.168.1.x to LAN devices; NAT allows Internet access.</li>
  </ul>

  <h2>2. Loopback Address</h2>
  <ul>
    <li><strong>Definition:</strong> Refers to the local host.</li>
    <li><strong>Range:</strong> 127.0.0.0 – 127.255.255.255 (commonly 127.0.0.1)</li>
    <li><strong>Purpose:</strong> Test host's network stack for diagnostics.</li>
    <li><strong>Example:</strong>
      <pre>ping 127.0.0.1</pre>
    </li>
  </ul>

  <h2>3. Broadcast Address</h2>
  <ul>
    <li><strong>Definition:</strong> Sends packet to all hosts in a subnet.</li>
    <li><strong>How it works:</strong> All host bits = 1</li>
    <li><strong>Example:</strong> Subnet 192.168.1.0/24 → Broadcast: 192.168.1.255</li>
    <li><strong>Purpose:</strong> Useful for announcements, ARP requests, DHCP requests.</li>
  </ul>

  <h2>4. Multicast Address</h2>
  <ul>
    <li><strong>Definition:</strong> Sends packets to a group of hosts (one-to-many).</li>
    <li><strong>Range (Class D):</strong> 224.0.0.0 – 239.255.255.255</li>
    <li><strong>Purpose:</strong> Efficiently deliver data to multiple subscribers (video conferencing, IPTV, streaming).</li>
    <li><strong>Example:</strong> Streaming live video to subscribed clients using 224.1.1.1</li>
  </ul>

  <h2>5. Summary Table</h2>
  <table>
    <tr>
      <th>Type</th>
      <th>Range</th>
      <th>Purpose</th>
      <th>Example</th>
    </tr>
    <tr>
      <td>Private</td>
      <td>10.0.0.0 – 10.255.255.255<br>172.16.0.0 – 172.31.255.255<br>192.168.0.0 – 192.168.255.255</td>
      <td>Internal networks</td>
      <td>192.168.1.10</td>
    </tr>
    <tr>
      <td>Loopback</td>
      <td>127.0.0.0 – 127.255.255.255</td>
      <td>Test local host</td>
      <td>127.0.0.1</td>
    </tr>
    <tr>
      <td>Broadcast</td>
      <td>Host bits = 1</td>
      <td>Send to all hosts in subnet</td>
      <td>192.168.1.255</td>
    </tr>
    <tr>
      <td>Multicast</td>
      <td>224.0.0.0 – 239.255.255.255</td>
      <td>Send to group of hosts</td>
      <td>224.1.1.1</td>
    </tr>
  </table>
  <body>

  <h1>IPv4 Subnetting – In-Depth</h1>

  <h2>1. Purpose of Subnetting</h2>
  <ul>
    <li>Divide a large network into smaller, manageable subnets.</li>
    <li>Benefits:
      <ul>
        <li>Efficient IP address utilization</li>
        <li>Improved network performance</li>
        <li>Easier management and security</li>
      </ul>
    </li>
  </ul>

  <h2>2. Subnet Mask</h2>
  <ul>
    <li>Definition: 32-bit number dividing IP into network and host parts.</li>
    <li>Example:
      <pre>
IP: 192.168.1.10
Subnet Mask: 255.255.255.0
Network: 192.168.1.0
Host: 0.0.0.10

Binary Representation:
IP:       11000000.10101000.00000001.00001010
Subnet:   11111111.11111111.11111111.00000000
      </pre>
    </li>
  </ul>

  <h2>3. CIDR Notation</h2>
  <ul>
    <li>Classless Inter-Domain Routing (CIDR) represents subnet mask as /n</li>
    <li>n = number of network bits</li>
    <li>Example: 192.168.1.0/26 → 26 network bits, 6 host bits</li>
  </ul>

  <h2>4. Number of Hosts per Subnet</h2>
  <ul>
    <li>Formula: <strong>2^(host bits) - 2</strong> (subtract network & broadcast)</li>
    <li>Example: /26 → host bits = 6 → 2^6 - 2 = 62 hosts per subnet</li>
  </ul>

  <h2>5. Number of Subnets</h2>
  <ul>
    <li>Formula: <strong>2^(borrowed bits)</strong></li>
    <li>Borrowed bits = bits taken from host portion to create more subnets.</li>
    <li>Example: 192.168.1.0/24 → subnet mask /26 → 2 bits borrowed → 2^2 = 4 subnets</li>
  </ul>

  <h2>6. Subnet Address Calculation</h2>
  <p>Example: 192.168.1.0/26 → 4 subnets</p>
  <table>
    <tr>
      <th>Subnet</th>
      <th>Network Address</th>
      <th>First Host</th>
      <th>Last Host</th>
      <th>Broadcast Address</th>
    </tr>
    <tr>
      <td>1</td>
      <td>192.168.1.0</td>
      <td>192.168.1.1</td>
      <td>192.168.1.62</td>
      <td>192.168.1.63</td>
    </tr>
    <tr>
      <td>2</td>
      <td>192.168.1.64</td>
      <td>192.168.1.65</td>
      <td>192.168.1.126</td>
      <td>192.168.1.127</td>
    </tr>
    <tr>
      <td>3</td>
      <td>192.168.1.128</td>
      <td>192.168.1.129</td>
      <td>192.168.1.190</td>
      <td>192.168.1.191</td>
    </tr>
    <tr>
      <td>4</td>
      <td>192.168.1.192</td>
      <td>192.168.1.193</td>
      <td>192.168.1.254</td>
      <td>192.168.1.255</td>
    </tr>
  </table>

  <h2>7. Shortcut Table for Common Subnets</h2>
  <table>
    <tr>
      <th>CIDR</th>
      <th>Subnet Mask</th>
      <th>#Hosts</th>
      <th>Increment</th>
    </tr>
    <tr><td>/24</td><td>255.255.255.0</td><td>254</td><td>256</td></tr>
    <tr><td>/25</td><td>255.255.255.128</td><td>126</td><td>128</td></tr>
    <tr><td>/26</td><td>255.255.255.192</td><td>62</td><td>64</td></tr>
    <tr><td>/27</td><td>255.255.255.224</td><td>30</td><td>32</td></tr>
    <tr><td>/28</td><td>255.255.255.240</td><td>14</td><td>16</td></tr>
    <tr><td>/29</td><td>255.255.255.248</td><td>6</td><td>8</td></tr>
    <tr><td>/30</td><td>255.255.255.252</td><td>2</td><td>4</td></tr>
  </table>

  <h2>✅ Summary</h2>
  <ul>
    <li>Subnetting divides networks for better management and efficiency.</li>
    <li>CIDR /n represents network portion.</li>
    <li>Hosts per subnet: 2^(host bits) - 2</li>
    <li>Number of subnets: 2^(borrowed bits)</li>
    <li>Use increment to calculate consecutive subnet addresses.</li>
  </ul>
  <h1>IPv4 Fragmentation and MTU</h1>

  <h2>1. What is MTU (Maximum Transmission Unit)?</h2>
  <ul>
    <li>The largest size of a packet (in bytes) that a network can transmit without fragmentation.</li>
    <li>Purpose: Ensures packets can traverse networks with different MTUs.</li>
    <li>Examples:
      <ul>
        <li>Ethernet: MTU = 1500 bytes</li>
        <li>PPPoE: MTU = 1492 bytes</li>
        <li>Wireless networks: varies</li>
      </ul>
    </li>
  </ul>

  <h2>2. Why Fragmentation is Needed</h2>
  <ul>
    <li>Networks along the path may have different MTUs.</li>
    <li>If a packet is larger than the MTU, it must be fragmented to fit.</li>
    <li>Fragmentation ensures end-to-end delivery over smaller MTU links.</li>
  </ul>

  <h2>3. How IPv4 Fragmentation Works</h2>
  <p>IPv4 allows routers or sender to split large packets into smaller fragments. Each fragment:</p>
  <ul>
    <li>Has its own IP header</li>
    <li>Carries a portion of the original payload</li>
  </ul>

  <h3>IPv4 Header Fields for Fragmentation</h3>
  <table>
    <tr>
      <th>Field</th>
      <th>Purpose</th>
    </tr>
    <tr>
      <td>Identification</td>
      <td>Unique ID for original packet; used to reassemble fragments.</td>
    </tr>
    <tr>
      <td>Flags (3 bits)</td>
      <td>
        <ul>
          <li>DF (Don't Fragment) = 1 → cannot fragment</li>
          <li>MF (More Fragments) = 1 → more fragments follow</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>Fragment Offset</td>
      <td>Position of fragment’s data in the original packet (in 8-byte units)</td>
    </tr>
  </table>

  <h2>4. Fragmentation Process Example</h2>
  <p>Scenario: Original packet = 4000 bytes, MTU = 1500 bytes</p>
  <ul>
    <li>Step 1: Calculate fragment size → 1500 - 20 = 1480 bytes payload per fragment</li>
    <li>Step 2: Split packet:
      <pre>
Fragment 1 → 1480 bytes payload, MF=1, Offset=0
Fragment 2 → 1480 bytes payload, MF=1, Offset=185  (1480/8)
Fragment 3 → 1040 bytes payload, MF=0, Offset=370
      </pre>
    </li>
    <li>Step 3: Forward fragments independently</li>
    <li>Step 4: Reassemble at destination using Identification and Fragment Offset; MF=0 indicates last fragment</li>
  </ul>

  <h2>5. Important Points</h2>
  <ul>
    <li>Reassembly occurs only at the destination, not at routers.</li>
    <li>Fragmentation can reduce performance; modern networks prefer Path MTU Discovery (PMTUD).</li>
    <li>DF bit avoids intermediate fragmentation; routers drop packet if > MTU and send ICMP “Fragmentation Needed”.</li>
  </ul>

  <h2>6. Path MTU Discovery (PMTUD)</h2>
  <ul>
    <li>Technique to find the smallest MTU along a path.</li>
    <li>Prevents fragmentation by sending packets small enough to traverse all links.</li>
    <li>Uses ICMP “Fragmentation Needed” messages to adjust packet size.</li>
  </ul>

  <h2>7. Summary</h2>
  <ul>
    <li>MTU = Maximum packet size a network can carry.</li>
    <li>IPv4 supports fragmentation for large packets over smaller MTU links.</li>
    <li>Key IPv4 header fields: Identification, Flags (DF/MF), Fragment Offset.</li>
    <li>Reassembly occurs at the destination host.</li>
    <li>Modern networks prefer avoiding fragmentation using PMTUD.</li>
  </ul>
  <h2>Protocols Used with IPv4</h2>

<h3>1. ICMP (Internet Control Message Protocol)</h3>
<p><strong>Purpose:</strong> Provides error reporting and network diagnostics. Helps identify problems such as unreachable hosts or routing loops.</p>
<p><strong>Key Functions:</strong></p>
<ul>
  <li><strong>Error Reporting:</strong> Destination Unreachable, Time Exceeded (TTL expired), Source Quench (rarely used)</li>
  <li><strong>Network Diagnostics:</strong> 
    <ul>
      <li>Ping: Checks if a host is reachable</li>
      <li>Traceroute: Shows the path packets take to reach a destination</li>
    </ul>
  </li>
</ul>
<p><strong>How ICMP Works:</strong> Encapsulated in an IPv4 packet (Protocol field = 1). ICMP messages are control messages, not for data transfer.</p>
<p><strong>Example:</strong> ping 8.8.8.8 → ICMP Echo Request sent → ICMP Echo Reply received</p>

<h3>2. ARP (Address Resolution Protocol)</h3>
<p><strong>Purpose:</strong> Maps IPv4 addresses to MAC addresses in a local network (LAN).</p>
<p><strong>How ARP Works:</strong></p>
<ol>
  <li>Host wants to send a packet to IP 192.168.1.10.</li>
  <li>Checks ARP cache for corresponding MAC address.</li>
  <li>If not found, sends ARP Request (broadcast): "Who has 192.168.1.10?"</li>
  <li>Host with that IP responds with ARP Reply (MAC address).</li>
  <li>Sender updates ARP table and transmits frame to MAC address.</li>
</ol>

<h3>3. TCP / UDP (Transport Layer Protocols)</h3>
<p><strong>Purpose:</strong> IPv4 encapsulates Transport Layer segments, allowing process-to-process communication between applications.</p>
<ul>
  <li><strong>TCP (Transmission Control Protocol):</strong> Connection-oriented, reliable, ordered delivery. Examples: HTTP, HTTPS, FTP, SMTP.</li>
  <li><strong>UDP (User Datagram Protocol):</strong> Connectionless, unreliable, faster. Examples: DNS, DHCP, VoIP, streaming services.</li>
</ul>
<p><strong>How TCP/UDP Works with IPv4:</strong></p>
<ol>
  <li>Transport layer creates segment (TCP/UDP).</li>
  <li>IPv4 adds IP header → forms packet.</li>
  <li>Routers forward based on destination IP.</li>
  <li>Receiver extracts segment and passes to correct application using port number.</li>
</ol>

<h3>Summary Table of IPv4-Related Protocols</h3>
<table border="1" cellpadding="5">
  <tr>
    <th>Protocol</th>
    <th>Layer</th>
    <th>Purpose</th>
    <th>Examples</th>
  </tr>
  <tr>
    <td>ICMP</td>
    <td>Network</td>
    <td>Error reporting, diagnostics</td>
    <td>ping, traceroute</td>
  </tr>
  <tr>
    <td>ARP</td>
    <td>Network / Data Link</td>
    <td>Map IP → MAC</td>
    <td>LAN delivery</td>
  </tr>
  <tr>
    <td>TCP</td>
    <td>Transport</td>
    <td>Reliable, connection-oriented delivery</td>
    <td>HTTP, FTP, SMTP</td>
  </tr>
  <tr>
    <td>UDP</td>
    <td>Transport</td>
    <td>Fast, connectionless delivery</td>
    <td>DNS, VoIP, Streaming</td>
  </tr>
</table>
<h2>IPv4 Packet Flow (Step by Step)</h2>

<h3>1. Application Layer Generates Data</h3>
<p>The application (e.g., web browser, email client) generates raw data.</p>
<p><strong>Example:</strong> Requesting a webpage → HTTP generates a request message.</p>

<h3>2. Transport Layer Adds Header</h3>
<p>TCP or UDP adds its transport header to create a segment.</p>
<ul>
  <li>Header includes source/destination ports, sequence number (TCP), checksum, etc.</li>
  <li>Resulting data unit = segment (TCP/UDP header + application data)</li>
</ul>

<h3>3. Network Layer Adds IPv4 Header</h3>
<p>IPv4 encapsulates the segment by adding an IP header, creating a packet.</p>
<ul>
  <li>Header includes: Source IP, Destination IP, TTL, Protocol (TCP/UDP), Fragmentation info if needed</li>
</ul>

<h3>4. Data Link Layer Encapsulation</h3>
<p>Packet is passed to the Data Link Layer.</p>
<ul>
  <li>Adds frame header & trailer (MAC addresses, error-checking checksum)</li>
  <li>Resulting data unit = frame ready for transmission</li>
</ul>

<h3>5. Physical Layer Transmission</h3>
<p>Frame is transmitted as electrical, optical, or wireless signals through the physical medium.</p>

<h3>6. Routing Across Networks</h3>
<ul>
  <li>If destination is on a different network, routers examine the destination IP and forward packet using routing tables</li>
  <li>TTL in the IP header is decremented at each hop to prevent loops</li>
</ul>

<h3>7. Arrival at Destination Host</h3>
<ul>
  <li>Frame reaches destination host’s Data Link Layer → frame header removed, IP packet extracted</li>
</ul>

<h3>8. Network Layer Processing</h3>
<ul>
  <li>IPv4 checks destination IP and header checksum</li>
  <li>Reassembles any fragments if needed</li>
  <li>Passes payload (TCP/UDP segment) to Transport Layer</li>
</ul>

<h3>9. Transport Layer Processing</h3>
<ul>
  <li>TCP/UDP uses port number to deliver the segment to correct application</li>
  <li>TCP ensures reliability: ACKs, sequence numbers, reordering if needed</li>
</ul>

<h3>10. Application Receives Data</h3>
<p>Application processes the data, e.g., displaying a webpage, storing an email, or playing a video stream.</p>

<h3>Visual Flow (Simplified)</h3>
<pre>
[Application Data]
        ↓
[Transport Layer: TCP/UDP Segment]
        ↓
[Network Layer: IPv4 Packet]
        ↓
[Data Link Layer: Frame with MAC addresses]
        ↓
[Physical Layer: Signals on medium]
        ↓ (Routers forward based on IP)
[Data Link Layer at Destination: Remove frame]
        ↓
[Network Layer: IPv4 header removed]
        ↓
[Transport Layer: TCP/UDP delivers to app]
        ↓
[Application Layer: Data received]
</pre>

<h3>Key Points</h3>
<ul>
  <li>IPv4 enables end-to-end delivery across multiple networks</li>
  <li>Routing is based on logical IP addresses, not MAC addresses</li>
  <li>Transport layer ensures port-based delivery and reliability</li>
  <li>Packet is encapsulated at each layer and decapsulated at the receiver</li>
</ul>
<h2>Limitations of IPv4 and IPv6 Improvements</h2>

<h3>1. Limited Address Space</h3>
<p><strong>Issue:</strong> IPv4 uses 32-bit addresses, allowing approximately <strong>4.3 billion</strong> unique addresses.</p>
<p>With the rapid growth of the Internet, especially due to mobile devices and IoT, this address space has become insufficient.</p>
<p><strong>IPv6 Solution:</strong> Uses 128-bit addresses, allowing <strong>340 undecillion</strong> (3.4 × 10<sup>38</sup>) unique addresses — effectively eliminating address shortages.</p>

<h3>2. No Built-in Security</h3>
<p><strong>Issue:</strong> IPv4 does not include encryption or authentication by default. Any IP packet can be intercepted, altered, or spoofed.</p>
<p>Security can be added via <strong>IPsec</strong>, but it is optional and not inherently part of IPv4.</p>
<p><strong>IPv6 Solution:</strong> Security is built-in — <strong>IPsec</strong> is mandatory in IPv6, providing end-to-end encryption and authentication.</p>

<h3>3. Fragmentation and Efficiency</h3>
<p><strong>Issue:</strong> In IPv4, routers can fragment packets if they exceed the MTU (Maximum Transmission Unit) of a link.</p>
<p><strong>Problems with Fragmentation:</strong></p>
<ul>
  <li>Increases overhead (each fragment carries its own IP header).</li>
  <li>Reassembly at the destination is complex and resource-intensive.</li>
  <li>Loss of a single fragment requires retransmission of the entire packet.</li>
</ul>
<p><strong>IPv6 Solution:</strong> Removes router-based fragmentation — only the sender performs fragmentation, improving efficiency and simplifying routing.</p>

<h3>Summary</h3>
<table border="1" cellpadding="6">
  <tr>
    <th>Limitation</th>
    <th>Impact</th>
    <th>IPv6 Improvement</th>
  </tr>
  <tr>
    <td>Limited Address Space</td>
    <td>Not enough IPs for all devices</td>
    <td>128-bit address space</td>
  </tr>
  <tr>
    <td>No Built-in Security</td>
    <td>Vulnerable to interception and spoofing</td>
    <td>Mandatory IPsec for encryption and authentication</td>
  </tr>
  <tr>
    <td>Fragmentation Inefficiency</td>
    <td>Higher overhead and slower transmission</td>
    <td>Only sender fragments packets; more efficient</td>
  </tr>
</table>
<h2>1. Introduction to IPv6</h2>

<p><strong>Developed by:</strong> IETF (Internet Engineering Task Force)</p>
<p><strong>Standardized in:</strong> 1998 (<a href="https://datatracker.ietf.org/doc/html/rfc2460" target="_blank">RFC 2460</a>), updated by 
<a href="https://datatracker.ietf.org/doc/html/rfc8200" target="_blank">RFC 8200</a></p>
<p><strong>Purpose:</strong> To overcome the limitations of IPv4, particularly:</p>
<ul>
  <li>Address exhaustion</li>
  <li>Lack of built-in security</li>
  <li>Inefficient routing and packet processing</li>
</ul>
<p><strong>Address Length:</strong> 128 bits → approximately <strong>3.4 × 10<sup>38</sup></strong> unique addresses 
(340 undecillion), ensuring enough addresses for every device globally.</p>
<h2>Key Features of IPv6</h2>
<p>IPv6 introduces several improvements over IPv4 to enhance scalability, performance, and security. Below is a detailed comparison:</p>

<table border="1" cellpadding="6">
  <tr>
    <th>Feature</th>
    <th>IPv4</th>
    <th>IPv6</th>
  </tr>
  <tr>
    <td><strong>Address Size</strong></td>
    <td>32 bits</td>
    <td>128 bits</td>
  </tr>
  <tr>
    <td><strong>Address Notation</strong></td>
    <td>Dotted decimal (e.g., 192.168.0.1)</td>
    <td>Hexadecimal (e.g., 2001:0db8:85a3::8a2e:0370:7334)</td>
  </tr>
  <tr>
    <td><strong>Header Length</strong></td>
    <td>Variable (20–60 bytes)</td>
    <td>Fixed (40 bytes)</td>
  </tr>
  <tr>
    <td><strong>Checksum</strong></td>
    <td>Present</td>
    <td>Removed for faster processing</td>
  </tr>
  <tr>
    <td><strong>Fragmentation</strong></td>
    <td>Routers can fragment packets</td>
    <td>Only sender fragments packets</td>
  </tr>
  <tr>
    <td><strong>Security (IPsec)</strong></td>
    <td>Optional</td>
    <td>Built-in and mandatory</td>
  </tr>
  <tr>
    <td><strong>Configuration</strong></td>
    <td>Manual or DHCP</td>
    <td>Stateless (SLAAC) or DHCPv6</td>
  </tr>
  <tr>
    <td><strong>Broadcasting</strong></td>
    <td>Supported</td>
    <td>Not supported (uses multicast/anycast instead)</td>
  </tr>
  <tr>
    <td><strong>QoS Field</strong></td>
    <td>Type of Service (ToS)</td>
    <td>Traffic Class + Flow Label</td>
  </tr>
</table>
<h2>IPv6 Addressing</h2>

<p>IPv6 uses 128-bit addresses, providing an enormous number of unique addresses. It supports multiple address types to handle different communication needs.</p>

<h3>Types of IPv6 Addresses</h3>

<table border="1" cellpadding="6">
  <tr>
    <th>Type</th>
    <th>Description</th>
    <th>Example</th>
  </tr>
  <tr>
    <td><strong>Unicast</strong></td>
    <td>Identifies a single interface. Packets sent to a unicast address are delivered to one specific device.</td>
    <td><code>2001:db8::1</code></td>
  </tr>
  <tr>
    <td><strong>Multicast</strong></td>
    <td>Used for one-to-many communication. Packets are delivered to multiple devices in a multicast group.</td>
    <td><code>ff02::1</code> (all nodes)</td>
  </tr>
  <tr>
    <td><strong>Anycast</strong></td>
    <td>Used for one-to-nearest communication. The same address is assigned to multiple interfaces, and the packet is delivered to the nearest one.</td>
    <td><em>Same address assigned to multiple interfaces</em></td>
  </tr>
  <tr>
    <td><strong>Loopback</strong></td>
    <td>Used for testing within the same host.</td>
    <td><code>::1</code></td>
  </tr>
  <tr>
    <td><strong>Link-local</strong></td>
    <td>Automatically configured for communication within a local network (not routable on the Internet).</td>
    <td><code>fe80::/10</code></td>
  </tr>
  <tr>
    <td><strong>Global Unicast</strong></td>
    <td>Publicly routable IPv6 addresses used across the Internet.</td>
    <td><code>2000::/3</code></td>
  </tr>
</table>
<h1>🌐 IPv6 Header Structure</h1>
<p><strong>Fixed Header Size:</strong> 40 bytes (unlike IPv4’s 20–60 bytes) → faster and simpler processing.</p>

<h2>🧩 IPv6 Fixed Header Format</h2>
<pre>
| Version | Traffic Class |      Flow Label        |
|     Payload Length      | Next Header | Hop Limit |
|                                                |
|               Source Address (128 bits)       |
|                                                |
|             Destination Address (128 bits)   |
</pre>

<h2>📘 Field-by-Field Explanation</h2>
<table>
<tr>
<th>Field</th>
<th>Size (bits)</th>
<th>Purpose / Explanation</th>
</tr>
<tr><td>Version</td><td>4</td><td>Always 6 (IPv6); identifies protocol version.</td></tr>
<tr><td>Traffic Class</td><td>8</td><td>QoS / priority (similar to IPv4 ToS).</td></tr>
<tr><td>Flow Label</td><td>20</td><td>Identifies packets in the same flow; supports QoS for real-time data.</td></tr>
<tr><td>Payload Length</td><td>16</td><td>Size of payload (excluding header); max 65,535 bytes. Jumbo payload handled via extension header.</td></tr>
<tr><td>Next Header</td><td>8</td><td>Identifies upper-layer protocol or extension header (TCP=6, UDP=17, ICMPv6=58).</td></tr>
<tr><td>Hop Limit</td><td>8</td><td>Limits packet lifetime; same as IPv4 TTL.</td></tr>
<tr><td>Source Address</td><td>128</td><td>Sender’s IPv6 address (unicast, anycast).</td></tr>
<tr><td>Destination Address</td><td>128</td><td>Receiver’s IPv6 address (unicast, multicast, or anycast).</td></tr>
</table>

<h2>⚙️ Key Improvements Over IPv4 Header</h2>
<table>
<tr><th>IPv4 Feature</th><th>IPv6 Feature / Improvement</th></tr>
<tr><td>Variable header (20–60 B)</td><td>Fixed header (40 B) → faster routing</td></tr>
<tr><td>Includes checksum</td><td>No checksum → less router computation</td></tr>
<tr><td>Fragmentation by routers</td><td>Only sender fragments → more efficient</td></tr>
<tr><td>Options inside header</td><td>Optional features in extension headers</td></tr>
<tr><td>Fragmentation fields (ID, flags, offset)</td><td>Removed → simpler processing</td></tr>
<tr><td>Header Length field</td><td>Not needed (fixed size)</td></tr>
</table>

<h2>🧱 IPv6 Extension Headers</h2>
<p>Optional features are included via extension headers; identified by the <strong>Next Header</strong> field of the previous header.</p>
<table>
<tr><th>Extension Header</th><th>Next Header Value</th><th>Purpose</th></tr>
<tr><td>Hop-by-Hop Options</td><td>0</td><td>Examined by every router along the path</td></tr>
<tr><td>Routing Header</td><td>43</td><td>List of intermediate nodes to visit</td></tr>
<tr><td>Fragment Header</td><td>44</td><td>Packet fragmentation</td></tr>
<tr><td>Destination Options</td><td>60</td><td>Options for destination node only</td></tr>
<tr><td>Authentication Header (AH)</td><td>51</td><td>IPsec authentication</td></tr>
<tr><td>Encapsulating Security Payload (ESP)</td><td>50</td><td>IPsec encryption</td></tr>
</table>

<h2>🧠 Advantages of IPv6 Header Design</h2>
<ul>
<li><strong>Simplified Processing:</strong> Fixed size + no checksum → faster per-hop handling.</li>
<li><strong>Scalability:</strong> 128-bit addresses → massive global network support.</li>
<li><strong>Better QoS Support:</strong> Traffic Class + Flow Label enable priority routing.</li>
<li><strong>Security:</strong> IPsec natively supported via AH and ESP headers.</li>
<li><strong>Efficient Extension Mechanism:</strong> Clean separation of main header and optional features.</li>
</ul>

<h2>🧾 Example IPv6 Header (Hexadecimal)</h2>
<table>
<tr><th>Field</th><th>Value</th></tr>
<tr><td>Version</td><td>6</td></tr>
<tr><td>Traffic Class</td><td>0x00</td></tr>
<tr><td>Flow Label</td><td>0x00000</td></tr>
<tr><td>Payload Length</td><td>0x0020 (32 bytes)</td></tr>
<tr><td>Next Header</td><td>0x3A (ICMPv6)</td></tr>
<tr><td>Hop Limit</td><td>0x40 (64)</td></tr>
<tr><td>Source Address</td><td>2001:0db8::1</td></tr>
<tr><td>Destination Address</td><td>2001:0db8::2</td></tr>
</table>
<p><em>Example represents an ICMPv6 Echo Request (ping) from <strong>2001:db8::1</strong> → <strong>2001:db8::2</strong>.</em></p>

<h2>🧩 Summary of IPv6 Header Fields</h2>
<table>
<tr><th>Field</th><th>Size</th><th>Purpose</th></tr>
<tr><td>Version</td><td>4 bits</td><td>IPv6 identifier (value = 6)</td></tr>
<tr><td>Traffic Class</td><td>8 bits</td><td>Packet priority / QoS</td></tr>
<tr><td>Flow Label</td><td>20 bits</td><td>Identify packets in the same flow</td></tr>
<tr><td>Payload Length</td><td>16 bits</td><td>Length of payload data</td></tr>
<tr><td>Next Header</td><td>8 bits</td><td>Upper-layer protocol or extension header</td></tr>
<tr><td>Hop Limit</td><td>8 bits</td><td>Max hops (like TTL)</td></tr>
<tr><td>Source Address</td><td>128 bits</td><td>Sender address</td></tr>
<tr><td>Destination Address</td><td>128 bits</td><td>Receiver address</td></tr>
</table>
<h1>🌐 IPv6 Address Configuration Methods</h1>
<p>IPv6 addresses can be assigned to hosts using three main methods.</p>

<h2>1. Stateless Address Autoconfiguration (SLAAC)</h2>
<p><strong>Purpose:</strong> Automatically configure IPv6 addresses without a DHCP server.</p>

<h3>How it Works:</h3>
<ol>
<li>Device generates a link-local address automatically using its MAC address.<br>
<em>Example:</em> <code>fe80::1a2b:3c4d:5e6f:7g8h</code></li>
<li>Device sends a Router Solicitation (RS) message to the network.</li>
<li>Router responds with Router Advertisement (RA) containing:
<ul>
<li>Network prefix</li>
<li>Prefix length</li>
<li>Default gateway info</li>
</ul>
</li>
<li>Device combines RA’s network prefix with its interface ID → forms global unicast IPv6 address.</li>
<li>Performs Duplicate Address Detection (DAD) to ensure uniqueness.</li>
</ol>

<h3>Advantages:</h3>
<ul>
<li>No DHCP server needed</li>
<li>Fully automatic</li>
<li>Easy deployment in large networks</li>
</ul>

<h2>2. DHCPv6 (Stateful Configuration)</h2>
<p><strong>Purpose:</strong> Centralized server assigns IPv6 addresses and other parameters.</p>

<h3>How it Works:</h3>
<ol>
<li>Device sends DHCPv6 Solicit message to discover servers.</li>
<li>Server responds with Advertise message containing available addresses.</li>
<li>Device requests a specific address using Request message.</li>
<li>Server confirms assignment with Reply message, including:
<ul>
<li>DNS servers</li>
<li>Domain name</li>
<li>NTP servers</li>
</ul>
</li>
</ol>

<h3>Advantages:</h3>
<ul>
<li>Centralized management</li>
<li>Suitable for enterprise networks</li>
<li>Provides full configuration options</li>
</ul>

<h2>3. Manual Configuration</h2>
<p><strong>Purpose:</strong> Administrator assigns IPv6 addresses manually.</p>

<h3>When Used:</h3>
<ul>
<li>Critical servers</li>
<li>Routers</li>
<li>Special devices requiring fixed addresses</li>
</ul>

<h3>Process:</h3>
<ul>
<li>Admin assigns global unicast address</li>
<li>Sets subnet prefix, gateway, and DNS manually</li>
</ul>

<h3>Disadvantages:</h3>
<ul>
<li>Time-consuming</li>
<li>Prone to errors</li>
<li>Not scalable for large networks</li>
</ul>

<h2>Comparison Table</h2>
<table>
<tr>
<th>Method</th>
<th>Automatic</th>
<th>Centralized</th>
<th>Suitable For</th>
<th>Notes</th>
</tr>
<tr>
<td>SLAAC</td>
<td>Yes</td>
<td>No</td>
<td>Most clients</td>
<td>Uses RA messages, no DHCP</td>
</tr>
<tr>
<td>DHCPv6</td>
<td>Yes</td>
<td>Yes</td>
<td>Enterprises</td>
<td>Provides extra configuration info</td>
</tr>
<tr>
<td>Manual</td>
<td>No</td>
<td>No</td>
<td>Servers, routers</td>
<td>Requires admin setup</td>
</tr>
</table>

<h2>💡 Key Points</h2>
<ul>
<li>SLAAC is stateless → device self-configures</li>
<li>DHCPv6 is stateful → server tracks assigned addresses</li>
</ul>
<h1>🌐 Important IPv6 Concepts – Detailed Explanation</h1>

<h2>(a) Neighbor Discovery Protocol (NDP)</h2>
<p><strong>Purpose:</strong> NDP replaces multiple IPv4 protocols:</p>
<ul>
<li>ARP → NDP handles IPv6 address → MAC mapping</li>
<li>ICMP Router Discovery → NDP enables automatic router discovery</li>
<li>ICMP Redirect → NDP manages route optimization</li>
</ul>

<h3>Functions of NDP:</h3>
<ul>
<li><strong>Address Resolution:</strong> Maps IPv6 addresses to MAC addresses. <em>Example:</em> fe80::1 → NDP finds MAC.</li>
<li><strong>Router Discovery:</strong> Hosts discover routers via Router Advertisement (RA) messages including network prefix, MTU, etc.</li>
<li><strong>Duplicate Address Detection (DAD):</strong> Ensures newly assigned IPv6 addresses are unique. Host sends Neighbor Solicitation; no response → address valid.</li>
<li><strong>Prefix Discovery:</strong> Hosts learn link network prefix from RA messages → enables SLAAC.</li>
</ul>

<h2>(b) ICMPv6</h2>
<p><strong>Purpose:</strong> IPv6 version of ICMP used for:</p>
<ul>
<li>Error reporting (unreachable destination, packet too big)</li>
<li>Diagnostics (ping6, traceroute6)</li>
<li>Neighbor Discovery (NDP relies on ICMPv6 messages)</li>
<li>Path MTU Discovery</li>
</ul>

<h3>Key ICMPv6 Message Types:</h3>
<ul>
<li><strong>Error Messages:</strong> Destination Unreachable, Packet Too Big, Time Exceeded, Parameter Problem</li>
<li><strong>Informational Messages:</strong> Echo Request / Echo Reply (ping)</li>
</ul>
<p><em>Note:</em> ICMPv6 is mandatory in IPv6 since NDP depends on it.</p>

<h2>(c) Flow Label</h2>
<p><strong>Purpose:</strong> 20-bit field in IPv6 header to support flows.</p>

<h3>Function:</h3>
<ul>
<li>Allows routers to identify packets belonging to the same “flow”.</li>
<li>Flow: sequence of packets requiring special handling (e.g., low-latency streaming, VoIP, real-time video).</li>
</ul>

<h3>Benefit:</h3>
<ul>
<li>Supports QoS without examining upper-layer headers.</li>
<li>Efficient forwarding, reduced latency, improved performance for real-time traffic.</li>
<li>Example: Packets with same source/destination and flow label → routed consistently.</li>
</ul>

<h2>📊 Summary Table</h2>
<table>
<tr>
<th>Concept</th>
<th>Purpose</th>
<th>Key Functions</th>
</tr>
<tr>
<td>NDP</td>
<td>Replaces ARP & router discovery</td>
<td>Address resolution, router discovery, DAD, prefix discovery</td>
</tr>
<tr>
<td>ICMPv6</td>
<td>Error reporting & diagnostics</td>
<td>Echo request/reply, packet too big, path MTU, NDP messaging</td>
</tr>
<tr>
<td>Flow Label</td>
<td>QoS & flow identification</td>
<td>Identifies packets of same flow for special treatment</td>
</tr>
</table>
<h1>🔐 IPv6 Security – IPsec</h1>

<h2>1. What is IPsec?</h2>
<p><strong>Full form:</strong> Internet Protocol Security</p>
<p>A set of protocols for securing IP communications by authenticating and encrypting each IP packet.</p>
<ul>
<li>In IPv4, IPsec is optional.</li>
<li>In IPv6, IPsec support is mandatory, though usage is optional in practice.</li>
</ul>

<h2>2. Components of IPsec</h2>
<table>
<tr>
<th>Component</th>
<th>Purpose</th>
</tr>
<tr>
<td>AH (Authentication Header)</td>
<td>Provides authentication and integrity of the packet. Ensures packet is from a trusted source and not altered.</td>
</tr>
<tr>
<td>ESP (Encapsulating Security Payload)</td>
<td>Provides encryption, authentication, and integrity. Hides the data inside the packet from eavesdroppers.</td>
</tr>
</table>

<h2>3. Security Features Provided</h2>
<ul>
<li><strong>Authentication:</strong> Confirms sender is legitimate and prevents IP spoofing.</li>
<li><strong>Encryption:</strong> Encrypts payload to prevent eavesdropping.</li>
<li><strong>Integrity:</strong> Ensures packet data is not tampered with; uses cryptographic hash functions.</li>
</ul>

<h2>4. How IPsec Works in IPv6</h2>
<p>IPsec can operate in two modes:</p>
<ul>
<li><strong>Transport Mode:</strong> Only the payload is encrypted/authenticated. Header remains intact. Used for host-to-host communication.</li>
<li><strong>Tunnel Mode:</strong> Entire packet (header + payload) is encrypted/authenticated. Encapsulated inside a new IPv6 packet. Used for VPNs or gateway-to-gateway communication.</li>
</ul>

<h2>5. Advantages over IPv4</h2>
<ul>
<li>IPv6 has native IPsec support → easier end-to-end security.</li>
<li>Reduces reliance on optional add-ons or application-layer encryption (TLS still recommended).</li>
<li>Secures communications, VPNs, and mobile networks efficiently.</li>
</ul>

<h2>6. Summary</h2>
<table>
<tr>
<th>Feature</th>
<th>IPv4</th>
<th>IPv6</th>
</tr>
<tr>
<td>IPsec Support</td>
<td>Optional</td>
<td>Mandatory (supported)</td>
</tr>
<tr>
<td>Authentication</td>
<td>Optional</td>
<td>Provided via AH</td>
</tr>
<tr>
<td>Encryption</td>
<td>Optional</td>
<td>Provided via ESP</td>
</tr>
<tr>
<td>Integrity</td>
<td>Optional</td>
<td>Guaranteed via AH/ESP</td>
</tr>
</table>
<h1>🌐 IPv6 Advantages over IPv4</h1>

<h2>1. Huge Address Space</h2>
<p>IPv6 uses 128-bit addresses, giving ~3.4 × 10<sup>38</sup> unique addresses. This solves the IPv4 limitation (~4.3 billion addresses), supporting billions of devices, IoT, and future expansion.</p>

<h2>2. Better Routing and Packet Handling</h2>
<p>IPv6 supports hierarchical addressing for efficient routing. The simplified header allows routers to process packets faster, reducing delays.</p>

<h2>3. Simplified Header Format</h2>
<p>The IPv6 header is fixed at 40 bytes (vs. variable 20–60 bytes in IPv4). Fewer fields → faster processing at routers, improving network performance.</p>

<h2>4. Built-in IPsec for Security</h2>
<p>IPv6 mandates support for IPsec, enabling:</p>
<ul>
<li>Authentication</li>
<li>Encryption</li>
<li>Data integrity</li>
</ul>
<p>IPv4 only has optional IPsec.</p>

<h2>5. No NAT Needed</h2>
<p>IPv6 provides enough public addresses for every device, enabling true end-to-end connectivity without Network Address Translation (NAT). This allows easier peer-to-peer communication and better IoT support.</p>

<h2>6. Autoconfiguration (SLAAC)</h2>
<p>Devices can automatically assign themselves an address using Router Advertisements, reducing administrative effort and DHCP dependency.</p>

<h2>7. Efficient Multicast Instead of Broadcast</h2>
<p>IPv6 eliminates broadcast traffic (which wastes bandwidth) and uses multicast for one-to-many communication → more efficient.</p>

<h2>8. Improved Mobility and QoS</h2>
<p>The Flow Label field allows routers to identify packet flows for Quality of Service (QoS), providing better support for real-time applications like VoIP and video conferencing. Mobile devices can change networks without breaking connections.</p>

<div class="summary">
<h3>✅ Summary</h3>
<p>IPv6 solves IPv4 limitations by providing massive address space, better performance, built-in security, and modern features like autoconfiguration and multicast, making the Internet more scalable and efficient.</p>
</div>
<h1>🌐 Transition from IPv4 to IPv6</h1>
<p>IPv4 and IPv6 are not directly compatible because:</p>
<ul>
<li>IPv4 uses 32-bit addresses, IPv6 uses 128-bit addresses</li>
<li>IPv6 has a different header structure and no checksum in the header</li>
<li>IPv6 supports features like SLAAC, mandatory IPsec, and no NAT</li>
</ul>
<p>Mechanisms are needed to allow communication between IPv4 and IPv6 networks during the transition period.</p>

<h2>1. Dual Stack</h2>
<p><strong>Concept:</strong> Devices run both IPv4 and IPv6 simultaneously.</p>
<h3>How it works:</h3>
<ul>
<li>Network interface has both IPv4 and IPv6 addresses.</li>
<li>Can communicate with IPv4 hosts using IPv4 and IPv6 hosts using IPv6.</li>
</ul>
<h3>Advantages:</h3>
<ul>
<li>Gradual transition without breaking connectivity.</li>
<li>Modern routers and OSs support dual-stack.</li>
</ul>

<h2>2. Tunneling</h2>
<p><strong>Concept:</strong> IPv6 packets are encapsulated inside IPv4 packets to traverse IPv4-only networks.</p>
<h3>How it works:</h3>
<ul>
<li>IPv6 packet is wrapped inside an IPv4 packet.</li>
<li>Travels through IPv4 network.</li>
<li>Decapsulated at tunnel endpoint and delivered as IPv6.</li>
</ul>
<h3>Types of Tunneling:</h3>
<ul>
<li>Manual/Configured Tunnels: Admin sets up tunnel endpoints.</li>
<li>Automatic Tunnels: Use techniques like 6to4 or Teredo.</li>
</ul>
<h3>Advantages:</h3>
<ul>
<li>Allows IPv6 deployment without upgrading the entire network.</li>
</ul>

<h2>3. Translation (NAT64 / DNS64)</h2>
<p><strong>Concept:</strong> Converts IPv6 packets to IPv4 packets (and vice versa) to allow communication between IPv4-only and IPv6-only hosts.</p>
<h3>How it works:</h3>
<ul>
<li><strong>NAT64:</strong> Translates IPv6 header and payload to IPv4 format.</li>
<li><strong>DNS64:</strong> Synthesizes AAAA records for IPv6 hosts querying IPv4-only hosts.</li>
</ul>
<h3>Advantages:</h3>
<ul>
<li>IPv6-only clients can reach IPv4 servers.</li>
</ul>
<h3>Limitations:</h3>
<ul>
<li>Some protocols may not work well if they depend on end-to-end IPv4 addresses.</li>
</ul>

<h2>Comparison Table</h2>
<table>
<tr>
<th>Mechanism</th>
<th>Purpose</th>
<th>How it Works</th>
<th>Pros</th>
<th>Cons</th>
</tr>
<tr>
<td>Dual Stack</td>
<td>Gradual IPv6 adoption</td>
<td>Device supports both IPv4 & IPv6</td>
<td>Simple, gradual transition</td>
<td>Requires dual-stack on all devices</td>
</tr>
<tr>
<td>Tunneling</td>
<td>IPv6 through IPv4 network</td>
<td>Encapsulates IPv6 in IPv4</td>
<td>Allows IPv6 deployment without upgrading</td>
<td>Extra overhead, slightly slower</td>
</tr>
<tr>
<td>Translation (NAT64/DNS64)</td>
<td>IPv6 ↔ IPv4 communication</td>
<td>Converts headers and payload</td>
<td>IPv6-only clients reach IPv4 servers</td>
<td>Limited protocol support, some apps may break</td>
</tr>
</table>

<h2>Summary</h2>
<ul>
<li>Transition is necessary because IPv4 and IPv6 are incompatible.</li>
<li><strong>Dual Stack:</strong> Run both protocols simultaneously.</li>
<li><strong>Tunneling:</strong> IPv6 packets travel over IPv4 networks.</li>
<li><strong>Translation:</strong> IPv6 ↔ IPv4 communication for compatibility.</li>
<li>Gradual adoption is important as IPv6 usage grows worldwide.</li>
</ul>
<h1>📡 IPv6 Packet Forwarding Process</h1>
<p>This describes the journey of an IPv6 packet from source host (Host A) to destination host (Host B).</p>

<h2>1. Host A Generates the Packet</h2>
<ol>
<li>Application layer sends data to transport layer (TCP/UDP).</li>
<li>Transport layer adds its header → forms TCP/UDP segment.</li>
<li>IPv6 layer wraps the segment in an IPv6 packet:
<ul>
<li>Source Address: Host A (e.g., <code>2001:db8::1</code>)</li>
<li>Destination Address: Host B (e.g., <code>2001:db8::2</code>)</li>
<li>Hop Limit: Default 64</li>
<li>Next Header: TCP or UDP</li>
<li>IPv6 header is fixed 40 bytes and has no checksum → faster processing</li>
</ul>
</li>
</ol>

<h2>2. Packet Leaves Host A</h2>
<ul>
<li>Packet passed to data link layer (e.g., Ethernet).</li>
<li>MAC address of next hop determined using Neighbor Discovery Protocol (NDP).</li>
<li>Frame transmitted over the link to the first router.</li>
</ul>

<h2>3. Routers Forward the Packet</h2>
<ul>
<li>Each router examines only the <strong>Destination Address</strong> in IPv6 header.</li>
<li>Router looks up routing table → finds next hop.</li>
<li>Hop Limit decremented by 1 at each router to prevent loops.</li>
<li>Packet forwarded until it reaches destination network.</li>
<li>No checksum recalculation needed (unlike IPv4).</li>
</ul>

<h2>4. Packet Arrives at Destination</h2>
<ul>
<li>Host B receives the frame at data link layer.</li>
<li>Data link layer extracts IPv6 packet → passes to network layer.</li>
<li>IPv6 layer verifies:
<ul>
<li>Destination Address matches Host B</li>
<li>Hop Limit &gt; 0</li>
</ul>
</li>
<li>IPv6 header stripped → payload (TCP/UDP segment) passed to transport layer.</li>
</ul>

<h2>5. Upper-Layer Processing</h2>
<ul>
<li>TCP/UDP layer checks port → delivers data to correct application.</li>
<li>If TCP → ensures reliability and ordering.</li>
<li>Application finally receives data (e.g., web page, email, video stream).</li>
</ul>

<h2>Visual Summary</h2>
<pre>
Host A (Source)
  └─ Application Layer → TCP/UDP segment
  └─ IPv6 Header Added → Packet (Src: 2001:db8::1, Dst: 2001:db8::2)
  └─ Data Link Layer Frame → Sent over network

Router 1 → Router 2 → Router 3
  └─ Examine Destination Address
  └─ Decrement Hop Limit
  └─ Forward to next hop

Host B (Destination)
  └─ Data Link Layer → Extract Packet
  └─ IPv6 Layer → Verify Address, Hop Limit
  └─ Transport Layer → TCP/UDP delivers to Application
</pre>

<h2>✅ Key Takeaways</h2>
<ul>
<li>IPv6 uses hop-by-hop forwarding based solely on destination address.</li>
<li>Hop Limit prevents packets from looping infinitely.</li>
<li>No checksum in IPv6 header → faster router forwarding.</li>
<li>Upper-layer protocols (TCP/UDP) handle reliability and ordering.</li>
</ul>
<h1>🌐 IPv6 Address Types</h1>
<p>IPv6 addresses are categorized based on their scope and purpose.</p>

<h2>1. Global Unicast (2000::/3)</h2>
<ul>
<li><strong>Purpose:</strong> Publicly routable addresses on the Internet.</li>
<li><strong>Scope:</strong> Can be reached from anywhere on the IPv6 Internet.</li>
<li><strong>Example:</strong> <code>2001:0db8::1</code></li>
<li><strong>Use:</strong> Assign to devices needing Internet access, e.g., web servers or public hosts.</li>
</ul>

<h2>2. Link-Local (fe80::/10)</h2>
<ul>
<li><strong>Purpose:</strong> Communication within a single link (local network segment).</li>
<li><strong>Scope:</strong> Cannot be routed beyond the local link.</li>
<li><strong>Automatic Assignment:</strong> Every IPv6-enabled interface gets a link-local address automatically.</li>
<li><strong>Example:</strong> <code>fe80::1ff:fe23:4567:890a</code></li>
<li><strong>Use:</strong> Essential for neighbor discovery, routing protocols, and automatic configuration.</li>
</ul>

<h2>3. Unique Local Address (ULA, fc00::/7)</h2>
<ul>
<li><strong>Purpose:</strong> Private addresses, similar to IPv4 private addresses (10.x.x.x, 192.168.x.x).</li>
<li><strong>Scope:</strong> Local to a site or organization; not routable on the global Internet.</li>
<li><strong>Example:</strong> <code>fd12:3456:789a::1</code></li>
<li><strong>Use:</strong> Internal networks, VPNs, isolated communication between devices.</li>
</ul>

<h2>4. Multicast (ff00::/8)</h2>
<ul>
<li><strong>Purpose:</strong> One-to-many communication; sends packets to multiple hosts simultaneously.</li>
<li><strong>Scope:</strong> Depends on multicast group (link-local, site-local, global).</li>
<li><strong>Example:</strong> <code>ff02::1</code> → all nodes on the local link</li>
<li><strong>Use:</strong> Video streaming, network services, routing updates.</li>
<li><strong>Note:</strong> IPv6 does not use broadcast; multicast replaces it.</li>
</ul>

<h2>5. Loopback (::1/128)</h2>
<ul>
<li><strong>Purpose:</strong> Tests the IPv6 stack of a host locally.</li>
<li><strong>Scope:</strong> Only within the host itself.</li>
<li><strong>Example:</strong> <code>::1</code></li>
<li><strong>Use:</strong> Verify IPv6 functionality without sending packets to the network.</li>
</ul>

<h2>Quick Summary Table</h2>
<table>
<tr>
<th>Type</th>
<th>Prefix</th>
<th>Scope</th>
<th>Usage</th>
</tr>
<tr>
<td>Global Unicast</td>
<td>2000::/3</td>
<td>Internet-wide</td>
<td>Public IP addresses</td>
</tr>
<tr>
<td>Link-Local</td>
<td>fe80::/10</td>
<td>Local link</td>
<td>Auto-config, routing, neighbor discovery</td>
</tr>
<tr>
<td>Unique Local (ULA)</td>
<td>fc00::/7</td>
<td>Private network</td>
<td>Internal communication, VPNs</td>
</tr>
<tr>
<td>Multicast</td>
<td>ff00::/8</td>
<td>Group</td>
<td>One-to-many communication</td>
</tr>
<tr>
<td>Loopback</td>
<td>::1/128</td>
<td>Host</td>
<td>Local testing</td>
</tr>
</table>
<h1>🌐 IPv6 Address Example</h1>

<p><strong>Example IPv6 Address:</strong> <code>2001:0db8:85a3:0000:0000:8a2e:0370:7334</code></p>

<h2>1. Global Routing Prefix (First 48 bits)</h2>
<p><code>2001:0db8:85a3</code></p>
<ul>
<li>Assigned by IANA / ISPs to identify a specific organization or site on the Internet.</li>
<li>Used for routing between networks globally.</li>
</ul>

<h2>2. Subnet ID (Next 16 bits)</h2>
<p><code>85a3</code></p>
<ul>
<li>Used within the organization to divide the site into multiple subnets.</li>
<li>Helps manage internal networks efficiently.</li>
</ul>

<h2>3. Interface ID (Last 64 bits)</h2>
<p><code>0000:0000:8a2e:0370:7334</code></p>
<ul>
<li>Uniquely identifies a device interface on a subnet.</li>
<li>Often derived from MAC address or configured manually.</li>
</ul>

<h2>📊 Visual Representation</h2>
<table>
<tr>
<th>Global Routing Prefix</th>
<th>Subnet ID</th>
<th>Interface ID</th>
</tr>
<tr>
<td>2001:0db8</td>
<td>85a3</td>
<td>0000:0000:8a2e:0370:7334</td>
</tr>
</table>

<h2>🔑 Key Notes</h2>
<ul>
<li>Total 128 bits: 48 + 16 + 64 bits</li>
<li>First 64 bits (Global Routing Prefix + Subnet ID) are network-related.</li>
<li>Last 64 bits are host/interface-related.</li>
</ul>
<h2>1. ping6</h2>
<p><strong>Purpose:</strong> Test reachability of an IPv6 host.</p>
<pre><code>ping6 2001:db8::1</code></pre>
<p><strong>Details:</strong></p>
<ul>
<li>Sends ICMPv6 Echo Request messages.</li>
<li>Replies confirm connectivity and measure round-trip time.</li>
<li>Similar to ping in IPv4 but uses ICMPv6.</li>
</ul>

<h2>2. traceroute6</h2>
<p><strong>Purpose:</strong> Trace the path packets take to reach an IPv6 destination.</p>
<pre><code>traceroute6 2001:db8::1</code></pre>
<p><strong>Details:</strong></p>
<ul>
<li>Shows all routers (hops) along the path.</li>
<li>Helps diagnose network routing issues.</li>
</ul>

<h2>3. ip -6 addr</h2>
<p><strong>Purpose:</strong> View IPv6 addresses assigned to all interfaces.</p>
<pre><code>ip -6 addr</code></pre>
<p><strong>Details:</strong></p>
<ul>
<li>Displays link-local, global, and unique local addresses.</li>
<li>Shows interface names, prefix lengths, and scope.</li>
</ul>

<h2>4. ifconfig / ipconfig</h2>
<p><strong>Purpose:</strong> Display and configure network interfaces.</p>
<pre><code>Linux/macOS: ifconfig
Windows: ipconfig</code></pre>
<p><strong>Details:</strong></p>
<ul>
<li>Shows IPv6 addresses assigned to each interface.</li>
<li>Can configure temporary IPv6 addresses for testing.</li>
</ul>

<h2>5. Wireshark</h2>
<p><strong>Purpose:</strong> Analyze IPv6 traffic and headers.</p>
<p><strong>Usage:</strong> Capture packets on any interface and filter using <code>ipv6</code>.</p>
<p><strong>Details:</strong></p>
<ul>
<li>View source/destination addresses, Next Header field, Flow Label, and payload.</li>
<li>Useful for debugging, learning, and verifying IPv6 configurations.</li>
</ul>

<h2>📋 Summary of Tools</h2>
<table>
<tr>
<th>Tool</th>
<th>Function</th>
<th>Protocol</th>
</tr>
<tr>
<td>ping6</td>
<td>Connectivity test</td>
<td>ICMPv6 Echo</td>
</tr>
<tr>
<td>traceroute6</td>
<td>Path tracing / hops</td>
<td>ICMPv6 TTL</td>
</tr>
<tr>
<td>ip -6 addr</td>
<td>View interface IPv6 addresses</td>
<td>N/A</td>
</tr>
<tr>
<td>ifconfig / ipconfig</td>
<td>Interface configuration</td>
<td>N/A</td>
</tr>
<tr>
<td>Wireshark</td>
<td>Packet capture & analysis</td>
<td>IPv6</td>
</tr>
</table>
<h1>🌐 What is Routing?</h1>

<p><strong>Definition:</strong> Routing is the process of determining the optimal path for data packets to travel from the source to the destination across one or more networks.</p>

<p><strong>Goal:</strong> Deliver packets efficiently, reliably, and quickly.</p>

<p><strong>Key Point:</strong> Routers use routing tables and protocols to make forwarding decisions.</p>
<h1>🌐 Static Routing</h1>

<h2>1. Definition</h2>
<p>Static routing is a type of routing in which network routes are manually configured by a network administrator. These routes do not change automatically if the network topology changes. Suitable for small or simple networks.</p>
<p><strong>Key Idea:</strong> The administrator tells the router exactly where to send packets for specific networks.</p>

<h2>2. Characteristics of Static Routing</h2>
<table>
<tr>
<th>Feature</th>
<th>Description</th>
</tr>
<tr>
<td>Configuration</td>
<td>Manual by admin</td>
</tr>
<tr>
<td>Adaptability</td>
<td>Does not adapt automatically to network failures</td>
</tr>
<tr>
<td>Complexity</td>
<td>Simple in small networks, complex in large networks</td>
</tr>
<tr>
<td>Overhead</td>
<td>No extra routing protocol overhead</td>
</tr>
<tr>
<td>Security</td>
<td>More secure because routes cannot be altered by external routers</td>
</tr>
</table>

<h2>3. Advantages</h2>
<ul>
<li>Simplicity: Easy to configure in small networks.</li>
<li>Low Overhead: No routing protocol updates or calculations.</li>
<li>Predictable: Routes are fixed, making troubleshooting easier.</li>
<li>Security: No risk of external routing updates changing the routes.</li>
</ul>

<h2>4. Disadvantages</h2>
<ul>
<li>Not scalable: Hard to manage in large networks with many routers.</li>
<li>No automatic adaptation: Packets may be lost if a link goes down.</li>
<li>Administrative effort: Any network change requires manual updates.</li>
</ul>

<h2>5. Configuration Example</h2>

<h3>IPv4 Static Route</h3>
<p>Suppose you have two networks connected via a router:</p>
<ul>
<li>Network A: 192.168.1.0/24</li>
<li>Network B: 192.168.2.0/24</li>
<li>Router interface toward B: 192.168.1.2</li>
</ul>
<p><strong>Command (Cisco IOS syntax):</strong></p>
<pre><code>ip route 192.168.2.0 255.255.255.0 192.168.1.2</code></pre>
<p>Destination network: 192.168.2.0<br>
Subnet mask: 255.255.255.0<br>
Next hop: 192.168.1.2</p>

<h3>IPv6 Static Route</h3>
<pre><code>ipv6 route 2001:db8:2::/64 2001:db8:1::2</code></pre>

<h2>6. When to Use Static Routing</h2>
<ul>
<li>Small networks with few routers.</li>
<li>Connections to ISP routers for default routes.</li>
<li>Networks where security and control are important.</li>
<li>When network topology rarely changes.</li>
</ul>

<h2>7. Comparison: Static vs Dynamic Routing</h2>
<table>
<tr>
<th>Feature</th>
<th>Static Routing</th>
<th>Dynamic Routing</th>
</tr>
<tr>
<td>Configuration</td>
<td>Manual</td>
<td>Automatic via protocols</td>
</tr>
<tr>
<td>Adaptability</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>Complexity</td>
<td>Low for small networks</td>
<td>Higher</td>
</tr>
<tr>
<td>Overhead</td>
<td>Minimal</td>
<td>Uses bandwidth & CPU</td>
</tr>
<tr>
<td>Scalability</td>
<td>Poor</td>
<td>Good for large networks</td>
</tr>
<tr>
<td>Security</td>
<td>High</td>
<td>Moderate</td>
</tr>
</table>
<h1>🌐 Dynamic Routing</h1>

<h2>Definition</h2>
<p>Routing in which routers automatically exchange routing information and update their routing tables in real time.</p>

<h2>Goal</h2>
<p>Adapt to network changes such as link failures or new networks without manual intervention.</p>

<h2>Key Idea</h2>
<p>Each router communicates with its neighbors to learn the best path through the network.</p>

<h1>🌐 Dynamic Routing Overview</h1>

<h2>1. Automatic Updates</h2>
<p>Dynamic routing protocols allow routers to learn new routes automatically from neighboring routers.</p>
<ul>
<li>No manual configuration required after initial setup.</li>
<li>Ensures routing tables are always up-to-date with the current network topology.</li>
</ul>

<h2>2. Adaptability</h2>
<p>Dynamic routing can respond to network failures or changes:</p>
<ul>
<li>If a link goes down, routers detect it and recalculate alternative paths.</li>
<li>If a new network is added, routers automatically propagate the new route.</li>
<li>Ensures continuous network connectivity without human intervention.</li>
</ul>

<h2>3. Scalability</h2>
<p>Dynamic routing works well in large and complex networks:</p>
<ul>
<li>Routers exchange information dynamically, so adding more routers/networks doesn’t require manual route entries.</li>
<li>Protocols like OSPF and BGP are designed for enterprise and Internet-scale networks.</li>
</ul>

<h2>4. Routing Protocols</h2>
<p>Examples of dynamic routing protocols:</p>
<table>
<tr>
<th>Protocol</th>
<th>Type</th>
<th>Notes</th>
</tr>
<tr>
<td>RIP (Routing Information Protocol)</td>
<td>Distance-vector</td>
<td>Simple, suitable for small networks</td>
</tr>
<tr>
<td>OSPF (Open Shortest Path First)</td>
<td>Link-state</td>
<td>Fast convergence, scalable</td>
</tr>
<tr>
<td>EIGRP (Enhanced Interior Gateway Routing Protocol)</td>
<td>Hybrid</td>
<td>Cisco proprietary, efficient</td>
</tr>
<tr>
<td>BGP (Border Gateway Protocol)</td>
<td>Path-vector</td>
<td>Used between autonomous systems (Internet backbone)</td>
</tr>
</table>

<h2>5. Convergence</h2>
<p>Convergence is the state when all routers have a consistent and updated view of reachable networks.</p>
<ul>
<li>Fast convergence prevents routing loops and packet loss.</li>
<li>Protocol convergence speeds:</li>
<ul>
<li>RIP → slower (periodic updates)</li>
<li>OSPF/EIGRP → faster (event-driven updates)</li>
</ul>
</ul>
<h1>📡 Distance-Vector Routing Protocols (In-Depth)</h1>

<h2>1. Definition</h2>
<p>Distance-vector routing is a dynamic routing method where each router shares its routing table with directly connected neighbors.</p>
<ul>
<li><strong>Distance:</strong> Metric to reach a destination (usually hop count)</li>
<li><strong>Vector:</strong> Direction (next-hop router) to reach the destination</li>
<li>Routers only know information from neighbors, not complete network topology</li>
</ul>

<h2>2. Algorithm: Bellman-Ford</h2>
<p>Distance-vector routing uses the Bellman-Ford algorithm:</p>

<pre>D(X) = min { C(X, Y) + D(Y) }</pre>

<p>Where:</p>
<ul>
<li><code>D(X)</code> = Distance from current router to destination X</li>
<li><code>C(X, Y)</code> = Cost from current router to neighbor Y</li>
<li><code>D(Y)</code> = Distance from neighbor Y to destination X</li>
</ul>
<p>Explanation: Router selects the neighbor Y that provides the minimum total distance to reach X.</p>

<h2>3. Key Features</h2>
<ul>
<li><strong>Periodic Updates:</strong> Each router sends its routing table to neighbors every 30 seconds (default in RIP)</li>
<li><strong>Simple Implementation:</strong> Low CPU and memory requirement</li>
<li><strong>Limited Knowledge:</strong> Routers do not know entire network topology</li>
<li><strong>Convergence Issues:</strong> Slow convergence can cause routing loops</li>
<li><strong>Loop Prevention Techniques:</strong>
    <ul>
        <li>Split Horizon: Do not advertise a route back to the router from which it was learned</li>
        <li>Poison Reverse: Advertise route back to neighbor with infinite metric to prevent loops</li>
        <li>Hold-down Timers: Delay accepting potentially bad updates</li>
    </ul>
</li>
</ul>

<h2>4. Example: RIP (Routing Information Protocol)</h2>
<table>
<tr>
<th>Feature</th>
<th>Details</th>
</tr>
<tr>
<td>Protocol</td>
<td>RIP (v1, v2)</td>
</tr>
<tr>
<td>Type</td>
<td>Distance-vector</td>
</tr>
<tr>
<td>Metric</td>
<td>Hop count</td>
</tr>
<tr>
<td>Maximum hops</td>
<td>15 (16 = unreachable)</td>
</tr>
<tr>
<td>Update interval</td>
<td>30 seconds</td>
</tr>
</table>

<h3>Example Network:</h3>
<pre>
Network A --- R1 --- R2 --- Network B
             |
             R3
             |
           Network C
</pre>

<h3>Routing Table at R1 (simplified):</h3>
<table>
<tr>
<th>Destination</th>
<th>Next Hop</th>
<th>Hop Count</th>
</tr>
<tr>
<td>Network A</td>
<td>Direct</td>
<td>0</td>
</tr>
<tr>
<td>Network B</td>
<td>R2</td>
<td>1</td>
</tr>
<tr>
<td>Network C</td>
<td>R3</td>
<td>1</td>
</tr>
</table>

<h3>Update Process:</h3>
<ul>
<li>R1 sends its table to R2 and R3 every 30 seconds</li>
<li>R2 updates its table based on R1’s info and sends back updates</li>
<li>Each router gradually learns the best paths</li>
</ul>

<h2>5. Advantages of Distance-Vector Protocols</h2>
<ul>
<li>Simple to configure and implement</li>
<li>Low memory and CPU usage</li>
<li>Works well in small networks</li>
</ul>

<h2>6. Disadvantages</h2>
<ul>
<li>Slow convergence → routing loops possible</li>
<li>Limited scalability → not suitable for very large networks</li>
<li>Only considers hop count → not suitable for complex networks where bandwidth, delay, or reliability matter</li>
</ul>
<h1>🌐 Link-State Routing Protocols</h1>

<h2>1. Definition</h2>
<p>Link-State Routing Protocols are dynamic routing protocols in which each router maintains a complete map of the network topology and independently computes the shortest path to every destination.</p>
<ul>
    <li><strong>Key Algorithm:</strong> Dijkstra’s Shortest Path First (SPF)</li>
    <li><strong>Key Idea:</strong> Every router knows the entire network graph, unlike distance-vector protocols that only know neighbors.</li>
</ul>

<h2>2. How Link-State Protocols Work</h2>

<h3>Step 1: Neighbor Discovery</h3>
<ul>
    <li>Routers use Hello messages to discover directly connected neighbors.</li>
    <li>Each router builds a neighbor table with interface info and link status.</li>
</ul>

<h3>Step 2: Link-State Advertisement (LSA)</h3>
<ul>
    <li>Routers broadcast LSAs to all routers in the area/network.</li>
    <li>LSA contains:
        <ul>
            <li>Router ID</li>
            <li>List of directly connected neighbors</li>
            <li>Cost (metric) of each link</li>
        </ul>
    </li>
    <li>LSAs are flooded reliably so all routers get the same information.</li>
</ul>

<h3>Step 3: Building Link-State Database</h3>
<ul>
    <li>Each router collects LSAs from all routers → forms a Link-State Database (LSDB).</li>
    <li>LSDB represents the complete topology of the network.</li>
</ul>

<h3>Step 4: Shortest Path Calculation</h3>
<ul>
    <li>Routers run Dijkstra’s SPF algorithm on LSDB:</li>
    <ul>
        <li>Start from the router itself (root)</li>
        <li>Calculate shortest path to every destination based on link cost</li>
        <li>Result = Shortest Path Tree</li>
    </ul>
    <li>Router updates its routing table with next-hop info for each destination.</li>
</ul>

<h3>Step 5: Forwarding</h3>
<p>Packets are forwarded according to the routing table computed by SPF. Each router independently computes paths, ensuring consistent network-wide routing.</p>

<h2>3. Key Features</h2>
<ul>
    <li>Fast Convergence: Network changes propagate quickly via LSAs.</li>
    <li>Accurate Topology: Routers have a full view of the network → optimal paths.</li>
    <li>Flooding Mechanism: LSAs reliably sent to all routers in the area.</li>
    <li>Hierarchical Design: Uses areas to reduce overhead (e.g., OSPF Areas).</li>
    <li>Resource Usage: Higher CPU and memory compared to distance-vector protocols.</li>
</ul>

<h2>4. Advantages</h2>
<ul>
    <li>No routing loops (thanks to SPF algorithm)</li>
    <li>Fast adaptation to network changes</li>
    <li>Scalable with hierarchical area design</li>
    <li>Supports variable metrics (cost, bandwidth, delay)</li>
</ul>

<h2>5. Disadvantages</h2>
<ul>
    <li>Higher resource usage → CPU and memory intensive</li>
    <li>More complex configuration than distance-vector</li>
    <li>Flooding LSAs can temporarily increase network traffic</li>
</ul>

<h2>6. Examples</h2>
<h3>A. OSPF (Open Shortest Path First)</h3>
<ul>
    <li>Widely used in enterprise networks</li>
    <li>Hierarchical design using areas</li>
    <li>Cost metric based on bandwidth</li>
    <li>Supports IPv4 and IPv6 (OSPFv3)</li>
</ul>

<h3>B. IS-IS (Intermediate System to Intermediate System)</h3>
<ul>
    <li>Often used in service provider networks / ISP backbones</li>
    <li>Hierarchical design using areas and levels</li>
    <li>Can carry both IPv4 and IPv6 addresses</li>
    <li>Uses CLNS addressing internally</li>
</ul>

<h2>7. Key Concepts</h2>
<table>
<tr>
<th>Concept</th>
<th>Description</th>
</tr>
<tr>
<td>LSA (Link-State Advertisement)</td>
<td>Packet describing router links and metrics</td>
</tr>
<tr>
<td>LSDB (Link-State Database)</td>
<td>Complete network map at each router</td>
</tr>
<tr>
<td>SPF (Shortest Path First)</td>
<td>Algorithm to compute shortest path tree</td>
</tr>
<tr>
<td>Hello Protocol</td>
<td>Detects and maintains neighbor relationships</td>
</tr>
<tr>
<td>Area</td>
<td>Logical grouping to reduce LSA flooding (OSPF)</td>
</tr>
</table>

<h2>8. Example Flow in OSPF</h2>
<ol>
    <li>Router discovers neighbors → forms neighbor table</li>
    <li>Sends LSA describing its links</li>
    <li>Receives LSAs from all routers → builds LSDB</li>
    <li>Runs SPF algorithm → generates routing table</li>
    <li>Forwards packets based on the table</li>
</ol>
<h1>🌐 Path-Vector Routing Protocols</h1>

<h2>1. Definition</h2>
<p>Path-Vector Routing is a type of dynamic routing used to exchange routing information between <strong>autonomous systems (AS)</strong>.</p>
<p>Each router maintains:</p>
<ul>
<li>The next hop for each destination</li>
<li>The full path of AS numbers the route traverses</li>
</ul>
<p><strong>Purpose:</strong> Prevent routing loops in large-scale networks (Internet).</p>

<h2>2. Key Characteristics</h2>
<ul>
<li><strong>Inter-domain Routing:</strong> Works between ASes, unlike RIP/OSPF (intra-domain).</li>
<li><strong>Loop Prevention:</strong> Maintains full AS path in route advertisements → if an AS number appears twice, the route is rejected.</li>
<li><strong>Policy-Based Routing:</strong> Operators control preferred paths using policies, local preference, and route filtering.</li>
<li><strong>Scalable:</strong> Designed for the Internet’s large network of routers and autonomous systems.</li>
</ul>

<h2>3. BGP (Border Gateway Protocol)</h2>
<ul>
<li>Most common path-vector protocol</li>
<li>RFC: 4271</li>
<li>Used for: Internet backbone routing between ISPs</li>
</ul>

<h3>Types of BGP</h3>
<ul>
<li><strong>eBGP (External BGP):</strong> Between different autonomous systems</li>
<li><strong>iBGP (Internal BGP):</strong> Within the same autonomous system</li>
</ul>

<h2>4. How BGP Works</h2>
<p>Routers establish <strong>TCP connection (port 179)</strong> → reliable session, then exchange messages:</p>
<ul>
<li><strong>OPEN:</strong> Establish session</li>
<li><strong>UPDATE:</strong> Advertise routes and AS-path</li>
<li><strong>KEEPALIVE:</strong> Maintain session</li>
<li><strong>NOTIFICATION:</strong> Error handling</li>
</ul>
<p>Routers build BGP Table with:</p>
<ul>
<li>Destination network</li>
<li>Next hop</li>
<li>AS path</li>
<li>Local preference</li>
</ul>

<h2>5. BGP Route Selection</h2>
<table>
<tr>
<th>Attribute</th>
<th>Description</th>
</tr>
<tr>
<td>AS-path</td>
<td>Shortest number of ASes traversed</td>
</tr>
<tr>
<td>Local Preference</td>
<td>Preference set within AS (higher = preferred)</td>
</tr>
<tr>
<td>MED (Multi-Exit Discriminator)</td>
<td>Suggests preferred entry point to neighbor AS</td>
</tr>
<tr>
<td>Next Hop</td>
<td>IP of the next router to reach destination</td>
</tr>
<tr>
<td>Origin</td>
<td>How route was learned (IGP, EGP, Incomplete)</td>
</tr>
<tr>
<td>Weight</td>
<td>Cisco-specific, local priority</td>
</tr>
</table>

<h2>6. Advantages of Path-Vector (BGP)</h2>
<ul>
<li>Prevents routing loops across ASes</li>
<li>Supports policy-based routing</li>
<li>Scalable for Internet-wide routing</li>
<li>Can handle multiple paths and failover</li>
</ul>

<h2>7. Disadvantages</h2>
<ul>
<li>Complex configuration</li>
<li>Slower convergence than IGPs (RIP/OSPF)</li>
<li>Needs careful policy management</li>
<li>BGP misconfigurations can affect global Internet routing</li>
</ul>

<h2>8. Example</h2>
<p>AS1 → AS2 → AS3 → Destination network</p>
<p>Route advertisement includes <strong>AS-path:</strong> 1 2 3</p>
<p>If AS2 receives the same route again → sees its own AS in path → ignores route, preventing loops.</p>

<h2>1. Convergence</h2>
<p><strong>Definition:</strong> Convergence is the process where all routers in a network agree on the best paths after a network change (link failure or addition).</p>

<h3>Importance:</h3>
<ul>
    <li>Ensures stable and reliable routing.</li>
    <li>Slow convergence → routing loops, lost packets, delays.</li>
</ul>

<h3>Speed of Convergence by Protocol:</h3>
<ul>
    <li>Link-State Protocols (OSPF, IS-IS): Fast convergence</li>
    <li>Distance-Vector Protocols (RIP): Slow convergence</li>
</ul>

<h3>Techniques to Improve Convergence:</h3>
<ul>
    <li>Triggered updates: Send updates immediately when topology changes (RIP)</li>
    <li>Hold-down timers: Prevent unstable routes from being reinstated too quickly</li>
    <li>Split horizon & poison reverse: Prevent loops in distance-vector protocols</li>
    <li>SPF recalculation: Recompute shortest paths using Dijkstra algorithm (OSPF)</li>
</ul>

<h2>2. Advantages of Dynamic Routing</h2>
<ul>
    <li>Automatic updates → No manual configuration needed after changes</li>
    <li>Scalable → Works well for large networks</li>
    <li>Adaptive to failures → Reroutes traffic if a link goes down</li>
    <li>Efficient path selection → Uses metrics like hop count, bandwidth, or policy</li>
</ul>

<h2>3. Disadvantages of Dynamic Routing</h2>
<ul>
    <li>Complexity → Requires proper protocol configuration</li>
    <li>Higher resource usage → More CPU, memory, and bandwidth compared to static routing</li>
    <li>Security risks → Routes can be manipulated; authentication required</li>
    <li>Routing loops → Possible in distance-vector protocols if not mitigated</li>
</ul>

<h2>4. How Dynamic Routing Works (Example)</h2>
<p>Scenario: 3 Routers (R1, R2, R3) connecting networks A, B, C</p>
<p>Routers exchange routing info using a protocol (e.g., RIP) and build a routing table:</p>

<table>
<tr>
<th>Destination Network</th>
<th>Next Hop</th>
<th>Metric</th>
</tr>
<tr>
<td>Network B</td>
<td>R2</td>
<td>1</td>
</tr>
<tr>
<td>Network C</td>
<td>R2 → R3</td>
<td>2</td>
</tr>
</table>

<p>If a link fails, routers detect it and update tables automatically to reroute packets.</p>

<h2>5. Comparison of Dynamic Routing Protocol Types</h2>
<table>
<tr>
<th>Feature</th>
<th>Distance-Vector</th>
<th>Link-State</th>
<th>Path-Vector</th>
</tr>
<tr>
<td>Protocol Examples</td>
<td>RIP</td>
<td>OSPF, IS-IS</td>
<td>BGP</td>
</tr>
<tr>
<td>Knowledge</td>
<td>Neighbor info only</td>
<td>Entire network topology</td>
<td>Path to destinations (AS-path)</td>
</tr>
<tr>
<td>Convergence</td>
<td>Slow</td>
<td>Fast</td>
<td>Moderate</td>
</tr>
<tr>
<td>Complexity</td>
<td>Low</td>
<td>High</td>
<td>High</td>
</tr>
<tr>
<td>Loop Prevention</td>
<td>Split horizon, poison reverse</td>
<td>SPF algorithm</td>
<td>Path info</td>
</tr>
<tr>
<td>Usage</td>
<td>Small–medium networks</td>
<td>Large enterprise networks</td>
<td>Inter-ISP / Internet backbone</td>
</tr>
</table>

<h2>✅ Key Takeaways</h2>
<ul>
<li>Distance-Vector: Simple, slow convergence, small networks</li>
<li>Link-State: Fast, accurate, suitable for large enterprise networks</li>
<li>Path-Vector: Handles Internet-wide routing between autonomous systems (BGP)</li>
<li>Convergence and loop prevention are critical for network stability</li>
</ul>


 <h1>1. What is the Data Link Layer?</h1>

    <p>
        The <span class="highlight">Data Link Layer</span> (Layer 2 of the OSI model) is responsible for
        reliable data transfer between two directly connected devices on the same physical network.
    </p>

    <p><span class="highlight">In simple words:</span></p>

    <ul>
        <li>Physical layer moves bits</li>
        <li>
            Data Link layer organizes those bits into frames, adds addresses,
            checks for errors, and controls who can talk and when
        </li>
    </ul>

    <p>
        It works only within a local network segment.
        The moment data has to cross a router, Layer 2 hands over responsibility.
    </p>

    <h2>2. Why the Data Link Layer Exists</h2>

    <p>
        Raw bits are useless without structure. The Data Link layer exists to:
    </p>

    <ul>
        <li>Add meaning to bits</li>
        <li>Identify sender and receiver</li>
        <li>Detect corruption</li>
        <li>Prevent devices from talking over each other</li>
    </ul>

    <p>
        Without it, Ethernet would be screaming into the void.
    </p>
    <h1>1. What is Framing?</h1>

<p>
    <span class="highlight">Framing</span> is a Data Link Layer function that divides a continuous stream
    of bits from the Physical layer into manageable units called <span class="highlight">frames</span>.
</p>

<p>
    Think of the Physical layer as a firehose of bits. Framing is the only thing stopping that hose
    from drowning the receiver.
</p>

<h2>2. Why Framing Is Needed</h2>

<p><span class="highlight">Without framing:</span></p>
<ul>
    <li>Receiver cannot tell where one message ends and the next begins</li>
    <li>Error detection is impossible</li>
    <li>Addressing cannot be applied</li>
    <li>Data becomes an undifferentiated bit soup</li>
</ul>

<p><span class="highlight">Framing gives:</span></p>
<ul>
    <li>Start and end boundaries</li>
    <li>Addressing</li>
    <li>Error detection</li>
</ul>

<h2>3. What a Frame Contains</h2>

<p>A frame typically has three parts:</p>

<table>
    <tr>
        <th>Header</th>
        <th>Payload (Data)</th>
        <th>Trailer</th>
    </tr>
</table>

<h3>Header</h3>
<ul>
    <li>Source address</li>
    <li>Destination address</li>
    <li>Control / Type / Length fields</li>
</ul>

<h3>Payload</h3>
<ul>
    <li>Actual data from upper layers</li>
</ul>

<h3>Trailer</h3>
<ul>
    <li>Error detection (FCS / CRC)</li>
</ul>

<h2>4. Textual Diagram: Generic Frame Structure</h2>

<pre>
+------------------------------------------------------+
|   Header        |        Data        |   Trailer     |
+------------------------------------------------------+
| Address | Ctrl  | Network Packet    |   FCS (CRC)   |
+------------------------------------------------------+
</pre>

<h2>5. Example: Framing in Ethernet</h2>

<p><span class="highlight">Scenario:</span></p>
<p>Host A sends data to Host B on the same LAN.</p>

<p>Upper layers give a raw data stream:</p>

<pre>
101010111010101110101011...
</pre>

<p>The Data Link layer frames it.</p>

<h3>Ethernet Frame Structure (Simplified)</h3>

<pre>
+------------------------------------------------------------------+
| Dest MAC | Src MAC | Type |        Data         |     FCS        |
+------------------------------------------------------------------+
| 6 bytes  | 6 bytes | 2 B  | 46–1500 bytes       |   4 bytes     |
+------------------------------------------------------------------+
</pre>

<p>This entire block is one frame.</p>

<h2>6. Step-by-Step Framing Process</h2>

<h3>Step 1: Data Arrival</h3>
<p>Network layer sends a packet to Data Link layer</p>
<pre>[ IP Packet ]</pre>

<h3>Step 2: Header Added</h3>
<pre>[ Dest MAC | Src MAC | Type | IP Packet ]</pre>

<h3>Step 3: Trailer Added</h3>
<pre>[ Dest MAC | Src MAC | Type | IP Packet | FCS ]</pre>

<h3>Step 4: Transmission</h3>
<pre>1010101010110101010101...</pre>

<h2>7. How Receiver Uses Framing</h2>

<ul>
    <li>Detects start of frame</li>
    <li>Reads header fields</li>
    <li>Collects payload</li>
    <li>Checks FCS</li>
    <li>Removes header and trailer</li>
    <li>Passes data upward</li>
</ul>

<p>If FCS fails → frame dropped without ceremony.</p>

<h2>8. Frame Boundary Detection Methods</h2>

<h3>1. Character Count</h3>
<ul>
    <li>Header specifies frame length</li>
    <li>Error-prone if count is corrupted</li>
</ul>

<h3>2. Flag Bytes (Byte Stuffing)</h3>
<ul>
    <li>Special flag marks start and end</li>
    <li>Escape characters used in data</li>
</ul>

<h3>3. Bit Stuffing</h3>
<ul>
    <li>Special bit pattern indicates frame boundary</li>
    <li>Used in HDLC</li>
</ul>

<h3>4. Physical Layer Coding Violations</h3>
<ul>
    <li>Ethernet uses signal-level tricks</li>
</ul>

<h2>9. Textual Diagram: Framing Concept</h2>

<pre>
Bit Stream from Physical Layer
----------------------------------------------------
101011001010111010101110101010101010101

After Framing
----------------------------------------------------
| Frame 1 | Frame 2 | Frame 3 |
----------------------------------------------------
| Header | Data | Trailer | Header | Data | Trailer |
----------------------------------------------------
</pre>

<h2>10. Why Framing Is Critical</h2>

<ul>
    <li>Enables error detection</li>
    <li>Enables addressing</li>
    <li>Enables switching</li>
    <li>Enables reliable local communication</li>
</ul>
<h1>1. What is Physical (MAC) Addressing?</h1>

<p>
    <span class="highlight">Physical addressing</span> is the mechanism used by the Data Link layer
    to uniquely identify devices within the same local network using
    <span class="highlight">MAC addresses</span>.
</p>

<p>A MAC (Media Access Control) address is:</p>
<ul>
    <li>48 bits (6 bytes)</li>
    <li>Written in hexadecimal</li>
    <li>Assigned to a Network Interface Card (NIC)</li>
</ul>

<p><span class="highlight">Example:</span></p>
<pre>00:1A:2B:3C:4D:5E</pre>

<p>
    Think of it as the device’s permanent name tag on a LAN.
</p>

<h2>2. Why MAC Addressing is Needed</h2>

<p>
    Bits don’t know where to go. IP addresses change.
    Switches need something local, fixed, and fast.
</p>

<p><span class="highlight">MAC addressing allows:</span></p>
<ul>
    <li>Frame delivery inside a LAN</li>
    <li>Switches to forward frames correctly</li>
    <li>Multiple devices to coexist without chaos</li>
</ul>

<p>
    Routing comes later. MAC handles the “who exactly” part.
</p>

<h2>3. Structure of a MAC Address</h2>

<table>
    <tr>
        <th>OUI (24 bits)</th>
        <th>NIC-specific (24 bits)</th>
    </tr>
</table>

<h3>OUI (Organizationally Unique Identifier)</h3>
<ul>
    <li>Assigned by IEEE</li>
    <li>Identifies the manufacturer</li>
</ul>

<p><span class="highlight">Example:</span></p>
<pre>00:1A:2B → Cisco</pre>

<h3>NIC-specific Part</h3>
<ul>
    <li>Assigned by the manufacturer</li>
    <li>Unique per device</li>
</ul>

<h2>4. Types of MAC Addresses</h2>

<h3>1. Unicast</h3>
<ul>
    <li>One-to-one communication</li>
    <li>Least significant bit of first byte = 0</li>
</ul>

<pre>00:1A:2B:3C:4D:5E</pre>

<h3>2. Multicast</h3>
<ul>
    <li>One-to-many communication</li>
    <li>First byte has LSB = 1</li>
</ul>

<pre>01:00:5E:00:00:FB</pre>

<p>
    Used by protocols like ARP and IPv6 Neighbor Discovery.
</p>

<h3>3. Broadcast</h3>
<ul>
    <li>One-to-all communication</li>
    <li>All bits set to 1</li>
</ul>

<pre>FF:FF:FF:FF:FF:FF</pre>

<p>
    Every device on the LAN listens whether it wants to or not.
</p>

<h2>5. MAC Addressing in an Ethernet Frame</h2>

<p><span class="highlight">Textual Diagram: Ethernet Frame (Relevant Fields)</span></p>

<pre>
+--------------------------------------------------+
| Destination MAC | Source MAC | Type | Data | FCS |
+--------------------------------------------------+
|     6 bytes     |   6 bytes  | 2 B  |      | 4 B |
+--------------------------------------------------+
</pre>

<p>
    MAC addresses live right at the front of the frame.
    No hiding.
</p>

<h2>6. Example: MAC Addressing in Action</h2>

<h3>Network Setup</h3>

<p><span class="highlight">PC A</span></p>
<ul>
    <li>MAC: AA:AA:AA:AA:AA:AA</li>
    <li>IP: 192.168.1.10</li>
</ul>

<p><span class="highlight">PC B</span></p>
<ul>
    <li>MAC: BB:BB:BB:BB:BB:BB</li>
    <li>IP: 192.168.1.20</li>
</ul>

<p>Connected via a switch</p>

<h3>Step 1: Resolve MAC Address (ARP)</h3>

<p>PC A knows the IP, not the MAC.</p>

<pre>
ARP Request:
Destination MAC: FF:FF:FF:FF:FF:FF
"Who has 192.168.1.20?"
</pre>

<p>PC B replies:</p>

<pre>
ARP Reply:
Source MAC: BB:BB:BB:BB:BB:BB
</pre>

<h3>Step 2: Frame Creation (Data Link Layer)</h3>

<pre>
+------------------------------------------------------+
| Dest MAC | Src MAC | Type |      Data      | FCS    |
+------------------------------------------------------+
| BB:BB... | AA:AA.. |  IP  | IP Packet     | CRC    |
+------------------------------------------------------+
</pre>

<h3>Step 3: Frame Forwarding by Switch</h3>

<pre>
PC A -----> Switch -----> PC B
</pre>

<p><span class="highlight">Switch logic:</span></p>
<ul>
    <li>Reads destination MAC</li>
    <li>Looks up MAC table</li>
    <li>Forwards frame to correct port</li>
</ul>

<p>No IP inspection. Switch doesn’t care.</p>

<h3>Step 4: Frame Reception</h3>

<ul>
    <li>PC B checks destination MAC</li>
    <li>Matches its own MAC</li>
    <li>Verifies FCS</li>
    <li>Passes data up the stack</li>
</ul>

<p>Delivered cleanly.</p>

<h2>7. MAC Address vs IP Address</h2>

<table>
    <tr>
        <th>MAC Address</th>
        <th>IP Address</th>
    </tr>
    <tr>
        <td>Physical</td>
        <td>Logical</td>
    </tr>
    <tr>
        <td>Layer 2</td>
        <td>Layer 3</td>
    </tr>
    <tr>
        <td>Fixed (mostly)</td>
        <td>Can change</td>
    </tr>
    <tr>
        <td>Used in LAN</td>
        <td>Used across networks</td>
    </tr>
    <tr>
        <td>Hexadecimal</td>
        <td>Decimal</td>
    </tr>
</table>

<p>
    They solve different problems.
    Confusing them is a common exam disaster.
</p>

<h2>8. Key Points for Exams</h2>

<ul>
    <li>MAC address = 48 bits</li>
    <li>Used at Data Link layer</li>
    <li>Included in frame header</li>
    <li>Required for LAN communication</li>
    <li>Switches forward frames using MAC addresses</li>
</ul>
<h1>1. What is Error Detection?</h1>

<p>
    <span class="highlight">Error detection</span> is the process of identifying whether data has been
    corrupted during transmission due to noise, interference, attenuation, or cosmic rays doing
    whatever they do for fun.
</p>

<p><span class="highlight">Key points:</span></p>
<ul>
    <li>Errors can be detected</li>
    <li>They are usually not corrected at the Data Link layer</li>
    <li>Corrupted frames are discarded</li>
</ul>

<p>Fixing mistakes is someone else’s problem.</p>

<h2>2. Why Error Detection is Needed</h2>

<p>During transmission, bits can flip:</p>

<pre>
Sent:     10110110
Received: 10100110   ← one bit flipped
</pre>

<p>
    Without error detection, the receiver would accept garbage confidently.
    Computers are very good at being wrong with confidence.
</p>

<h2>3. Error Detection at the Data Link Layer</h2>

<p>At Layer 2, error detection is done using:</p>

<ul>
    <li>FCS (Frame Check Sequence)</li>
    <li>Located in the trailer of the frame</li>
    <li>Generated using CRC</li>
    <li>Verified by the receiver</li>
</ul>

<h2>4. Textual Diagram: Frame with Error Detection</h2>

<pre>
+------------------------------------------------------+
| Dest MAC | Src MAC | Type/Length | Data | FCS (CRC) |
+------------------------------------------------------+
</pre>

<p>The FCS protects everything before it.</p>

<h2>5. Cyclic Redundancy Check (CRC)</h2>

<p>
    CRC is the most widely used error detection technique at the Data Link layer.
</p>

<h3>Basic Idea</h3>
<ul>
    <li>Treat data as a binary number</li>
    <li>Divide it by a predefined generator polynomial</li>
    <li>The remainder becomes the CRC</li>
    <li>Receiver repeats the division</li>
</ul>

<p>No, you don’t do polynomial math by hand. Machines suffer so you don’t have to.</p>

<h2>6. CRC Generation: Step-by-Step Example</h2>

<p><span class="highlight">Given:</span></p>
<ul>
    <li>Data: 110101</li>
    <li>Generator: 1011</li>
</ul>

<h3>Step 1: Append Zeros</h3>
<pre>110101000</pre>

<h3>Step 2: Binary Division (XOR)</h3>
<pre>110101000 ÷ 1011</pre>

<p>Assume remainder:</p>
<pre>100</pre>

<h3>Step 3: Transmitted Frame</h3>
<pre>110101100</pre>

<h2>7. Receiver Side Error Detection</h2>

<pre>
Received: 110101100
Divide by: 1011
</pre>

<ul>
    <li>Remainder = 000 → No error</li>
    <li>Remainder ≠ 000 → Error detected</li>
</ul>

<h2>8. Error Detection Failure Example</h2>

<pre>
Sent:     110101100
Received: 110001100
</pre>

<p>Remainder ≠ 000 → Frame discarded. Cold efficiency.</p>

<hr>

<h1>Parity Check</h1>

<h2>1. What is Parity Check?</h2>

<p>
    Parity Check adds one extra bit to make the number of 1s either even or odd.
    One bit trying its best.
</p>

<h2>2. Types of Parity</h2>

<ul>
    <li><span class="highlight">Even Parity</span></li>
    <li><span class="highlight">Odd Parity</span></li>
</ul>

<h2>3. Parity Bit Generation Example</h2>

<pre>
Data: 1011001
Number of 1s = 4
</pre>

<p><span class="highlight">Even Parity:</span> Parity bit = 0</p>
<p><span class="highlight">Odd Parity:</span> Parity bit = 1</p>

<h2>4. Parity Diagram</h2>

<pre>
+-----------------------------+
| Data Bits       | Parity   |
+-----------------------------+
| 1 0 1 1 0 0 1   |    0     |
+-----------------------------+
</pre>

<h2>5. Failure Case</h2>

<pre>
Sent:     10110010
Received: 10010010
</pre>

<p>
    Two-bit error. Parity smiles and waves.
</p>

<h2>6. Limitations of Parity</h2>

<ul>
    <li>Detects only odd number of errors</li>
    <li>Cannot detect burst errors</li>
    <li>Cannot correct errors</li>
    <li>Very weak reliability</li>
</ul>

<hr>

<h1>Checksum</h1>

<h2>1. What is Checksum?</h2>

<p>
    A checksum adds blocks of data together and sends the result.
    The receiver judges silently.
</p>

<h2>2. Where Checksum is Used</h2>

<ul>
    <li>IP</li>
    <li>TCP</li>
    <li>UDP</li>
</ul>

<h2>3. Working Principle</h2>

<ul>
    <li>Divide data into words</li>
    <li>Add using 1’s complement</li>
    <li>Complement the result</li>
    <li>Transmit as checksum</li>
</ul>

<h2>4. Example</h2>

<pre>
Word 1: 10101010
Word 2: 11001100
</pre>

<h3>Addition</h3>
<pre>
10101010
11001100
---------
1 01110110
</pre>

<h3>Wrap-around & Complement</h3>
<pre>
Checksum = 10001000
</pre>

<h2>5. Receiver Verification</h2>

<pre>
Final sum = 11111111 → Accept
</pre>

<h2>6. Limitations</h2>

<ul>
    <li>Weaker than CRC</li>
    <li>May miss multi-bit errors</li>
    <li>No correction</li>
</ul>

<h2>7. Comparison</h2>

<table>
    <tr>
        <th>Technique</th>
        <th>Error Detection Power</th>
        <th>Used Where</th>
    </tr>
    <tr>
        <td>Parity</td>
        <td>Very Weak</td>
        <td>Legacy Systems</td>
    </tr>
    <tr>
        <td>Checksum</td>
        <td>Moderate</td>
        <td>IP, TCP, UDP</td>
    </tr>
    <tr>
        <td>CRC</td>
        <td>Strong</td>
        <td>Ethernet, Wi-Fi</td>
    </tr>
</table>
<h1>1. What is Flow Control?</h1>

<p>
Flow control is a mechanism that ensures a fast sender does not overwhelm a slow receiver by sending
data faster than the receiver can process.
</p>

<p>
It answers one basic question:
</p>

<p><em>“How much data can I send without breaking the other side?”</em></p>

<p>
Without flow control, buffers overflow, frames get dropped, and everyone pretends it’s a “network issue.”
</p>

<h2>2. Why Flow Control Is Needed</h2>

<p><span class="highlight">Consider:</span></p>
<ul>
    <li>Sender: High-speed system</li>
    <li>Receiver: Slower system with limited buffer</li>
</ul>

<p>If the sender keeps transmitting at full speed:</p>
<ul>
    <li>Receiver’s buffer fills up</li>
    <li>Data loss occurs</li>
    <li>Retransmissions increase</li>
    <li>Performance collapses</li>
</ul>

<p>Flow control prevents this polite disaster.</p>

<h2>3. Flow Control at Different Layers</h2>

<ul>
    <li>Data Link Layer: Controls frame transmission between directly connected nodes</li>
    <li>Transport Layer (TCP): Controls end-to-end data flow</li>
</ul>

<p>Here we focus on Data Link Layer flow control.</p>

<h1>4. Flow Control Techniques</h1>

<h2>Stop-and-Wait Flow Control</h2>

<h3>1. Definition</h3>
<p>
Stop-and-Wait Flow Control is a mechanism in which the sender transmits one frame at a time and then
waits for an acknowledgment (ACK) from the receiver before sending the next frame.
</p>

<p>No ACK, no next frame.</p>

<h3>2. Why It Exists</h3>
<ul>
    <li>Prevents receiver buffer overflow</li>
    <li>Ensures sender never sends data faster than the receiver can handle</li>
    <li>Guarantees orderly delivery on unreliable links</li>
</ul>

<h3>3. How It Works (Step-by-Step)</h3>
<ul>
    <li>Sender sends Frame 1</li>
    <li>Sender stops and waits</li>
    <li>Receiver receives the frame</li>
    <li>Receiver sends ACK</li>
    <li>Sender sends Frame 2</li>
</ul>

<h3>4. Textual Diagram</h3>
<pre>
Sender                         Receiver
  |                               |
  |---- Frame 1 ----------------->|
  |                               |
  |<--- ACK 1 --------------------|
  |                               |
  |---- Frame 2 ----------------->|
  |                               |
  |<--- ACK 2 --------------------|
</pre>

<p>Only one frame is ever in transit.</p>

<h3>5. Example</h3>
<p><span class="highlight">Scenario:</span></p>
<ul>
    <li>Sender: Computer A</li>
    <li>Receiver: Computer B</li>
    <li>Link: Slow or unreliable</li>
</ul>

<p><span class="highlight">Process:</span></p>
<ul>
    <li>A sends Frame 1</li>
    <li>B processes it and sends ACK</li>
    <li>A sends Frame 2 only after receiving ACK</li>
</ul>

<p>If ACK is lost:</p>
<ul>
    <li>Sender waits</li>
    <li>Timeout occurs</li>
    <li>Frame is retransmitted</li>
</ul>

<h3>6. Handling Errors</h3>
<p>Each frame has a sequence number (usually 0 or 1).</p>

<pre>
Frame 0 → ACK 0
Frame 1 → ACK 1
</pre>

<h3>7. Advantages</h3>
<ul>
    <li>Easy to implement</li>
    <li>Reliable delivery</li>
    <li>No receiver overflow</li>
    <li>Good for short or noisy links</li>
</ul>

<h3>8. Disadvantages</h3>
<ul>
    <li>Very inefficient</li>
    <li>Wastes bandwidth</li>
    <li>High latency on fast links</li>
    <li>Poor performance on long-distance networks</li>
</ul>

<h3>9. Where It Is Used</h3>
<ul>
    <li>Data Link layer protocols</li>
    <li>Simple communication systems</li>
    <li>Conceptual base for advanced protocols</li>
</ul>

<h1>Sliding Window Flow Control</h1>

<h2>1. What is Sliding Window Flow Control?</h2>
<p>
Sliding Window Flow Control allows the sender to transmit multiple frames before receiving
acknowledgements, limited by a window size specified by the receiver.
</p>

<p>
Sender can send N frames without waiting, where N = window size.
</p>

<h2>2. Why Sliding Window Is Needed</h2>
<ul>
    <li>Stop-and-Wait wastes time</li>
    <li>Sliding Window keeps the link busy</li>
</ul>

<h2>3. Basic Terminology</h2>
<ul>
    <li>Window Size (W)</li>
    <li>Sequence Number</li>
    <li>ACK</li>
    <li>Send Window</li>
    <li>Receive Window</li>
</ul>

<h2>4. How Sliding Window Works</h2>
<ul>
    <li>Sender transmits frames within window</li>
    <li>Receiver sends ACKs</li>
    <li>Window slides forward</li>
    <li>New frames are sent</li>
</ul>

<h2>5. Textual Diagram</h2>
<pre>
Window size = 4

Sender                              Receiver
  |                                   |
  |---- Frame 1 --------------------->|
  |---- Frame 2 --------------------->|
  |---- Frame 3 --------------------->|
  |---- Frame 4 --------------------->|
  |                                   |
  |<--- ACK 1 ------------------------|
  |---- Frame 5 --------------------->|
  |                                   |
  |<--- ACK 2 ------------------------|
  |---- Frame 6 --------------------->|
</pre>

<h2>6. Example with Numbers</h2>
<pre>
Window size = 3
Send window: [0, 1, 2]

After ACK 0:
Send window: [1, 2, 3]
</pre>

<h1>Go-Back-N (GBN)</h1>

<h2>1. What is Go-Back-N?</h2>
<p>
Go-Back-N is a sliding window ARQ protocol where the sender retransmits a frame and all subsequent
frames if an error occurs.
</p>

<h2>2. Key Characteristics</h2>
<ul>
    <li>Sender window size = N</li>
    <li>Receiver window size = 1</li>
    <li>Cumulative acknowledgements</li>
    <li>Timeout-based retransmission</li>
</ul>

<h2>3. Error Case Diagram</h2>
<pre>
Window size = 4
Frame 2 lost

Sender                                   Receiver
  |---- Frame 0 ----------------------->|
  |---- Frame 1 ----------------------->|
  |---- Frame 2 ----X                   |
  |---- Frame 3 ----------------------->| (discarded)
  |<--- ACK 1 --------------------------|
  |        timeout                      |
  |---- Frame 2 ----------------------->|
  |---- Frame 3 ----------------------->|
  |<--- ACK 3 --------------------------|
</pre>

<h2>4. Advantages</h2>
<ul>
    <li>Simple receiver</li>
    <li>Better than Stop-and-Wait</li>
</ul>

<h2>5. Disadvantages</h2>
<ul>
    <li>Wasted bandwidth</li>
    <li>Poor performance on noisy links</li>
</ul>

<h1>Selective Repeat (SR)</h1>

<h2>1. What is Selective Repeat?</h2>
<p>
Selective Repeat allows retransmission of only lost or corrupted frames while buffering
out-of-order frames.
</p>

<h2>2. Working Diagram</h2>
<pre>
Sender                                   Receiver
  |---- Frame 0 ----------------------->|
  |---- Frame 1 ----------------------->|
  |---- Frame 2 ---X                   |
  |---- Frame 3 ----------------------->|
  |<--- ACK 0 --------------------------|
  |<--- ACK 1 --------------------------|
  |<--- ACK 3 --------------------------| (buffered)
  |---- Frame 2 ----------------------->|
  |<--- ACK 2 --------------------------|
</pre>

<h2>3. Window Size Rule</h2>
<p>
Window Size ≤ (Sequence Number Space) / 2
</p>

<h2>4. Advantages</h2>
<ul>
    <li>Efficient bandwidth usage</li>
    <li>Better performance on noisy links</li>
</ul>

<h2>5. Disadvantages</h2>
<ul>
    <li>Complex logic</li>
    <li>Large buffer requirement</li>
</ul>

<h1>5. Flow Control in Ethernet</h1>
<ul>
    <li>Classic Ethernet has no flow control</li>
    <li>IEEE 802.3x PAUSE frames provide optional flow control</li>
</ul>

<h1>6. Flow Control vs Congestion Control</h1>

<table>
    <tr>
        <th>Flow Control</th>
        <th>Congestion Control</th>
    </tr>
    <tr>
        <td>Sender vs Receiver</td>
        <td>Network-wide</td>
    </tr>
    <tr>
        <td>Prevents buffer overflow</td>
        <td>Prevents network overload</td>
    </tr>
    <tr>
        <td>Data Link / Transport Layer</td>
        <td>Mainly Transport Layer</td>
    </tr>
    <tr>
        <td>Receiver-driven</td>
        <td>Network-driven</td>
    </tr>
</table>

<h1>7. Real-World Example</h1>
<ul>
    <li>Switch port connected to a slow device</li>
    <li>Device sends PAUSE frame</li>
    <li>Switch pauses transmission</li>
    <li>Data loss avoided</li>
</ul>
<h1>1. What is Access Control?</h1>

<p>
    <span class="highlight">Access Control</span> at the Data Link layer is the mechanism that decides
    which device can transmit data on a shared communication medium and when.
</p>

<p>
    Because if everyone transmits whenever they feel like it, you don’t get data.
    You get noise.
</p>

<p>
    This function is handled by the <span class="highlight">MAC (Media Access Control)</span> sublayer
    of Layer 2.
</p>

<h2>2. Why Access Control Is Needed</h2>

<p><span class="highlight">On a shared medium:</span></p>

<ul>
    <li>Multiple devices use the same cable or wireless channel</li>
    <li>Simultaneous transmission causes collisions</li>
    <li>Collisions corrupt data</li>
</ul>

<p><span class="highlight">Access control exists to:</span></p>

<ul>
    <li>Minimize collisions</li>
    <li>Coordinate transmission</li>
    <li>Ensure fair usage of the medium</li>
</ul>
<h1>1. What is CSMA/CD?</h1>

<p>
    <span class="highlight">CSMA/CD</span> (Carrier Sense Multiple Access with Collision Detection)
    is a media access control protocol used in wired Ethernet to control how multiple devices
    share the same communication medium.
</p>

<p>
    It operates at the <span class="highlight">MAC sublayer</span> of the Data Link layer (Layer 2).
</p>

<p>
    Its core idea is simple:
</p>

<ul>
    <li>Devices try to transmit</li>
    <li>Collisions are detected</li>
    <li>Transmission is retried later</li>
</ul>

<h2>2. Why CSMA/CD Is Needed</h2>

<p>
    In shared Ethernet environments such as:
</p>

<ul>
    <li>Bus topology</li>
    <li>Hub-based Ethernet</li>
    <li>Half-duplex links</li>
</ul>

<p>
    Multiple devices are connected to the same cable.
    If two transmit at the same time, a collision occurs and data is corrupted.
</p>

<p><span class="highlight">CSMA/CD exists to:</span></p>

<ul>
    <li>Detect collisions quickly</li>
    <li>Stop transmission immediately</li>
    <li>Reduce wasted bandwidth</li>
    <li>Retry transmission intelligently</li>
</ul>

<h2>3. Breaking Down CSMA/CD</h2>

<h3>1. Carrier Sense</h3>
<ul>
    <li>Device listens to the medium before transmitting</li>
    <li>If channel is busy → wait</li>
    <li>If channel is idle → transmit</li>
</ul>

<h3>2. Multiple Access</h3>
<ul>
    <li>Many devices share the same medium</li>
    <li>No central controller</li>
    <li>All devices follow the same access rules</li>
</ul>

<h3>3. Collision Detection</h3>
<ul>
    <li>Device monitors the signal while transmitting</li>
    <li>If signal changes unexpectedly → collision detected</li>
    <li>Possible only in wired Ethernet</li>
</ul>

<h2>4. Working of CSMA/CD (Step-by-Step)</h2>

<ul>
    <li>Node senses the channel</li>
    <li>If idle → starts transmitting</li>
    <li>If collision detected:</li>
    <ul>
        <li>Stops transmitting</li>
        <li>Sends a jam signal</li>
        <li>Waits for a random backoff time</li>
        <li>Retries transmission</li>
    </ul>
</ul>

<p>
    This continues until transmission succeeds or the retry limit is reached.
</p>

<h2>5. Binary Exponential Backoff</h2>

<ul>
    <li>After 1st collision → wait 0 or 1 slot</li>
    <li>After 2nd collision → wait 0–3 slots</li>
    <li>After <em>n</em> collisions → wait 0–(2<sup>n</sup> − 1) slots</li>
    <li>Maximum retries = 16</li>
    <li>Slot time = 512 bit times</li>
</ul>

<p>
    If transmission fails after 16 attempts, the frame is dropped.
</p>

<h2>6. Textual Diagram: CSMA/CD Collision</h2>

<pre>
Time →
Host A:  |----Transmit-------X------Wait------Retry---->
Host B:        |----Transmit------X------Wait-----Retry->
Medium: =======Collision Detected======================
</pre>

<h2>7. Textual Diagram: Successful Transmission</h2>

<pre>
Time →
Host A:  |----Transmit------------------------------>|
Host B:       |---Wait------------------------------>|
Medium: =======Busy=====================Idle=========
</pre>

<h2>8. Example Scenario</h2>

<h3>Network Setup</h3>

<pre>
PC1 ---\
PC2 ---- HUB ---- LAN
PC3 ---/
</pre>

<ul>
    <li>Half-duplex Ethernet</li>
    <li>PC1, PC2, PC3 connected to a hub</li>
</ul>

<h3>Event</h3>

<ul>
    <li>PC1 and PC2 sense idle channel</li>
    <li>Both transmit simultaneously</li>
    <li>Collision occurs at hub</li>
    <li>Jam signal sent</li>
    <li>PC1 waits 1 slot</li>
    <li>PC2 waits 2 slots</li>
    <li>PC1 retransmits successfully</li>
</ul>

<h2>9. Where CSMA/CD Is Used (and Not Used)</h2>

<h3>Used In</h3>
<ul>
    <li>10Base-T Ethernet with hubs</li>
    <li>Half-duplex Ethernet</li>
</ul>

<h3>Not Used In</h3>
<ul>
    <li>Switched Ethernet</li>
    <li>Full-duplex links</li>
    <li>Wi-Fi (uses CSMA/CA)</li>
</ul>

<p>
    Modern switches eliminate collisions entirely, making CSMA/CD mostly historical.
    Unfortunately, exams still care.
</p>
<h1>1. What is CSMA/CA?</h1>

<p>
    <span class="highlight">CSMA/CA</span> (Carrier Sense Multiple Access with Collision Avoidance)
    is a media access control protocol used in wireless networks (IEEE 802.11) to reduce
    the chances of collisions before transmission.
</p>

<p><span class="highlight">Key idea:</span></p>
<ul>
    <li>Wired Ethernet detects collisions</li>
    <li>Wireless cannot reliably detect collisions</li>
    <li>So it avoids them instead</li>
</ul>

<h2>2. Why Collision Detection Does Not Work in Wireless</h2>

<p>In wireless networks:</p>
<ul>
    <li>A node cannot transmit and listen at the same time</li>
    <li>Signal strength varies with distance</li>
    <li>Collisions may occur at the receiver, not the sender</li>
</ul>

<p>
    This is called the <span class="highlight">hidden node problem</span>.
</p>

<h2>3. Basic Working Principle of CSMA/CA</h2>

<p>CSMA/CA uses:</p>
<ul>
    <li>Carrier sensing</li>
    <li>Random backoff</li>
    <li>Acknowledgements (ACKs)</li>
    <li>Optional RTS/CTS mechanism</li>
</ul>

<h2>4. Step-by-Step Operation</h2>

<h3>Step 1: Carrier Sensing</h3>
<ul>
    <li>The station listens to the channel</li>
    <li>If busy → wait</li>
    <li>If idle → proceed</li>
</ul>

<h3>Step 2: Inter-Frame Space (IFS)</h3>
<p>
    Even if idle, the station waits a short fixed time:
</p>
<ul>
    <li>DIFS (Distributed IFS) for normal data</li>
</ul>

<p>This prevents unfair access.</p>

<h3>Step 3: Random Backoff</h3>
<ul>
    <li>Station selects a random backoff time</li>
    <li>Countdown decreases only when channel is idle</li>
    <li>When backoff reaches zero → transmit</li>
</ul>

<p>This randomness prevents simultaneous transmission.</p>

<h3>Step 4: Data Transmission</h3>
<p>Frame is transmitted to the receiver.</p>

<h3>Step 5: Acknowledgement (ACK)</h3>
<ul>
    <li>Receiver sends ACK after SIFS</li>
    <li>If ACK not received → assume collision → retry</li>
</ul>

<h2>5. Textual Diagram: Basic CSMA/CA Operation</h2>

<pre>
Time →
Station A:  Sense | DIFS | Backoff | DATA -------->
Station B:  Sense | DIFS | Backoff(wait) --------->
Receiver:                         <---- ACK -----
Channel:     Idle       Busy
</pre>

<p>
    Only one station reaches backoff zero first. The other waits.
</p>

<h2>6. RTS/CTS Mechanism (Optional but Important)</h2>

<p>
    Used to solve the <span class="highlight">hidden node problem</span>.
</p>

<h3>Hidden Node Scenario</h3>

<pre>
A -----> B <----- C
   (A and C cannot hear each other)
</pre>

<p>
    Without RTS/CTS, A and C may transmit together and collide at B.
</p>

<h3>RTS/CTS Process</h3>
<ul>
    <li>Sender sends RTS (Request to Send)</li>
    <li>Receiver replies with CTS (Clear to Send)</li>
    <li>Other stations hearing CTS stay silent</li>
    <li>Data is transmitted</li>
    <li>ACK is sent</li>
</ul>

<h2>7. Textual Diagram: RTS/CTS</h2>

<pre>
Sender (A)        Receiver (B)        Other Node (C)
   |--- RTS ----->|
   |<-- CTS ------|
   |--- DATA ---->|
   |<-- ACK ------|
                      (C stays silent)
</pre>

<p>RTS/CTS reserves the channel.</p>

<h2>8. Example: CSMA/CA in a Wi-Fi Network</h2>

<p><span class="highlight">Scenario:</span></p>
<ul>
    <li>Laptop A</li>
    <li>Laptop B</li>
    <li>Access Point</li>
</ul>

<p>Both laptops want to send data.</p>

<p><span class="highlight">What happens:</span></p>
<ul>
    <li>Both sense the channel idle</li>
    <li>Both wait DIFS</li>
    <li>A chooses backoff = 3 slots</li>
    <li>B chooses backoff = 7 slots</li>
    <li>A reaches zero first → transmits</li>
    <li>AP sends ACK</li>
    <li>B resumes countdown after channel becomes idle</li>
</ul>

<p>Collision avoided without detection.</p>

<h2>9. Advantages of CSMA/CA</h2>

<ul>
    <li>Reduces collisions in wireless</li>
    <li>Handles hidden node problem</li>
    <li>Efficient for shared radio medium</li>
</ul>

<h2>10. Limitations</h2>

<ul>
    <li>Overhead due to RTS/CTS and ACK</li>
    <li>Not collision-free, only collision-reducing</li>
    <li>Performance drops in dense networks</li>
</ul>
<h1>1. What is Token Passing?</h1>

<p>
    <span class="highlight">Token Passing</span> is a Media Access Control (MAC) method used at the
    Data Link layer where a special control frame called a <span class="highlight">token</span>
    circulates among devices.
</p>

<p>
    Only the device holding the token is allowed to transmit data.
</p>

<p>
    No token, no talking. Simple rule. Very strict household.
</p>

<h2>2. Why Token Passing Exists</h2>

<p>Token passing was designed to:</p>
<ul>
    <li>Eliminate collisions</li>
    <li>Provide deterministic access</li>
    <li>Guarantee fairness</li>
</ul>

<p>
    Unlike Ethernet’s “talk when you feel like it” model, token passing schedules access.
</p>

<h2>3. Where Token Passing Is Used</h2>

<ul>
    <li>Token Ring (IEEE 802.5)</li>
    <li>FDDI (Fiber Distributed Data Interface)</li>
</ul>

<p>
    Mostly historical now, but still relevant in theory and exams.
</p>

<h2>4. How Token Passing Works (Step-by-Step)</h2>

<ul>
    <li>A token frame circulates continuously in a logical ring</li>
    <li>Each station checks the token</li>
    <li>If a station has data to send:</li>
</ul>

<ul>
    <li>It captures the token</li>
    <li>Converts it into a data frame</li>
    <li>Data frame travels around the ring</li>
    <li>Destination copies the data</li>
    <li>Frame returns to sender</li>
    <li>Sender removes frame and releases a new token</li>
</ul>

<p>
    Very organized. Almost suspiciously so.
</p>

<h2>5. Structure of a Token Ring (Logical Ring)</h2>

<p>
    Even if physically star-wired, it behaves like a ring.
</p>

<h3>Textual Diagram: Logical Ring</h3>

<pre>
[Host A] → [Host B] → [Host C] → [Host D]
    ↑                                   ↓
    ←────────── Token Circulation ──────←
</pre>

<h2>6. Example: Token Passing in Action</h2>

<p><span class="highlight">Scenario:</span></p>
<p>Four computers connected in a token ring network: A, B, C, D</p>

<p>Token starts at A</p>

<h3>Step-by-Step Flow</h3>

<h4>Step 1: Token at A</h4>
<ul>
    <li>A has no data</li>
    <li>Passes token to B</li>
</ul>

<p>Token → B</p>

<h4>Step 2: Token at B</h4>
<ul>
    <li>B has data to send</li>
    <li>Captures token</li>
    <li>Sends data frame</li>
</ul>

<pre>
B → Data Frame → C → D → A → B
</pre>

<h4>Step 3: Data Delivery</h4>
<ul>
    <li>C is destination</li>
    <li>C copies data</li>
    <li>Frame continues circulating</li>
</ul>

<h4>Step 4: Token Release</h4>
<ul>
    <li>Frame returns to B</li>
    <li>B removes frame</li>
    <li>Generates a new token</li>
</ul>

<p>Token → C</p>

<p>Order restored.</p>

<h2>7. Textual Diagram: Token Capture and Release</h2>

<pre>
Token
  ↓
[ A ] → [ B ] → [ C ] → [ D ]
           |
        (Captures)
           |
     Data Frame Circulates
</pre>

<h2>8. Advantages of Token Passing</h2>

<ul>
    <li>No collisions</li>
    <li>Predictable delay</li>
    <li>Fair access (every node gets a turn)</li>
    <li>Good for real-time systems</li>
</ul>

<h2>9. Disadvantages of Token Passing</h2>

<ul>
    <li>Token loss breaks communication</li>
    <li>Single node failure can disrupt ring</li>
    <li>Slower under light load</li>
    <li>Complex management</li>
</ul>

<p>
    Ethernet survived because chaos scaled better than order.
</p>

<h2>10. Token Passing vs Ethernet (Quick Contrast)</h2>

<table>
    <tr>
        <th>Feature</th>
        <th>Token Passing</th>
        <th>Ethernet</th>
    </tr>
    <tr>
        <td>Collisions</td>
        <td>None</td>
        <td>Possible</td>
    </tr>
    <tr>
        <td>Access Method</td>
        <td>Token-based</td>
        <td>CSMA</td>
    </tr>
    <tr>
        <td>Delay</td>
        <td>Predictable</td>
        <td>Random</td>
    </tr>
    <tr>
        <td>Status</td>
        <td>Obsolete</td>
        <td>Dominant</td>
    </tr>
</table>
<h1>4. Example: Access Control in Ethernet LAN</h1>

<h2>Scenario</h2>

<p>Three PCs connected via a hub (shared medium):</p>

<pre>
PC1 ----\
PC2 ----- HUB ---- Internet
PC3 ----/
</pre>

<h3>What Happens</h3>

<ul>
    <li>PC1 senses channel → idle → starts transmitting</li>
    <li>PC2 senses channel → busy → waits</li>
    <li>PC3 senses channel → busy → waits</li>
</ul>

<p><span class="highlight">If PC2 and PC3 transmit at the same time:</span></p>

<ul>
    <li>Collision occurs</li>
    <li>Both stop transmitting</li>
    <li>Random backoff time is applied</li>
    <li>Retry later</li>
</ul>

<p>
    Access control prevents chaos by enforcing patience on devices
    sharing the same medium.
</p>

<h1>5. Access Control in Switched Ethernet</h1>

<p>
    Modern Ethernet networks use <span class="highlight">switches</span>, not hubs.
</p>

<ul>
    <li>Each switch port is a separate collision domain</li>
    <li>Full-duplex communication</li>
    <li>No collisions</li>
    <li>CSMA/CD is effectively disabled</li>
</ul>

<p>
    Access control still exists logically, but collisions are no longer
    a practical concern because switches isolate traffic.
</p>

<h1>6. Comparison Summary</h1>

<table>
    <tr>
        <th>Method</th>
        <th>Medium</th>
        <th>Collisions</th>
        <th>Usage Status</th>
    </tr>
    <tr>
        <td>CSMA/CD</td>
        <td>Wired</td>
        <td>Detects</td>
        <td>Legacy</td>
    </tr>
    <tr>
        <td>CSMA/CA</td>
        <td>Wireless</td>
        <td>Avoids</td>
        <td>Active</td>
    </tr>
    <tr>
        <td>Token Passing</td>
        <td>Wired</td>
        <td>None</td>
        <td>Obsolete</td>
    </tr>
</table>
<h1>Why the Data Link Layer Has Sub-layers</h1>

<p>
    The Data Link Layer was split by IEEE to:
</p>

<ul>
    <li>Separate media access details from upper-layer coordination</li>
    <li>Allow multiple network layer protocols to run over the same hardware</li>
    <li>Keep Ethernet, Wi-Fi, and other technologies sane</li>
</ul>

<p>
    As a result, Layer 2 is divided into two sub-layers:
</p>

<ul>
    <li>Logical Link Control (LLC)</li>
    <li>Media Access Control (MAC)</li>
</ul>

<h2>1. What is the LLC Sub-layer?</h2>

<p>
    The <span class="highlight">Logical Link Control (LLC)</span> sub-layer is the upper sub-layer of the
    Data Link Layer (Layer 2), defined by <span class="highlight">IEEE 802.2</span>.
</p>

<p>
    Its main role is to act as a bridge between the Network layer (Layer 3) and the MAC sub-layer,
    ensuring the correct network protocol receives the correct data.
</p>

<p><span class="highlight">In short:</span></p>

<p>
    LLC identifies the type of data inside the frame and provides optional control mechanisms.
</p>

<h2>2. Position of LLC in the OSI Model</h2>

<pre>
+----------------------+
| Network Layer (L3)   |  ← IP, ARP
+----------------------+
| Logical Link Control |
|        (LLC)         |
+----------------------+
| Media Access Control |
|        (MAC)         |
+----------------------+
| Physical Layer (L1)  |
+----------------------+
</pre>

<p>
    LLC is software-oriented and independent of the physical network technology.
</p>

<h2>3. Why LLC Is Needed</h2>

<p><span class="highlight">Without LLC:</span></p>

<ul>
    <li>The receiver would not know whether the payload contains IP, ARP, or something else</li>
    <li>Multiple network protocols could not share the same MAC layer cleanly</li>
</ul>

<p><span class="highlight">LLC solves this by:</span></p>

<ul>
    <li>Multiplexing protocols</li>
    <li>Providing a standardized interface to Layer 3</li>
</ul>

<h2>4. Functions of the LLC Sub-layer</h2>

<h3>1. Protocol Identification (Multiplexing)</h3>

<p>
    LLC identifies which Layer 3 protocol the frame carries using:
</p>

<ul>
    <li>DSAP (Destination Service Access Point)</li>
    <li>SSAP (Source Service Access Point)</li>
</ul>

<p><span class="highlight">Example:</span></p>

<pre>
DSAP = IP
SSAP = IP
</pre>

<h3>2. Flow Control (Optional)</h3>

<ul>
    <li>Prevents sender from overwhelming receiver</li>
    <li>Uses acknowledgments in some LLC service types</li>
</ul>

<p>
    Ethernet usually skips this and lets TCP handle the suffering.
</p>

<h3>3. Error Control (Optional)</h3>

<ul>
    <li>Detects and may recover from errors</li>
    <li>Uses sequence numbers and acknowledgments</li>
</ul>

<h3>4. Interface to the Network Layer</h3>

<ul>
    <li>Provides a consistent interface for IP across Ethernet, Wi-Fi, and others</li>
</ul>

<h2>5. LLC Frame Format</h2>

<pre>
+-------------------------------+
| DSAP | SSAP | Control | Data |
+-------------------------------+
</pre>

<ul>
    <li>DSAP (1 byte) → Destination protocol</li>
    <li>SSAP (1 byte) → Source protocol</li>
    <li>Control (1–2 bytes) → Flow & error control</li>
    <li>Data → Network layer packet (IP, ARP, etc.)</li>
</ul>

<p>
    This LLC PDU becomes the payload of the MAC frame.
</p>

<h2>6. Example: IP Communication Over Ethernet Using LLC</h2>

<p><span class="highlight">Scenario:</span></p>
<p>Host A sends IP data to Host B on the same LAN.</p>

<h3>Step 1: Network Layer (L3)</h3>

<pre>
[ IP Header | IP Data ]
</pre>

<h3>Step 2: LLC Sub-layer</h3>

<pre>
+--------------------------------------+
| DSAP=IP | SSAP=IP | Control | IP Pkt |
+--------------------------------------+
</pre>

<h3>Step 3: MAC Sub-layer</h3>

<pre>
+--------------------------------------------------+
| Dest MAC | Src MAC | LLC | Data | FCS           |
+--------------------------------------------------+
</pre>

<h3>Step 4: Transmission</h3>

<p>
    Physical layer sends bits. Receiver:
</p>

<ul>
    <li>MAC checks FCS</li>
    <li>LLC reads DSAP/SSAP</li>
    <li>Data passed to IP</li>
</ul>

<p>
    Correct protocol gets correct data. No guessing.
</p>

<h2>7. LLC Service Types</h2>

<ul>
    <li><span class="highlight">Type 1:</span> Unacknowledged connectionless (most common)</li>
    <li><span class="highlight">Type 2:</span> Connection-oriented (rare in Ethernet)</li>
    <li><span class="highlight">Type 3:</span> Acknowledged connectionless (almost extinct)</li>
</ul>

<h2>8. Real-World Reality</h2>

<ul>
    <li>LLC exists logically in modern Ethernet</li>
    <li>Protocol identification is usually done via EtherType</li>
    <li>LLC remains important for concepts and exams</li>
</ul>

<p>
    Reality cheated the theory. Networking does that.
</p>
<h1>1. IP Traffic</h1>

<h2>What it is</h2>
<p>
    <span class="highlight">IP traffic</span> is data carried by the Internet Protocol (IP),
    which operates at the Network layer (Layer 3).
</p>

<p><span class="highlight">Its job:</span></p>
<ul>
    <li>Logical addressing using IP addresses</li>
    <li>Packet routing across networks</li>
    <li>Best-effort delivery</li>
</ul>

<p>
    IP does not care about MAC addresses. That’s someone else’s mess.
</p>

<h2>Example of IP Traffic</h2>

<p>When you open a website:</p>
<pre>
HTTP request → TCP segment → IP packet
</pre>

<p>
    That IP packet becomes the payload inside an Ethernet frame.
</p>

<p>IP Packet (simplified):</p>
<pre>
| IP Header | TCP/UDP Header | Application Data |
</pre>

<h2>How IP Traffic Is Carried on Ethernet</h2>

<pre>
+----------------------------------------------------+
| Dest MAC | Src MAC | Type = 0x0800 | IP Packet | FCS |
+----------------------------------------------------+
</pre>

<ul>
    <li>EtherType <span class="highlight">0x0800</span> → IPv4</li>
    <li>MAC sub-layer handles delivery on the LAN</li>
    <li>IP handles delivery across networks</li>
</ul>

<h1>2. ARP Traffic</h1>

<h2>What it is</h2>
<p>
    <span class="highlight">ARP (Address Resolution Protocol)</span> maps an IP address
    to a MAC address.
</p>

<p>
    It lives in a weird no-man’s-land:
</p>
<ul>
    <li>Works between Layer 2 and Layer 3</li>
    <li>Encapsulated directly in an Ethernet frame</li>
    <li>Not carried inside an IP packet</li>
</ul>

<p>
    ARP exists because IP refuses to learn MAC addresses.
</p>

<h2>When ARP Traffic Occurs</h2>

<p>ARP is used when:</p>
<ul>
    <li>A device wants to send an IP packet</li>
    <li>It knows the destination IP</li>
    <li>It does not know the destination MAC</li>
</ul>

<h2>ARP Packet Structure (Simplified)</h2>

<pre>
| Hardware Type | Protocol Type | Opcode |
| Sender MAC | Sender IP |
| Target MAC | Target IP |
</pre>

<h3>ARP Request (Broadcast)</h3>

<pre>
Who has 192.168.1.20?
Tell 192.168.1.10
</pre>

<p>Ethernet frame:</p>
<pre>
Dest MAC: FF:FF:FF:FF:FF:FF
Src MAC : AA:AA:AA:AA:AA:AA
Type    : 0x0806 (ARP)
</pre>

<h3>ARP Reply (Unicast)</h3>

<pre>
192.168.1.20 is at BB:BB:BB:BB:BB:BB
</pre>

<h2>3. Textual Diagram: IP vs ARP on Ethernet</h2>

<pre>
                Ethernet Frame
+----------------------------------------------------+
| Dest MAC | Src MAC | Type | Payload | FCS          |
+----------------------------------------------------+
                         |
          +--------------+--------------+
          |                             |
       IP Packet                      ARP Packet
   (Type = 0x0800)               (Type = 0x0806)
</pre>

<h2>4. Key Differences: IP Traffic vs ARP Traffic</h2>

<table>
    <tr>
        <th>Feature</th>
        <th>IP Traffic</th>
        <th>ARP Traffic</th>
    </tr>
    <tr>
        <td>OSI Layer</td>
        <td>Layer 3</td>
        <td>Between L2 & L3</td>
    </tr>
    <tr>
        <td>Purpose</td>
        <td>Data delivery</td>
        <td>IP → MAC mapping</td>
    </tr>
    <tr>
        <td>Encapsulation</td>
        <td>Inside Ethernet frame</td>
        <td>Directly in Ethernet frame</td>
    </tr>
    <tr>
        <td>Broadcast</td>
        <td>No (usually)</td>
        <td>Yes (ARP request)</td>
    </tr>
    <tr>
        <td>EtherType</td>
        <td>0x0800</td>
        <td>0x0806</td>
    </tr>
</table>

<h2>5. How They Work Together (Real Flow)</h2>

<ul>
    <li>Application generates data</li>
    <li>IP packet is created</li>
    <li>ARP runs first (if MAC unknown)</li>
    <li>MAC address resolved</li>
    <li>IP traffic is sent using Ethernet frames</li>
</ul>

<p>
    ARP is the awkward handshake before IP traffic can happen.
</p>
<h1>1. What is the MAC Sub-layer?</h1>

<p>
    The <span class="highlight">Media Access Control (MAC)</span> sub-layer is the lower sub-layer of
    the Data Link Layer (Layer 2).
    It is responsible for how devices access the shared transmission medium and how frames are
    addressed, transmitted, and checked for errors.
</p>

<p>
    If LLC is the polite receptionist, MAC is the traffic cop standing in the middle of the road.
</p>

<h2>2. Position in the OSI Model</h2>

<pre>
+----------------------+
| Network Layer (L3)   |
+----------------------+
| Logical Link Control |
|        (LLC)         |
+----------------------+
| Media Access Control |
|        (MAC)         |  <-- This layer
+----------------------+
| Physical Layer (L1)  |
+----------------------+
</pre>

<h2>3. Major Functions of the MAC Sub-layer</h2>

<h3>1. MAC Addressing</h3>
<ul>
    <li>Uses 48-bit physical (MAC) addresses</li>
    <li>Each NIC has a unique MAC address</li>
    <li>Adds source and destination MAC to every frame</li>
</ul>

<p><span class="highlight">Example:</span></p>
<pre>
Source MAC:      00:14:22:01:23:45
Destination MAC: 08:00:27:AA:BB:CC
</pre>

<h3>2. Framing</h3>
<ul>
    <li>Encapsulates Network layer packets into frames</li>
    <li>Adds header and trailer</li>
</ul>

<p>Ethernet Frame (MAC level):</p>
<pre>
+--------------------------------------------------+
| Dest MAC | Src MAC | Type | Data | FCS          |
+--------------------------------------------------+
</pre>

<h3>3. Media Access Control</h3>
<ul>
    <li>Determines when a device can transmit</li>
    <li>Prevents collisions on shared media</li>
</ul>

<p><span class="highlight">Access Methods:</span></p>
<ul>
    <li>CSMA/CD – Ethernet (legacy wired LANs)</li>
    <li>CSMA/CA – Wi-Fi (wireless LANs)</li>
</ul>

<h3>4. Error Detection</h3>
<ul>
    <li>Adds Frame Check Sequence (FCS)</li>
    <li>Uses CRC</li>
    <li>Detects transmission errors</li>
</ul>

<p>If CRC fails → frame discarded.</p>

<h2>4. MAC Access Methods Explained</h2>

<h3>A. CSMA/CD (Ethernet)</h3>
<ul>
    <li>Carrier Sense Multiple Access with Collision Detection</li>
</ul>

<p><span class="highlight">Steps:</span></p>
<ul>
    <li>Sense the medium</li>
    <li>If free → transmit</li>
    <li>If collision → stop, wait random time, retry</li>
</ul>

<p>Used in half-duplex Ethernet. Largely obsolete now.</p>

<h3>B. CSMA/CA (Wi-Fi)</h3>
<ul>
    <li>Carrier Sense Multiple Access with Collision Avoidance</li>
</ul>

<p><span class="highlight">Steps:</span></p>
<ul>
    <li>Check channel</li>
    <li>Wait random backoff time</li>
    <li>Use RTS/CTS (optional)</li>
    <li>Transmit data</li>
</ul>

<p>
    Because wireless can’t detect collisions, it avoids them instead.
</p>

<h2>5. Textual Diagram: Frame Creation at MAC Layer</h2>

<pre>
IP Packet
   |
   v
+--------------------------------------------------+
| Dest MAC | Src MAC | Type | IP Packet | FCS     |
+--------------------------------------------------+
                ^
                |
           MAC Sub-layer
</pre>

<h2>6. Practical Example: Ethernet Communication</h2>

<p><span class="highlight">Scenario:</span></p>
<ul>
    <li>PC A MAC: AA:AA:AA:AA:AA:AA</li>
    <li>PC B MAC: BB:BB:BB:BB:BB:BB</li>
    <li>Connected via a switch</li>
</ul>

<h3>Step-by-Step Flow</h3>

<h4>Step 1: MAC Address Resolution</h4>
<p>PC A uses ARP to find PC B’s MAC address.</p>

<h4>Step 2: Frame Construction (MAC Sub-layer)</h4>
<pre>
Destination MAC: BB:BB:BB:BB:BB:BB
Source MAC:      AA:AA:AA:AA:AA:AA
Type:            IP
Payload:         IP Packet
FCS:             CRC
</pre>

<h4>Step 3: Medium Access</h4>
<ul>
    <li>MAC checks if medium is free</li>
    <li>Applies CSMA/CD rules</li>
    <li>Transmits frame</li>
</ul>

<h4>Step 4: Reception</h4>
<ul>
    <li>PC B receives frame</li>
    <li>Checks FCS</li>
    <li>Extracts IP packet</li>
    <li>Passes it to Network layer</li>
</ul>

<p>Node-to-node delivery complete.</p>

<h2>7. Devices Working at MAC Sub-layer</h2>
<ul>
    <li>Network Interface Card (NIC)</li>
    <li>Switch</li>
    <li>Bridge</li>
</ul>

<p>Switches forward frames using MAC address tables.</p>

<h2>8. What MAC Sub-layer Does NOT Do</h2>
<ul>
    <li>No IP addressing</li>
    <li>No routing</li>
    <li>No path selection</li>
    <li>No end-to-end reliability</li>
</ul>

<p>That chaos belongs to higher layers.</p>
<h2>4. Textual Diagram: Sub-layers of Data Link Layer</h2>

<pre>
+----------------------+
| Network Layer (L3)   |
+----------------------+
| Logical Link Control |
|        (LLC)         |
+----------------------+
| Media Access Control |
|        (MAC)         |
+----------------------+
| Physical Layer (L1)  |
+----------------------+
</pre>

<h2>5. Frame View with Sub-layers</h2>

<pre>
+----------------------------------------------------+
| MAC Header | LLC Header | Data | FCS (Trailer)     |
+----------------------------------------------------+
</pre>

<ul>
    <li><span class="highlight">MAC header:</span> MAC addresses, type/length</li>
    <li><span class="highlight">LLC header:</span> Protocol identification</li>
    <li><span class="highlight">FCS:</span> Error detection</li>
</ul>

<h2>6. Practical Example: Ethernet Communication</h2>

<p><span class="highlight">Scenario:</span> Two computers on the same LAN communicate using IP.</p>

<h3>Step 1: Network Layer</h3>
<ul>
    <li>IP creates a packet</li>
</ul>

<h3>Step 2: LLC Sub-layer</h3>
<ul>
    <li>Identifies payload as IP</li>
    <li>Prepares it for MAC</li>
</ul>

<h3>Step 3: MAC Sub-layer</h3>
<ul>
    <li>Adds source and destination MAC addresses</li>
    <li>Adds FCS</li>
    <li>Applies CSMA/CD rules</li>
</ul>

<h3>Step 4: Physical Layer</h3>
<ul>
    <li>Converts frame into bits and transmits</li>
</ul>

<h2>7. Key Differences: LLC vs MAC</h2>

<table>
    <tr>
        <th>Feature</th>
        <th>LLC</th>
        <th>MAC</th>
    </tr>
    <tr>
        <td>Position</td>
        <td>Upper part of L2</td>
        <td>Lower part of L2</td>
    </tr>
    <tr>
        <td>Handles</td>
        <td>Protocol ID, flow control</td>
        <td>Addressing, framing, access</td>
    </tr>
    <tr>
        <td>Standard</td>
        <td>IEEE 802.2</td>
        <td>IEEE 802.3 / 802.11</td>
    </tr>
    <tr>
        <td>Hardware dependent</td>
        <td>No</td>
        <td>Yes</td>
    </tr>
</table>

<h2>8. Exam-Ready Summary</h2>

<ul>
    <li>Data Link Layer has two sub-layers: LLC and MAC</li>
    <li>LLC provides interface to Network layer</li>
    <li>MAC controls access to transmission medium</li>
    <li>Used in Ethernet and Wi-Fi</li>
    <li>Improves flexibility and standardization</li>
</ul>
<h1>1. Devices That Operate at the Data Link Layer (Layer 2)</h1>

<p>
    The Data Link layer deals with <span class="highlight">frames</span> and
    <span class="highlight">MAC addresses</span>. Any device that:
</p>

<ul>
    <li>Reads MAC addresses</li>
    <li>Forwards frames</li>
    <li>Does not route based on IP</li>
</ul>

<p>belongs to Layer 2.</p>

<p><span class="highlight">Main Layer 2 devices:</span></p>
<ul>
    <li>Network Interface Card (NIC)</li>
    <li>Bridge</li>
    <li>Switch</li>
</ul>

<h2>2. Network Interface Card (NIC)</h2>

<h3>What It Is</h3>
<p>
    A <span class="highlight">NIC</span> is the hardware that connects a device to the network.
    Without it, your computer is just confidently isolated.
</p>

<h3>Data Link Layer Functions</h3>
<ul>
    <li>Has a unique MAC address</li>
    <li>Encapsulates data into frames</li>
    <li>Performs error detection using FCS</li>
    <li>Communicates directly with the medium</li>
</ul>

<h3>Example</h3>
<pre>
Laptop NIC:
MAC Address: 3C:52:82:9A:BC:11
</pre>

<p>When your laptop sends data:</p>
<ul>
    <li>NIC adds source and destination MAC</li>
    <li>Creates Ethernet frame</li>
    <li>Passes bits to Physical layer</li>
</ul>

<h3>Textual Diagram</h3>
<pre>
+----------------------+
| Application          |
+----------------------+
| Transport            |
+----------------------+
| Network              |
+----------------------+
| Data Link (NIC)      | <-- Framing, MAC, FCS
+----------------------+
| Physical             |
+----------------------+
</pre>

<h2>3. Bridge</h2>

<h3>What It Is</h3>
<p>
    A <span class="highlight">bridge</span> connects two LAN segments and filters traffic
    between them using MAC addresses.
</p>

<p>Old-school, yes. Still important conceptually.</p>

<h3>Data Link Layer Functions</h3>
<ul>
    <li>Learns MAC addresses</li>
    <li>Forwards or blocks frames</li>
    <li>Reduces collisions</li>
</ul>

<h3>Example</h3>
<p>Two Ethernet segments:</p>
<pre>
LAN A ---- Bridge ---- LAN B
</pre>

<p>If destination MAC is in LAN A, the frame is not forwarded to LAN B.</p>

<h3>Textual Diagram</h3>
<pre>
LAN A                LAN B
[PC1] [PC2] ---[ BRIDGE ]--- [PC3] [PC4]
</pre>

<p>
    Bridges:
</p>
<ul>
    <li>Work in software</li>
    <li>Have limited ports (usually 2–4)</li>
</ul>

<h2>4. Switch (Most Important)</h2>

<h3>What It Is</h3>
<p>
    A <span class="highlight">switch</span> is a multiport bridge that forwards frames
    based on MAC address tables.
</p>

<p>Modern networks run on switches. Routers just get the credit.</p>

<h3>Data Link Layer Functions</h3>
<ul>
    <li>Learns source MAC addresses</li>
    <li>Maintains a MAC address table</li>
    <li>Forwards frames only to the correct port</li>
    <li>Eliminates collisions using full-duplex</li>
</ul>

<h3>MAC Address Table Example</h3>
<table>
    <tr>
        <th>MAC Address</th>
        <th>Port</th>
    </tr>
    <tr>
        <td>AA:AA:AA:AA:AA:AA</td>
        <td>1</td>
    </tr>
    <tr>
        <td>BB:BB:BB:BB:BB:BB</td>
        <td>2</td>
    </tr>
    <tr>
        <td>CC:CC:CC:CC:CC:CC</td>
        <td>3</td>
    </tr>
</table>

<h3>Frame Forwarding Example</h3>
<p>Host A → Host C:</p>
<ul>
    <li>Switch reads destination MAC</li>
    <li>Looks up MAC table</li>
    <li>Sends frame only to Port 3</li>
</ul>

<h3>Textual Diagram</h3>
<pre>
        +-----------+
PC-A ---|           |--- PC-B
        |  SWITCH   |
PC-C ---|           |--- PC-D
        +-----------+
</pre>

<p>No IP checks. No routing. Just MAC logic.</p>

<h2>5. Comparison of Layer 2 Devices</h2>

<table>
    <tr>
        <th>Device</th>
        <th>Ports</th>
        <th>Uses MAC</th>
        <th>Forwards Frames</th>
        <th>Routing</th>
    </tr>
    <tr>
        <td>NIC</td>
        <td>1</td>
        <td>Yes</td>
        <td>Yes</td>
        <td>No</td>
    </tr>
    <tr>
        <td>Bridge</td>
        <td>2–4</td>
        <td>Yes</td>
        <td>Yes</td>
        <td>No</td>
    </tr>
    <tr>
        <td>Switch</td>
        <td>Many</td>
        <td>Yes</td>
        <td>Yes</td>
        <td>No</td>
    </tr>
</table>

<h2>6. What About Hubs? (Trick Question)</h2>

<ul>
    <li>Hub is <span class="highlight">NOT</span> a Data Link layer device</li>
    <li>Operates at Physical layer</li>
    <li>No MAC awareness</li>
    <li>Broadcasts bits to all ports</li>
</ul>

<p>Exams love this trap.</p>

<h2>7. Real-World Example (LAN Communication)</h2>

<pre>
PC-A ----\
           SWITCH ---- Router ---- Internet
PC-B ----/
</pre>

<ul>
    <li>PC-A → PC-B: Switch handles it (Layer 2)</li>
    <li>PC-A → Internet: Router needed (Layer 3)</li>
</ul>
<h1>1. What is the Physical Layer?</h1>

<p>
    The <span class="highlight">Physical Layer</span> (Layer 1 of the OSI model) is responsible for
    transmitting raw bits (<span class="highlight">0s and 1s</span>) over a physical medium.
</p>

<p>
    It defines how bits are represented, how they are sent, and what hardware is used.
    No frames. No MAC. Just electrical, optical, or radio signals.
</p>

<h2>2. Why the Physical Layer Exists</h2>

<p>
    Computers don’t magically understand each other. The Physical layer exists to define:
</p>

<ul>
    <li>Voltage levels</li>
    <li>Timing of bits</li>
    <li>Signal encoding</li>
    <li>Physical connectors and cables</li>
</ul>

<p>
    Without it, data would remain theoretical.
</p>

<hr>

<h1>1. What is Bit Transmission?</h1>

<p>
    <span class="highlight">Bit transmission</span> is the process of sending raw binary data
    (0s and 1s) from one device to another over a physical medium.
</p>

<ul>
    <li>Data is just bits</li>
    <li>Bits are represented as signals</li>
    <li>The Physical layer defines how a 0 and a 1 look on the wire or in the air</li>
</ul>

<p>
    No structure. No meaning. Just physics.
</p>

<h2>2. Why Bit Transmission Is Needed</h2>

<p>
    Computers are digital. Transmission media are physical.
</p>

<p>Bit transmission exists to:</p>
<ul>
    <li>Convert binary data into physical signals</li>
    <li>Send those signals reliably</li>
    <li>Convert signals back into bits at the receiver</li>
</ul>

<p>
    Without this, networking stays theoretical.
</p>

<h2>3. How Bit Transmission Works (Step-by-Step)</h2>

<h3>Step 1: Bit Stream Generation</h3>
<pre>10110101</pre>

<h3>Step 2: Encoding Bits into Signals</h3>
<p>Example (Voltage-based):</p>
<pre>
1 → +5V
0 → 0V
</pre>

<h3>Step 3: Transmission over Medium</h3>
<ul>
    <li>Copper (electrical)</li>
    <li>Fiber (light)</li>
    <li>Wireless (radio waves)</li>
</ul>

<h3>Step 4: Signal Reception and Decoding</h3>
<ul>
    <li>Receiver measures signal</li>
    <li>Interprets voltage/light as 0 or 1</li>
    <li>Reconstructs original bit stream</li>
</ul>

<h2>4. Bit Transmission Example (Ethernet over Copper)</h2>

<p><span class="highlight">Scenario:</span></p>
<p>Sender wants to transmit data <span class="highlight">1011001</span></p>

<p><span class="highlight">Encoding Rule (Simplified):</span></p>
<pre>
1 → High voltage
0 → Low voltage
</pre>

<h3>Textual Diagram: Bit Transmission</h3>

<pre>
Bit Stream:   1   0   1   1   0   0   1

Voltage:     ┌───┐       ┌───┐┌───┐       ┌───┐
             │   │       │   ││   │       │   │
─────────────┘   └───────┘   └┘   └───────┘   └───
             H       L       H   H       L   L   H
</pre>

<p>
    Each voltage level lasts for a bit duration (defined by the data rate).
</p>

<h2>5. Data Rate and Bit Duration</h2>

<pre>
If data rate = 1 Mbps
1 bit = 1 microsecond

If data rate = 100 Mbps
1 bit = 0.01 microsecond
</pre>

<p>
    Sender and receiver must agree on this timing.
</p>

<h2>6. Transmission Modes</h2>

<h3>Simplex</h3>
<pre>Sender -----> Receiver</pre>

<h3>Half Duplex</h3>
<pre>Sender <----> Receiver (one at a time)</pre>

<h3>Full Duplex</h3>
<pre>Sender <====> Receiver (simultaneously)</pre>

<h2>7. Common Encoding Techniques</h2>

<ul>
    <li>NRZ (Non-Return to Zero)</li>
    <li>Manchester (Ethernet legacy)</li>
    <li>Differential Manchester</li>
    <li>4B/5B, 8B/10B</li>
</ul>

<p>
    Physical layer standards define these.
</p>

<h2>8. Errors in Bit Transmission</h2>

<p>Bits can flip due to:</p>
<ul>
    <li>Noise</li>
    <li>Attenuation</li>
    <li>Interference</li>
</ul>

<p><span class="highlight">Example:</span></p>
<pre>
Sent:     1011001
Received: 1010001   ← bit error
</pre>

<p>
    Physical layer does not detect or correct errors.
</p>

<h2>9. What Bit Transmission Does NOT Do</h2>

<ul>
    <li>No error checking</li>
    <li>No addressing</li>
    <li>No framing</li>
    <li>No retransmission</li>
</ul>

<p>
    It sends bits and hopes for the best.
</p>
<h1>1. What is Physical Topology?</h1>

<p>
    <span class="highlight">Physical topology</span> describes the actual physical layout of network
    devices and cables.
</p>

<p>It answers one simple question:</p>
<p><span class="highlight">How are devices physically connected?</span></p>

<p>It does not care about:</p>
<ul>
    <li>Data flow logic</li>
    <li>MAC tables</li>
    <li>Routing paths</li>
</ul>

<p>Just wires, ports, and real-world connections.</p>

<h2>2. Why Physical Topology Matters</h2>

<ul>
    <li>Affects cost</li>
    <li>Determines fault tolerance</li>
    <li>Impacts performance</li>
    <li>Influences ease of troubleshooting</li>
</ul>

<p>Bad physical design leads to good exam questions and bad networks.</p>

<h2>3. Types of Physical Topology</h2>

<h3>1. Bus Topology</h3>

<p><span class="highlight">Description:</span></p>
<ul>
    <li>All devices share a single backbone cable</li>
    <li>Data travels in both directions</li>
    <li>Ends must be terminated</li>
</ul>

<p><span class="highlight">Example:</span> Old Ethernet (10Base2, 10Base5)</p>

<p><span class="highlight">Textual Diagram:</span></p>
<pre>
[PC1]----[PC2]----[PC3]----[PC4]
</pre>

<p><span class="highlight">Advantages:</span></p>
<ul>
    <li>Cheap</li>
    <li>Easy to install</li>
</ul>

<p><span class="highlight">Disadvantages:</span></p>
<ul>
    <li>Backbone failure kills network</li>
    <li>Performance drops with more devices</li>
    <li>Difficult troubleshooting</li>
</ul>

<h3>2. Star Topology (Most Common)</h3>

<p><span class="highlight">Description:</span></p>
<ul>
    <li>All devices connect to a central device (hub/switch)</li>
    <li>Each link is independent</li>
</ul>

<p><span class="highlight">Example:</span> Modern Ethernet LANs</p>

<p><span class="highlight">Textual Diagram:</span></p>
<pre>
        [PC1]
          |
[PC2]--[SWITCH]--[PC3]
          |
        [PC4]
</pre>

<p><span class="highlight">Advantages:</span></p>
<ul>
    <li>Easy to add or remove devices</li>
    <li>Failure of one cable doesn’t affect others</li>
    <li>Easy troubleshooting</li>
</ul>

<p><span class="highlight">Disadvantages:</span></p>
<ul>
    <li>Central device failure kills network</li>
    <li>More cabling cost</li>
</ul>

<h3>3. Ring Topology</h3>

<p><span class="highlight">Description:</span></p>
<ul>
    <li>Each device connects to two neighbors</li>
    <li>Forms a closed loop</li>
</ul>

<p><span class="highlight">Example:</span> Token Ring, FDDI</p>

<p><span class="highlight">Textual Diagram:</span></p>
<pre>
[PC1]----[PC2]----[PC3]
  |                   |
  --------[PC4]--------
</pre>

<p><span class="highlight">Advantages:</span></p>
<ul>
    <li>Predictable performance</li>
    <li>No collisions</li>
</ul>

<p><span class="highlight">Disadvantages:</span></p>
<ul>
    <li>One break affects entire ring</li>
    <li>Difficult to reconfigure</li>
</ul>

<h3>4. Mesh Topology</h3>

<p><span class="highlight">Description:</span></p>
<ul>
    <li>Devices are interconnected</li>
    <li>Can be full mesh or partial mesh</li>
</ul>

<p><span class="highlight">Example:</span> WAN links, backbone networks</p>

<p><span class="highlight">Textual Diagram (Partial Mesh):</span></p>
<pre>
[Router1]----[Router2]
     |           |
     |--------[Router3]
</pre>

<p><span class="highlight">Advantages:</span></p>
<ul>
    <li>High reliability</li>
    <li>Multiple paths</li>
</ul>

<p><span class="highlight">Disadvantages:</span></p>
<ul>
    <li>Expensive</li>
    <li>Complex cabling</li>
</ul>

<h3>5. Tree (Hierarchical) Topology</h3>

<p><span class="highlight">Description:</span></p>
<ul>
    <li>Combination of star and bus</li>
    <li>Hierarchical structure</li>
</ul>

<p><span class="highlight">Example:</span> Enterprise campus networks</p>

<p><span class="highlight">Textual Diagram:</span></p>
<pre>
        [Core Switch]
            |
      ----------------
      |              |
 [Dist SW1]      [Dist SW2]
      |              |
   [PCs]          [PCs]
</pre>

<p><span class="highlight">Advantages:</span></p>
<ul>
    <li>Scalable</li>
    <li>Easy management</li>
</ul>

<p><span class="highlight">Disadvantages:</span></p>
<ul>
    <li>Root failure affects large portion</li>
    <li>Configuration complexity</li>
</ul>

<h3>6. Hybrid Topology</h3>

<p><span class="highlight">Description:</span></p>
<ul>
    <li>Combination of multiple topologies</li>
    <li>Most real networks</li>
</ul>

<p><span class="highlight">Example:</span> Star + Mesh in enterprise networks</p>

<p><span class="highlight">Textual Diagram:</span></p>
<pre>
[PC]--\
        [SW]----[SW]----[SW]
[PC]--/
</pre>

<h2>4. Physical vs Logical Topology (Exam Trap)</h2>

<table>
    <tr>
        <th>Physical Topology</th>
        <th>Logical Topology</th>
    </tr>
    <tr>
        <td>Actual wiring</td>
        <td>Data flow</td>
    </tr>
    <tr>
        <td>Deals with cables</td>
        <td>Deals with frames</td>
    </tr>
    <tr>
        <td>Example: Star</td>
        <td>Example: Bus (Ethernet)</td>
    </tr>
</table>

<p><span class="highlight">Example:</span></p>
<ul>
    <li>Ethernet using a hub</li>
    <li>Physical: Star</li>
    <li>Logical: Bus</li>
</ul>

<h2>5. Real-World Example</h2>

<p><span class="highlight">Home Network:</span></p>

<pre>
Laptop \
Phone   --- Wi-Fi Router
TV     /
</pre>

<ul>
    <li>Physical topology: Star</li>
    <li>Logical topology: Star (switching)</li>
</ul>
<h1>1. Physical Layer Standards</h1>

<p>
    <span class="highlight">Physical layer standards</span> define how bits are transmitted.
    Not what the bits mean. Just how they survive the trip.
</p>

<p>They specify:</p>
<ul>
    <li>Signal type (electrical, optical, radio)</li>
    <li>Voltage / light levels</li>
    <li>Data rate</li>
    <li>Distance limits</li>
    <li>Connector type</li>
</ul>

<p>
    Most of these standards come from IEEE and a few other standards bodies.
</p>

<h2>2. Major Physical Layer Standards</h2>

<h3>1. IEEE 802.3 (Ethernet Physical Standards)</h3>

<p>Defines wired Ethernet at Layer 1.</p>

<h4>Common Variants</h4>

<table>
    <tr>
        <th>Standard</th>
        <th>Speed</th>
        <th>Medium</th>
        <th>Max Distance</th>
    </tr>
    <tr>
        <td>10BASE-T</td>
        <td>10 Mbps</td>
        <td>UTP</td>
        <td>100 m</td>
    </tr>
    <tr>
        <td>100BASE-TX</td>
        <td>100 Mbps</td>
        <td>UTP</td>
        <td>100 m</td>
    </tr>
    <tr>
        <td>1000BASE-T</td>
        <td>1 Gbps</td>
        <td>UTP</td>
        <td>100 m</td>
    </tr>
    <tr>
        <td>10GBASE-T</td>
        <td>10 Gbps</td>
        <td>UTP</td>
        <td>100 m</td>
    </tr>
</table>

<p><span class="highlight">Example:</span></p>
<ul>
    <li>Office LAN using Cat6 cable at 1 Gbps</li>
    <li>PCs connect to switch using 1000BASE-T</li>
</ul>

<h3>2. IEEE 802.11 (Wi-Fi Physical Standards)</h3>

<p>Defines wireless transmission using radio waves.</p>

<h4>Common Variants</h4>

<table>
    <tr>
        <th>Standard</th>
        <th>Frequency</th>
        <th>Speed (Theoretical)</th>
    </tr>
    <tr>
        <td>802.11b</td>
        <td>2.4 GHz</td>
        <td>11 Mbps</td>
    </tr>
    <tr>
        <td>802.11g</td>
        <td>2.4 GHz</td>
        <td>54 Mbps</td>
    </tr>
    <tr>
        <td>802.11n</td>
        <td>2.4 / 5 GHz</td>
        <td>600 Mbps</td>
    </tr>
    <tr>
        <td>802.11ac</td>
        <td>5 GHz</td>
        <td>&gt; 1 Gbps</td>
    </tr>
    <tr>
        <td>802.11ax (Wi-Fi 6)</td>
        <td>2.4 / 5 / 6 GHz</td>
        <td>Very fast, marketing-approved</td>
    </tr>
</table>

<p><span class="highlight">Example:</span></p>
<ul>
    <li>Laptop connecting to router via Wi-Fi</li>
    <li>Signals transmitted as radio waves</li>
</ul>

<h3>3. Fiber Optic Standards</h3>

<p>Used for high speed and long distance communication.</p>

<table>
    <tr>
        <th>Standard</th>
        <th>Type</th>
        <th>Speed</th>
        <th>Distance</th>
    </tr>
    <tr>
        <td>100BASE-FX</td>
        <td>Multimode</td>
        <td>100 Mbps</td>
        <td>2 km</td>
    </tr>
    <tr>
        <td>1000BASE-SX</td>
        <td>Multimode</td>
        <td>1 Gbps</td>
        <td>550 m</td>
    </tr>
    <tr>
        <td>1000BASE-LX</td>
        <td>Single-mode</td>
        <td>1 Gbps</td>
        <td>5–10 km</td>
    </tr>
</table>

<p><span class="highlight">Example:</span></p>
<ul>
    <li>ISP backbone</li>
    <li>Campus inter-building links</li>
</ul>

<h2>3. Physical Transmission Media</h2>

<h3>1. Twisted Pair Cable</h3>

<p><span class="highlight">Types:</span></p>
<ul>
    <li>UTP (Unshielded Twisted Pair)</li>
    <li>STP (Shielded Twisted Pair)</li>
</ul>

<h4>Categories</h4>

<table>
    <tr>
        <th>Category</th>
        <th>Speed</th>
    </tr>
    <tr>
        <td>Cat5e</td>
        <td>1 Gbps</td>
    </tr>
    <tr>
        <td>Cat6</td>
        <td>10 Gbps (short range)</td>
    </tr>
    <tr>
        <td>Cat6a</td>
        <td>10 Gbps</td>
    </tr>
</table>

<p><span class="highlight">Pros:</span></p>
<ul>
    <li>Cheap</li>
    <li>Easy to install</li>
</ul>

<p><span class="highlight">Cons:</span></p>
<ul>
    <li>EMI interference</li>
    <li>Distance limited to 100 m</li>
</ul>

<h3>2. Coaxial Cable</h3>

<ul>
    <li>Used in older Ethernet and cable TV</li>
    <li>Better shielding than twisted pair</li>
    <li>Bulky and outdated for LANs</li>
</ul>

<p><span class="highlight">Example:</span> Cable modem connection</p>

<h3>3. Fiber Optic Cable</h3>

<ul>
    <li>Uses light pulses</li>
    <li>Immune to EMI</li>
    <li>Very high speed</li>
</ul>

<p><span class="highlight">Types:</span></p>
<ul>
    <li>Single-mode fiber (SMF)</li>
    <li>Multi-mode fiber (MMF)</li>
</ul>

<p><span class="highlight">Pros:</span></p>
<ul>
    <li>Long distance</li>
    <li>High bandwidth</li>
</ul>

<p><span class="highlight">Cons:</span></p>
<ul>
    <li>Expensive</li>
    <li>Harder to install</li>
</ul>

<h3>4. Wireless Media</h3>

<ul>
    <li>Radio waves</li>
    <li>No cables</li>
    <li>Susceptible to interference</li>
</ul>

<p><span class="highlight">Example:</span> Wi-Fi, Bluetooth</p>

<h2>4. Textual Diagram: Media Comparison</h2>

<pre>
[PC] --UTP--> [Switch] --Fiber--> [Router] )))) Wi-Fi )))) [Laptop]
</pre>

<h2>5. Example: Office Network Setup</h2>

<pre>
PCs --Cat6--> Switch --Fiber--> Core Switch --Fiber--> ISP
             |
             )))) Wi-Fi AP )))) Laptops
</pre>

<ul>
    <li>Cat6 for short distances</li>
    <li>Fiber for backbone</li>
    <li>Wireless for mobility</li>
</ul>
<h1>1. What Does “Operating at Physical Layer” Mean?</h1>

<p>
    A <span class="highlight">Physical layer (Layer 1)</span> device:
</p>
<ul>
    <li>Works with raw bits (0s and 1s)</li>
    <li>Deals with signals, voltage, light, or radio waves</li>
    <li>Has no idea about frames, MAC addresses, or IP addresses</li>
</ul>

<p>
    If it can’t read an address, it’s probably Layer 1.
</p>

<h2>2. Devices Operating at the Physical Layer</h2>

<h3>1. Cable (Transmission Media)</h3>

<p><span class="highlight">What It Is:</span> The actual path the signals travel through.</p>

<p><span class="highlight">Types:</span></p>
<ul>
    <li>Twisted Pair (UTP, STP)</li>
    <li>Coaxial Cable</li>
    <li>Optical Fiber</li>
    <li>Wireless medium (air)</li>
</ul>

<p><span class="highlight">Function:</span></p>
<ul>
    <li>Carries electrical, optical, or radio signals</li>
    <li>No processing, no intelligence</li>
</ul>

<p><span class="highlight">Example:</span> Ethernet cable (Cat6) connecting PC to a switch.</p>

<pre>
[PC] ===== Ethernet Cable ===== [Switch]
</pre>

<h3>2. Repeater</h3>

<p><span class="highlight">What It Is:</span> A device that regenerates and amplifies signals to extend distance.</p>

<p><span class="highlight">Function:</span></p>
<ul>
    <li>Receives weak signal</li>
    <li>Cleans it</li>
    <li>Sends it again</li>
</ul>

<p>No filtering. No thinking.</p>

<p><span class="highlight">Example:</span> Used in long-distance fiber links.</p>

<pre>
[PC] --- weak signal --- [Repeater] --- regenerated --- [PC]
</pre>

<h3>3. Hub</h3>

<p><span class="highlight">What It Is:</span> A multiport repeater.</p>

<p><span class="highlight">Function:</span></p>
<ul>
    <li>Receives bits on one port</li>
    <li>Broadcasts them to all other ports</li>
</ul>

<p>This is why hubs caused chaos and collisions.</p>

<p><span class="highlight">Example:</span> Old Ethernet LANs.</p>

<pre>
PC-A ---\
PC-B ---- HUB ---- PC-C
PC-D ---/
</pre>

<p>Every bit goes everywhere. Democracy, but terrible.</p>

<h3>4. Modem (Physical Layer Role)</h3>

<p><span class="highlight">What It Is:</span> MOdulator–DEModulator</p>

<p><span class="highlight">Function:</span></p>
<ul>
    <li>Converts digital data to analog signals</li>
    <li>Converts analog signals back to digital</li>
</ul>

<p>Used to transmit over phone lines or cable networks.</p>

<p><span class="highlight">Example:</span> DSL or cable modem.</p>

<pre>
[PC] --digital--> [MODEM] --analog--> ISP
</pre>

<p>(Yes, modems also touch higher layers. Exams usually forgive this.)</p>

<h3>5. NIC (Physical Layer Component)</h3>

<p><span class="highlight">What It Is:</span> The physical interface part of the Network Interface Card.</p>

<p><span class="highlight">Function:</span></p>
<ul>
    <li>Converts bits to electrical or radio signals</li>
    <li>Handles connectors and transmission</li>
</ul>

<p>MAC addressing belongs to Layer 2. Don’t mix them.</p>

<p><span class="highlight">Example:</span> Ethernet port on a laptop.</p>

<pre>
[Computer]
   |
[ NIC ]  <-- signal generation
   |
[ Cable ]
</pre>

<h2>3. What About These Devices?</h2>

<ul>
    <li>❌ <span class="highlight">Switch</span> – Data Link layer (uses MAC addresses)</li>
    <li>❌ <span class="highlight">Router</span> – Network layer (uses IP addresses)</li>
    <li>❌ <span class="highlight">Bridge</span> – Data Link layer</li>
</ul>

<p>Classic exam traps. Step around them calmly.</p>

<h2>4. Comparison Table</h2>

<table>
    <tr>
        <th>Device</th>
        <th>Layer</th>
        <th>Role</th>
    </tr>
    <tr>
        <td>Cable</td>
        <td>L1</td>
        <td>Signal transmission</td>
    </tr>
    <tr>
        <td>Repeater</td>
        <td>L1</td>
        <td>Signal regeneration</td>
    </tr>
    <tr>
        <td>Hub</td>
        <td>L1</td>
        <td>Broadcast bits</td>
    </tr>
    <tr>
        <td>Modem</td>
        <td>L1 (part)</td>
        <td>Digital ↔ Analog</td>
    </tr>
    <tr>
        <td>NIC (physical part)</td>
        <td>L1</td>
        <td>Signal encoding</td>
    </tr>
</table>

<h2>5. Real-World Example</h2>

<p>Home setup:</p>
<pre>
Laptop -- Ethernet Cable -- Router
</pre>

<p><span class="highlight">Physical layer:</span></p>
<ul>
    <li>Cable carries signals</li>
    <li>NIC sends and receives bits</li>
    <li>Router’s PHY receives signals</li>
</ul>

<p>
    Everything above that is someone else’s job.
</p>





</body>
</html>
