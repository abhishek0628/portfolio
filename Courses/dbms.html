<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>DBMS Topics Overview</title>
    <style>
        body {
    font-family: "Segoe UI", Roboto, Arial, sans-serif;
    background: #ffffff; /* white background */
    color: #000000;      /* black text */
    margin: 0;
    padding: 20px;
    line-height: 1.7;
}

/* Container */
.container {
    max-width: 1000px;
    margin: auto;
    padding: 40px;
}

/* Headings */
h1, h2, h3 {
    color: #000000; /* black headings */
    margin-top: 30px;
}

h1 {
    font-size: 2.5rem;
    border-bottom: 2px solid #000000;
    padding-bottom: 10px;
}

h2 {
    font-size: 1.9rem;
}

h3 {
    font-size: 1.4rem;
    color: #000000;
}

/* Paragraphs and lists */
p {
    font-size: 1.05rem;
    margin: 15px 0;
}

ul, ol {
    margin-left: 25px;
    margin-bottom: 15px;
}

li {
    margin: 8px 0;
}

/* Boxes for examples or notes */
.box, .example {
    background: #f0f0f0; /* light gray background */
    border-left: 5px solid #000000;
    padding: 20px;
    margin: 25px 0;
    border-radius: 6px;
    color: #000000;
}

/* Code and diagram blocks */
.diagram, .code, pre {
    background: #e5e5e5; /* slightly darker gray for code/diagrams */
    padding: 20px;
    font-family: "Courier New", monospace;
    white-space: pre;
    border-radius: 6px;
    margin: 20px 0;
    color: #000000;
    overflow-x: auto;
}

code {
    font-family: monospace;
    background-color: #f4f4f4;
    padding: 2px 4px;
    border-radius: 4px;
    color: #000000;
}

/* Tables */
table {
    width: 100%;
    border-collapse: collapse;
    margin: 20px 0;
}

table th, table td {
    border: 1px solid #cccccc;
    padding: 10px;
    text-align: left;
    color: #000000;
}

table th {
    background: #e0e0e0;
    color: #000000;
}

/* Highlighted text */
.highlight {
    color: #ff6600; /* orange for highlights */
}

/* Footer */
footer {
    text-align: center;
    padding: 20px;
    color: #ffffff;
    background-color: #000000; /* black footer background */
    margin-top: 20px;
}
    </style>
</head>
<body>

<h1>DBMS </h1>

<h2>1. Basics of DBMS</h2>
<ul>
    <li>Data vs Information</li>
    <li>Database, DBMS, RDBMS</li>
    <li>File system vs DBMS</li>
    <li>Advantages and limitations of DBMS</li>
    <li>Database users and administrators</li>
</ul>

<h2>2. Data Models</h2>
<ul>
    <li>Hierarchical model</li>
    <li>Network model</li>
    <li>Relational model</li>
    <li>Entity–Relationship (ER) model</li>
    <li>Object-oriented data model</li>
</ul>

<h2>3. ER Model</h2>
<ul>
    <li>Entities and entity sets</li>
    <li>Attributes (simple, composite, multivalued, derived)</li>
    <li>Keys (super, candidate, primary, foreign)</li>
    <li>Relationships and relationship sets</li>
    <li>Cardinality and participation constraints</li>
    <li>Weak entity sets</li>
</ul>

<h2>4. Relational Model</h2>
<ul>
    <li>Relations, tuples, attributes</li>
    <li>Domains</li>
    <li>Schema vs instance</li>
    <li>Relational database constraints</li>
    <li>Codd’s rules</li>
</ul>

<h2>5. Relational Algebra</h2>
<ul>
    <li><strong>Basic operations:</strong>
        <ul>
            <li>Selection (σ)</li>
            <li>Projection (π)</li>
            <li>Union (∪)</li>
            <li>Set difference (−)</li>
            <li>Cartesian product (×)</li>
        </ul>
    </li>
    <li><strong>Derived operations:</strong>
        <ul>
            <li>Join (θ, equi, natural)</li>
            <li>Division</li>
            <li>Intersection</li>
        </ul>
    </li>
</ul>

<h2>6. SQL</h2>
<ul>
    <li>DDL: CREATE, DROP, ALTER, TRUNCATE</li>
    <li>DML: SELECT, INSERT, UPDATE, DELETE</li>
    <li>DCL: GRANT, REVOKE</li>
    <li>TCL: COMMIT, ROLLBACK, SAVEPOINT</li>
    <li>Constraints: NOT NULL, UNIQUE, PRIMARY KEY, FOREIGN KEY, CHECK</li>
    <li>Joins (INNER, LEFT, RIGHT, FULL)</li>
    <li>Subqueries (nested, correlated)</li>
    <li>Views</li>
    <li>Indexes</li>
    <li>Stored procedures and triggers</li>
</ul>

<h2>7. Normalization</h2>
<ul>
    <li>Functional dependencies</li>
    <li>Closure of attributes</li>
    <li>Normal forms: 1NF, 2NF, 3NF, BCNF, 4NF, 5NF</li>
    <li>Lossless decomposition</li>
    <li>Dependency preservation</li>
</ul>

<h2>8. Transaction Management</h2>
<ul>
    <li>Transactions and schedules</li>
    <li>ACID properties</li>
    <li>Serial and concurrent schedules</li>
    <li>Conflict and view serializability</li>
    <li>Recoverable, cascadeless, strict schedules</li>
</ul>

<h2>9. Concurrency Control</h2>
<ul>
    <li>Problems: lost update, dirty read, unrepeatable read</li>
    <li>Lock-based protocols</li>
    <li>Two-phase locking (2PL)</li>
    <li>Deadlock and starvation</li>
    <li>Timestamp-based protocols</li>
    <li>Optimistic concurrency control</li>
</ul>

<h2>10. Recovery System</h2>
<ul>
    <li>Types of failures</li>
    <li>Log-based recovery</li>
    <li>Checkpointing</li>
    <li>Undo and redo operations</li>
    <li>Shadow paging</li>
</ul>

<h2>11. Indexing and File Organization</h2>
<ul>
    <li>File organization techniques</li>
    <li>Primary and secondary indexes</li>
    <li>Dense and sparse indexes</li>
    <li>B-tree and B+ tree</li>
    <li>Hashing (static and dynamic)</li>
</ul>

<h2>12. Query Processing and Optimization</h2>
<ul>
    <li>Query evaluation plans</li>
    <li>Cost-based optimization</li>
    <li>Heuristics in query optimization</li>
    <li>Join algorithms</li>
</ul>

<h2>13. Database Security</h2>
<ul>
    <li>Authentication and authorization</li>
    <li>SQL injection</li>
    <li>Access control mechanisms</li>
    <li>Encryption</li>
</ul>

<h2>14. Distributed Databases</h2>
<ul>
    <li>Distributed DBMS architecture</li>
    <li>Data fragmentation and replication</li>
    <li>Transparency</li>
    <li>Two-phase commit protocol</li>
</ul>

<h2>15. Advanced Topics</h2>
<ul>
    <li>NoSQL databases</li>
    <li>Data warehousing</li>
    <li>OLTP vs OLAP</li>
    <li>Big data basics</li>
    <li>Cloud databases</li>
</ul>
<h1>Basics of DBMS</h1>

<h2>1. What is Data?</h2>
<p>Data is raw, unprocessed facts. It does not mean anything on its own.</p>

<p><strong>Example</strong></p>
<pre>
101
Abhishek
CS
85
</pre>

<p>These values are just raw facts without context.</p>

<h2>2. What is Information?</h2>
<p>Information is processed data that has meaning.</p>

<p><strong>Example</strong></p>
<pre>
Roll No : 101
Name     : Abhishek
Branch   : CS
Marks    : 85
</pre>

<p>Same data, now organized and meaningful.</p>

<h2>3. What is a Database?</h2>
<p>A database is an organized collection of related data stored electronically.</p>

<p><strong>Example: Student Database</strong></p>

<table>
    <tr>
        <th>Roll</th>
        <th>Name</th>
        <th>Branch</th>
        <th>Marks</th>
    </tr>
    <tr>
        <td>101</td>
        <td>Abhishek</td>
        <td>CS</td>
        <td>85</td>
    </tr>
    <tr>
        <td>102</td>
        <td>Ravi</td>
        <td>EC</td>
        <td>78</td>
    </tr>
    <tr>
        <td>103</td>
        <td>Neha</td>
        <td>ME</td>
        <td>90</td>
    </tr>
</table>

<h2>4. What is DBMS?</h2>
<p>A Database Management System (DBMS) is software that:</p>

<ul>
    <li>Creates databases</li>
    <li>Stores data</li>
    <li>Retrieves data</li>
    <li>Updates data</li>
    <li>Controls access</li>
</ul>

<p><strong>Examples:</strong> MySQL, PostgreSQL, Oracle, SQL Server</p>

<h2>5. DBMS Architecture</h2>

<pre>
+------------------+
|      USER        |
+------------------+
         |
         v
+------------------+
|   APPLICATION    |
+------------------+
         |
         v
+------------------+
|       DBMS       |
| Query Processor  |
| Storage Manager  |
| Transaction Mgmt |
+------------------+
         |
         v
+------------------+
|    DATABASE      |
| Tables, Indexes  |
| Files            |
+------------------+
</pre>

<p>Users interact with data through the DBMS, not directly.</p>

<h2>6. File System vs DBMS</h2>

<h3>File System Approach</h3>
<pre>
User
 |
 v
Program  --->  File (data.txt)
</pre>

<p><strong>Problems:</strong></p>
<ul>
    <li>Data redundancy</li>
    <li>No security</li>
    <li>No concurrency control</li>
    <li>Data inconsistency</li>
</ul>

<h3>DBMS Approach</h3>
<pre>
User
 |
 v
Application
 |
 v
DBMS  --->  Database
</pre>

<p><strong>Benefits:</strong></p>
<ul>
    <li>Centralized control</li>
    <li>Reduced redundancy</li>
    <li>Better security</li>
    <li>Multiple users supported</li>
</ul>

<h2>7. Why Not Just Use Files?</h2>
<p>File systems can cause inconsistency when the same data exists in multiple files.</p>

<p><strong>Example Problem:</strong></p>
<ul>
    <li>student.txt</li>
    <li>marks.txt</li>
</ul>

<p>Updating one file and forgetting the other leads to inconsistent data.</p>

<h2>8. Characteristics of DBMS</h2>
<ul>
    <li>Data abstraction</li>
    <li>Data independence</li>
    <li>Reduced redundancy</li>
    <li>Concurrency control</li>
    <li>Security</li>
    <li>Backup and recovery</li>
</ul>

<h2>9. Database Users</h2>

<pre>
Naive Users        -> ATM users
Application Users -> Developers
Sophisticated     -> Analysts
DBA               -> Database Administrator
</pre>

<p><strong>DBA Responsibilities:</strong></p>
<ul>
    <li>Schema definition</li>
    <li>Security management</li>
    <li>Backup and recovery</li>
    <li>Performance tuning</li>
</ul>

<h2>10. DBMS vs RDBMS</h2>

<table>
    <tr>
        <th>DBMS</th>
        <th>RDBMS</th>
    </tr>
    <tr>
        <td>No relation enforcement</td>
        <td>Enforces relationships</td>
    </tr>
    <tr>
        <td>Single table</td>
        <td>Multiple related tables</td>
    </tr>
    <tr>
        <td>Less secure</td>
        <td>More secure</td>
    </tr>
    <tr>
        <td>Example: File DB</td>
        <td>Examples: MySQL, Oracle</td>
    </tr>
</table>

<h2>11. Real-Life Example: Library System</h2>

<h3>Without DBMS</h3>
<ul>
    <li>Books.txt</li>
    <li>Students.txt</li>
    <li>IssuedBooks.txt</li>
</ul>

<p>Manual updates and high chance of errors.</p>

<h3>With DBMS</h3>
<pre>
BOOK(BookID, Title, Author)
STUDENT(Roll, Name)
ISSUE(BookID, Roll, Date)
</pre>

<p><strong>Query Example:</strong></p>
<pre>
SELECT Name
FROM STUDENT
WHERE Roll IN
(SELECT Roll FROM ISSUE WHERE BookID = 10);
</pre>

<p>Fast, accurate, and consistent.</p>
<h1>Hierarchical Data Model</h1>

<h2>1. What is the Hierarchical Model?</h2>
<p>The hierarchical data model organizes data in a tree-like structure.</p>
<ul>
    <li>Each record is called a node</li>
    <li>There is one root node</li>
    <li>Each parent can have multiple children</li>
    <li>Each child has only one parent</li>
    <li>Relationship type: One-to-Many (1:N) only</li>
</ul>
<p>If you want Many-to-Many, this model politely refuses.</p>

<h2>2. Structure Overview</h2>
<ul>
    <li><strong>Root:</strong> Top-most record</li>
    <li><strong>Parent:</strong> Record that has children</li>
    <li><strong>Child:</strong> Record dependent on parent</li>
    <li><strong>Link:</strong> Relationship between parent and child</li>
</ul>
<p>Traversal happens top-down, because democracy is not allowed here.</p>

<h2>3. Textual Diagram (Tree Structure)</h2>
<p><strong>Example: Company → Departments → Employees</strong></p>

<pre>
Company
│
├── Department (CSE)
│   ├── Employee (Alice)
│   ├── Employee (Bob)
│
├── Department (ECE)
│   ├── Employee (Charlie)
│   ├── Employee (David)
│
└── Department (ME)
    ├── Employee (Eve)
</pre>

<ul>
    <li>Company is the root</li>
    <li>Departments are children of Company</li>
    <li>Employees are children of Departments</li>
</ul>
<p>No employee can belong to two departments.<br>
Yes, HR would love that. Reality does not.</p>

<h2>4. Example with Student Database</h2>
<p><strong>Scenario</strong></p>
<ul>
    <li>One University</li>
    <li>Multiple Colleges</li>
    <li>Each College has multiple Students</li>
</ul>

<h3>Hierarchical Representation</h3>
<pre>
University
│
├── College (Engineering)
│   ├── Student (Roll: 101)
│   ├── Student (Roll: 102)
│
├── College (Science)
│   ├── Student (Roll: 201)
│   ├── Student (Roll: 202)
</pre>

<h3>Relationship Rules</h3>
<ul>
    <li>One University → Many Colleges</li>
    <li>One College → Many Students</li>
    <li>One Student → Only one College</li>
</ul>
<p>If a student wants to do a double major?<br>
Hierarchical model says “pick one and stop asking.”</p>

<h2>5. Data Storage Concept</h2>
<pre>
Parent Record
   ↓
Child Record
   ↓
Grandchild Record
</pre>
<p>Access path is predefined.<br>
If you don’t know the path, enjoy your full traversal.</p>

<h2>6. Operations in Hierarchical Model</h2>

<h3>1. Insertion</h3>
<ul>
    <li>Parent must exist before inserting child</li>
    <li>No orphan nodes allowed</li>
</ul>

<h3>2. Deletion</h3>
<p>Deleting a parent deletes all children<br>
(Cascade delete before it was cool)</p>

<h3>3. Update</h3>
<p>Can be complex if structure changes</p>

<h2>7. Advantages</h2>
<ul>
    <li>Simple and easy to understand</li>
    <li>Fast data access for 1:N relationships</li>
    <li>Data integrity is strong</li>
    <li>Efficient for structured data</li>
</ul>

<h2>8. Disadvantages</h2>
<ul>
    <li>Cannot handle Many-to-Many relationships</li>
    <li>Rigid structure</li>
    <li>Data redundancy</li>
    <li>Difficult to reorganize</li>
    <li>Poor flexibility for complex queries</li>
</ul>
<p>Basically: great until real life happens.</p>

<h2>9. Real-World Applications</h2>
<ul>
    <li>File systems (folders and files)</li>
    <li>XML and JSON data</li>
    <li>IBM IMS (classic example)</li>
    <li>Organization charts</li>
</ul>
<p>Your operating system still loves this model. Progress is slow.</p>

<h2>10. Comparison Snapshot</h2>
<table>
    <tr>
        <th>Feature</th>
        <th>Hierarchical Model</th>
    </tr>
    <tr>
        <td>Structure</td>
        <td>Tree</td>
    </tr>
    <tr>
        <td>Root</td>
        <td>Single</td>
    </tr>
    <tr>
        <td>Relationship</td>
        <td>1:N</td>
    </tr>
    <tr>
        <td>Flexibility</td>
        <td>Low</td>
    </tr>
    <tr>
        <td>M:N support</td>
        <td>No</td>
    </tr>
    <tr>
        <td>Example</td>
        <td>File system</td>
    </tr>
</table>

<hr>

<h1>Network Data Model</h1>

<h2>1. What is the Network Data Model?</h2>
<p>The Network Data Model represents data as a graph structure.</p>
<ul>
    <li>Records are nodes</li>
    <li>Relationships are edges</li>
    <li>A record can have multiple parents and multiple children</li>
    <li>Relationships are represented using sets</li>
</ul>
<p>This model was standardized by CODASYL.</p>

<h3>Key Idea</h3>
<p>One-to-many relationships, but a child can belong to multiple parents.</p>

<h2>2. Why Network Model Exists</h2>
<p><strong>Hierarchical model problem:</strong><br>
Child → only one parent ❌</p>
<p><strong>Network model solution:</strong><br>
Child → many parents ✔️</p>
<p>Real-world data is not a family tree. It’s a spider web.</p>

<h2>3. Core Components</h2>

<h3>3.1 Record Types</h3>
<p>Equivalent to a table row (but older and moodier).</p>
<ul>
    <li>STUDENT</li>
    <li>COURSE</li>
    <li>FACULTY</li>
</ul>

<h3>3.2 Set Types (Most Important)</h3>
<p>A set type represents a relationship.</p>
<ul>
    <li>Each set has an Owner (parent)</li>
    <li>Each set has a Member (child)</li>
    <li>One owner → many members</li>
    <li>One member → can belong to many sets</li>
</ul>

<h2>4. Textual Diagram (Graph Representation)</h2>
<pre>
            FACULTY
           /       \
      teaches     teaches
         /           \
     COURSE -------- COURSE
       |  \            |
   enrolls  enrolls  enrolls
       |      \        |
    STUDENT   STUDENT  STUDENT
</pre>
<p>This is many-to-many done manually, before databases got civilized.</p>

<h2>5. Example with Records and Sets</h2>

<h3>Record Types</h3>
<ul>
    <li>STUDENT (Student_ID, Name)</li>
    <li>COURSE (Course_ID, Title)</li>
    <li>FACULTY (Faculty_ID, Name)</li>
</ul>

<h3>Set Types</h3>
<ul>
    <li>SET ENROLLMENT<br>Owner: COURSE<br>Member: STUDENT</li>
    <li>SET TEACHING<br>Owner: FACULTY<br>Member: COURSE</li>
</ul>

<h3>Interpretation</h3>
<ul>
    <li>COURSE → many STUDENTS</li>
    <li>FACULTY → many COURSES</li>
    <li>STUDENT can belong to multiple COURSE owners</li>
    <li>COURSE can belong to multiple FACULTY owners</li>
</ul>
<p>No rules about “only one parent.” Chaos, but useful chaos.</p>

<h2>6. Data Access in Network Model</h2>
<p>Access is navigational, not declarative.</p>
<p>You don’t say: “Give me all students of DBMS”</p>
<p>You say:</p>
<ul>
    <li>Find COURSE = DBMS</li>
    <li>Follow ENROLLMENT set</li>
    <li>Traverse STUDENT records one by one</li>
</ul>
<p>Path matters. Miss the path, miss the data. Fun.</p>

<h2>7. Advantages</h2>
<ul>
    <li>Supports many-to-many relationships</li>
    <li>Less redundancy than hierarchical model</li>
    <li>Faster access if traversal path is known</li>
    <li>More realistic than tree structures</li>
</ul>

<h2>8. Disadvantages</h2>
<ul>
    <li>Complex structure</li>
    <li>Difficult to design and maintain</li>
    <li>Program-dependent data access</li>
    <li>Poor data independence</li>
    <li>Queries are procedural, not flexible</li>
</ul>
<p>In short: powerful but unfriendly.</p>

<h2>9. Network Model vs Hierarchical Model</h2>
<table>
    <tr>
        <th>Feature</th>
        <th>Hierarchical</th>
        <th>Network</th>
    </tr>
    <tr>
        <td>Structure</td>
        <td>Tree</td>
        <td>Graph</td>
    </tr>
    <tr>
        <td>Parent per child</td>
        <td>One</td>
        <td>Many</td>
    </tr>
    <tr>
        <td>M:N relationship</td>
        <td>No</td>
        <td>Yes</td>
    </tr>
    <tr>
        <td>Flexibility</td>
        <td>Low</td>
        <td>Medium</td>
    </tr>
    <tr>
        <td>Complexity</td>
        <td>Low</td>
        <td>High</td>
    </tr>
</table>
<h1>3. ER Model</h1>

<h2>Entities and Entity Sets (In Depth)</h2>

<h3>1. Entity</h3>
<p>An entity is a real-world object that can be uniquely identified and about which data is stored.</p>
<p>Think of it as one actual thing, not the idea of the thing.</p>

<h4>Examples</h4>
<ul>
    <li>A specific student with roll no 101</li>
    <li>A particular book with ISBN 978-013</li>
    <li>One employee with emp_id E23</li>
</ul>

<p>Each of these exists independently and has properties.</p>

<h4>Key Point</h4>
<p>An entity must be distinguishable from other similar objects.</p>
<p>If you can point at it and say “this one, not that one,” it qualifies.</p>

<h3>2. Attributes of an Entity</h3>
<p>Attributes describe the properties of an entity.</p>

<h4>Example: Student entity</h4>
<ul>
    <li>Roll_No</li>
    <li>Name</li>
    <li>Age</li>
    <li>Branch</li>
    <li>Email</li>
</ul>

<p>Every single student entity will have values for these attributes.</p>

<h3>3. Entity Set</h3>
<p>An entity set is a collection of similar entities sharing the same attributes.</p>

<ul>
    <li>Entity = one row</li>
    <li>Entity Set = entire table</li>
</ul>

<h4>Example</h4>
<p>All students in a college form the STUDENT entity set.</p>

<table>
    <tr>
        <th>Roll_No</th>
        <th>Name</th>
        <th>Age</th>
        <th>Branch</th>
    </tr>
    <tr>
        <td>101</td>
        <td>Rahul</td>
        <td>20</td>
        <td>CSE</td>
    </tr>
    <tr>
        <td>102</td>
        <td>Anita</td>
        <td>21</td>
        <td>ECE</td>
    </tr>
    <tr>
        <td>103</td>
        <td>Mohan</td>
        <td>19</td>
        <td>ME</td>
    </tr>
</table>

<p>Each row is an entity. The whole table is the entity set.</p>

<h3>4. Strong Entity Set</h3>
<p>A strong entity set:</p>
<ul>
    <li>Has its own primary key</li>
    <li>Exists independently</li>
</ul>

<h4>Example: STUDENT</h4>
<p>Primary Key: Roll_No</p>

<pre>
+------------------+
|     STUDENT      |
+------------------+
| Roll_No (PK)     |
| Name             |
| Age              |
| Branch           |
+------------------+
</pre>

<p>STUDENT does not depend on any other entity to exist.</p>

<h3>5. Weak Entity Set</h3>
<p>A weak entity set:</p>
<ul>
    <li>Does not have a primary key of its own</li>
    <li>Depends on a strong entity for identification</li>
    <li>Has a partial key</li>
</ul>

<h4>Example</h4>
<p>DEPENDENT depends on EMPLOYEE.</p>

<pre>
+------------------+        +--------------------+
|    EMPLOYEE      |        |     DEPENDENT      |
+------------------+        +--------------------+
| Emp_ID (PK)      |◄───────| Dep_Name (Partial) |
| Name             |        | Age                |
| Dept             |        | Relation           |
+------------------+        +--------------------+
</pre>

<p>Primary key of DEPENDENT = (Emp_ID, Dep_Name)</p>

<h3>6. Entity vs Entity Set</h3>

<table>
    <tr>
        <th>Aspect</th>
        <th>Entity</th>
        <th>Entity Set</th>
    </tr>
    <tr>
        <td>Meaning</td>
        <td>Single object</td>
        <td>Collection of entities</td>
    </tr>
    <tr>
        <td>Example</td>
        <td>Student with Roll 101</td>
        <td>All students</td>
    </tr>
    <tr>
        <td>DB Representation</td>
        <td>Row</td>
        <td>Table</td>
    </tr>
</table>

<h3>7. Why Entity Sets Matter</h3>
<ul>
    <li>They define tables in relational databases</li>
    <li>Help in schema design</li>
    <li>Prevent redundancy and chaos</li>
    <li>Make normalization possible</li>
</ul>

<h3>8. Real-World Example (University DB)</h3>
<ul>
    <li>STUDENT (Roll_No, Name, Branch)</li>
    <li>COURSE (Course_ID, Title, Credits)</li>
    <li>FACULTY (Fac_ID, Name, Dept)</li>
</ul>

<h3>9. Common Exam Traps</h3>
<ul>
    <li>Entity ≠ Attribute</li>
    <li>Entity set ≠ Relationship</li>
    <li>Weak entity must have identifying relationship</li>
    <li>Primary key ≠ Partial key</li>
</ul>

<h2>Attributes in ER Model (In Depth)</h2>

<h3>1. Simple (Atomic) Attribute</h3>
<p>A simple attribute cannot be divided into smaller meaningful parts.</p>

<h4>Examples</h4>
<ul>
    <li>RollNo</li>
    <li>Age</li>
    <li>Gender</li>
</ul>

<h3>2. Composite Attribute</h3>
<p>A composite attribute can be broken down into smaller sub-attributes.</p>

<pre>
Name
 ├── FirstName
 ├── MiddleName
 └── LastName
</pre>

<h3>3. Multivalued Attribute</h3>
<p>A multivalued attribute can have more than one value.</p>

<pre>
STUDENT_PHONE(RollNo, PhoneNumber)
</pre>

<h3>4. Derived Attribute</h3>
<p>A derived attribute is calculated from other attributes.</p>

<pre>
Age = CurrentDate − DateOfBirth
</pre>

<h2>Keys in ER Model</h2>

<h3>Super Key</h3>
<p>A super key uniquely identifies a tuple.</p>

<h3>Candidate Key</h3>
<p>A minimal super key.</p>

<h3>Primary Key</h3>
<p>A candidate key chosen to identify tuples.</p>

<h3>Foreign Key</h3>
<p>References the primary key of another table.</p>

<h2>Relationships in ER Model</h2>

<h3>1. What is a Relationship?</h3>
<p>A relationship represents an association between entities.</p>

<h3>2. Degree of Relationship</h3>
<ul>
    <li>Unary</li>
    <li>Binary</li>
    <li>Ternary</li>
</ul>

<h3>3. Cardinality Constraints</h3>
<ul>
    <li>1:1</li>
    <li>1:N</li>
    <li>N:1</li>
    <li>M:N</li>
</ul>

<h3>4. Participation Constraints</h3>
<ul>
    <li>Total Participation</li>
    <li>Partial Participation</li>
</ul>

<h3>5. Identifying Relationship</h3>
<p>Used for weak entities.</p>

<h2>Cardinality and Participation Constraints</h2>

<h3>Cardinality</h3>
<p>Defines how many entities can participate.</p>

<h3>Participation</h3>
<p>Defines whether participation is mandatory or optional.</p>

<h3>Minimum–Maximum Notation</h3>

<pre>
[Employee] (1,3) ───── works_on ───── (0,N) [Project]
</pre>

<h3>Common Mistakes</h3>
<ul>
    <li>Confusing cardinality with participation</li>
    <li>Ignoring weak entity rules</li>
    <li>Wrong relationship mapping</li>
</ul>
<h2>3. ER Model</h2>

<h3>Entities and Entity Sets (In Depth)</h3>

<h4>1. Entity</h4>

<p>An entity is a real-world object that can be uniquely identified and about which data is stored.</p>

<p>Think of it as one actual thing, not the idea of the thing.</p>

<p><strong>Examples</strong></p>

<ul>
    <li>A specific student with roll no 101</li>
    <li>A particular book with ISBN 978-013</li>
    <li>One employee with emp_id E23</li>
</ul>

<p>Each of these exists independently and has properties.</p>

<p><strong>Key Point</strong></p>

<p>An entity must be distinguishable from other similar objects.</p>

<p>If you can point at it and say “this one, not that one,” it qualifies.</p>

<h4>2. Attributes of an Entity</h4>

<p>Attributes describe the properties of an entity.</p>

<p><strong>Example: Student entity</strong></p>

<ul>
    <li>Roll_No</li>
    <li>Name</li>
    <li>Age</li>
    <li>Branch</li>
    <li>Email</li>
</ul>

<p>Every single student entity will have values for these attributes.</p>

<h4>3. Entity Set</h4>

<p>An entity set is a collection of similar entities sharing the same attributes.</p>

<p>Entity = one row</p>

<p>Entity Set = entire table</p>

<p><strong>Example</strong></p>

<p>All students in a college form the STUDENT entity set.</p>

<table border="1" cellpadding="5" cellspacing="0">
    <tr>
        <th>Roll_No</th>
        <th>Name</th>
        <th>Age</th>
        <th>Branch</th>
    </tr>
    <tr>
        <td>101</td>
        <td>Rahul</td>
        <td>20</td>
        <td>CSE</td>
    </tr>
    <tr>
        <td>102</td>
        <td>Anita</td>
        <td>21</td>
        <td>ECE</td>
    </tr>
    <tr>
        <td>103</td>
        <td>Mohan</td>
        <td>19</td>
        <td>ME</td>
    </tr>
</table>

<p>Each row is an entity</p>

<p>The whole table is the entity set</p>

<h4>4. Strong Entity Set</h4>

<p>A strong entity set:</p>

<ul>
    <li>Has its own primary key</li>
    <li>Exists independently</li>
</ul>

<p><strong>Example: STUDENT</strong></p>

<p><strong>Primary Key:</strong> Roll_No</p>

<p><strong>Textual ER Diagram:</strong></p>

<pre>
+------------------+
|     STUDENT      |
+------------------+
| Roll_No (PK)     |
| Name             |
| Age              |
| Branch           |
+------------------+
</pre>

<p>STUDENT does not depend on any other entity to exist. No drama.</p>

<h4>5. Weak Entity Set</h4>

<p>A weak entity set:</p>

<ul>
    <li>Does not have a primary key of its own</li>
    <li>Depends on a strong entity for identification</li>
    <li>Has a partial key</li>
</ul>

<p><strong>Example</strong></p>

<p>DEPENDENT depends on EMPLOYEE.</p>

<p>A dependent cannot exist without an employee. Shocking but true.</p>

<p><strong>Attributes:</strong></p>

<ul>
    <li>Dep_Name (partial key)</li>
    <li>Age</li>
    <li>Relation</li>
</ul>

<p><strong>EMPLOYEE has:</strong></p>

<ul>
    <li>Emp_ID (PK)</li>
    <li>Name</li>
</ul>

<p><strong>Textual ER Diagram</strong></p>

<pre>
+------------------+        +--------------------+
|    EMPLOYEE      |        |     DEPENDENT      |
+------------------+        +--------------------+
| Emp_ID (PK)      |◄───────| Dep_Name (Partial) |
| Name             |        | Age                |
| Dept             |        | Relation           |
+------------------+        +--------------------+
</pre>

<p>Primary key of DEPENDENT = (Emp_ID, Dep_Name)</p>

<p>DEPENDENT is helpless without EMPLOYEE.</p>

<h4>6. Entity vs Entity Set (Quick Comparison)</h4>

<table border="1" cellpadding="5" cellspacing="0">
    <tr>
        <th>Aspect</th>
        <th>Entity</th>
        <th>Entity Set</th>
    </tr>
    <tr>
        <td>Meaning</td>
        <td>Single object</td>
        <td>Collection of entities</td>
    </tr>
    <tr>
        <td>Example</td>
        <td>Student with Roll 101</td>
        <td>All students</td>
    </tr>
    <tr>
        <td>DB Representation</td>
        <td>Row</td>
        <td>Table</td>
    </tr>
</table>

<h4>7. Why Entity Sets Matter</h4>

<ul>
    <li>They define tables in relational databases</li>
    <li>Help in schema design</li>
    <li>Prevent redundancy and chaos</li>
    <li>Make normalization possible</li>
</ul>

<p>Without entity sets, DBMS is just Excel with trust issues.</p>

<h4>8. Real-World Example (University DB)</h4>

<p><strong>Entity Sets:</strong></p>

<ul>
    <li>STUDENT (Roll_No, Name, Branch)</li>
    <li>COURSE (Course_ID, Title, Credits)</li>
    <li>FACULTY (Fac_ID, Name, Dept)</li>
</ul>

<p>Each set contains many entities. Simple. Predictable. Peaceful.</p>

<h4>9. Common Exam Traps</h4>

<ul>
    <li>Entity ≠ Attribute</li>
    <li>Entity set ≠ Relationship</li>
    <li>Weak entity must have identifying relationship</li>
    <li>Primary key ≠ Partial key</li>
</ul>

<p>Miss these and marks evaporate.</p>
<h2>Attributes in ER Model (In Depth)</h2>

<p>An attribute describes a property of an entity or a relationship.</p>

<p><strong>Example:</strong></p>
<p>Entity = STUDENT</p>
<p>Attributes = RollNo, Name, Age, Phone, DOB</p>

<h3>1. Simple (Atomic) Attribute</h3>

<p><strong>Definition</strong></p>

<p>A simple attribute cannot be divided into smaller meaningful parts.</p>

<p><strong>Example</strong></p>

<ul>
    <li>RollNo</li>
    <li>Age</li>
    <li>Gender</li>
</ul>

<p>You can’t split these without destroying meaning.</p>

<p><strong>Textual Diagram</strong></p>

<pre>
STUDENT
 ├── RollNo
 ├── Age
 └── Gender
</pre>

<p><strong>Real-world note</strong></p>

<p>If you try to split “Age” into years, months, days, you are not designing a database. You are designing pain.</p>

<h3>2. Composite Attribute</h3>

<p><strong>Definition</strong></p>

<p>A composite attribute can be broken down into smaller sub-attributes that are meaningful.</p>

<p><strong>Example</strong></p>

<p>Attribute: Name</p>

<ul>
    <li>FirstName</li>
    <li>MiddleName</li>
    <li>LastName</li>
</ul>

<p>Attribute: Address</p>

<ul>
    <li>Street</li>
    <li>City</li>
    <li>State</li>
    <li>Pincode</li>
</ul>

<p><strong>Textual Diagram</strong></p>

<pre>
STUDENT
 ├── Name
 │    ├── FirstName
 │    ├── MiddleName
 │    └── LastName
 └── Address
      ├── Street
      ├── City
      ├── State
      └── Pincode
</pre>

<p><strong>Key Point</strong></p>

<p>In relational tables, only the simple components are stored, not the composite attribute itself.</p>

<h3>3. Multivalued Attribute</h3>

<p><strong>Definition</strong></p>

<p>A multivalued attribute can have more than one value for a single entity.</p>

<p><strong>Example</strong></p>

<ul>
    <li>PhoneNumbers</li>
    <li>EmailIDs</li>
    <li>Skills</li>
</ul>

<p>A student can have multiple phone numbers.</p>

<p><strong>ER Notation</strong></p>

<p>Represented by double oval (because one oval clearly wasn’t enough).</p>

<p><strong>Textual Diagram</strong></p>

<pre>
STUDENT
 ├── RollNo
 ├── Name
 └── PhoneNumbers {Phone1, Phone2, Phone3}
</pre>

<p>Or more formally:</p>

<pre>
STUDENT
 └── PhoneNumber
      ├── Phone1
      ├── Phone2
      └── Phone3
</pre>

<p><strong>Mapping to Tables</strong></p>

<p>Multivalued attributes require a separate table.</p>

<pre>
STUDENT(RollNo, Name)
STUDENT_PHONE(RollNo, PhoneNumber)
</pre>

<p>This is not optional. DBMS will punish you otherwise.</p>

<h3>4. Derived Attribute</h3>

<p><strong>Definition</strong></p>

<p>A derived attribute is calculated from other stored attributes and usually not stored in the database.</p>

<p><strong>Example</strong></p>

<ul>
    <li>Age derived from DateOfBirth</li>
    <li>TotalMarks derived from individual marks</li>
</ul>

<p><strong>Textual Diagram</strong></p>

<pre>
STUDENT
 ├── DateOfBirth
 └── Age (derived)
</pre>

<p><strong>Formula:</strong></p>

<p>Age = CurrentDate − DateOfBirth</p>

<p><strong>Key Rule</strong></p>

<p>Store DOB</p>
<p>Derive Age</p>

<p>If you store Age, it will become wrong every year. Databases remember everything. Including mistakes.</p>

<h3>Combined Example (All Attribute Types)</h3>

<p>Entity: STUDENT</p>

<pre>
STUDENT
 ├── RollNo (Simple, Key)
 ├── Name (Composite)
 │    ├── FirstName
 │    └── LastName
 ├── Address (Composite)
 │    ├── City
 │    └── Pincode
 ├── PhoneNumber (Multivalued)
 ├── DateOfBirth (Simple)
 └── Age (Derived)
</pre>

<h3>Quick Comparison Table</h3>

<table border="1" cellpadding="8" cellspacing="0">
    <tr>
        <th>Attribute Type</th>
        <th>Can be split</th>
        <th>Multiple values</th>
        <th>Stored in DB</th>
    </tr>
    <tr>
        <td>Simple</td>
        <td>No</td>
        <td>No</td>
        <td>Yes</td>
    </tr>
    <tr>
        <td>Composite</td>
        <td>Yes</td>
        <td>No</td>
        <td>Components only</td>
    </tr>
    <tr>
        <td>Multivalued</td>
        <td>No</td>
        <td>Yes</td>
        <td>Separate table</td>
    </tr>
    <tr>
        <td>Derived</td>
        <td>No</td>
        <td>No</td>
        <td>Usually No</td>
    </tr>
</table>
<h2>1. Super Key</h2>

<h3>Definition</h3>
<p>A super key is any set of one or more attributes that can uniquely identify a tuple (row) in a relation.</p>

<p>It must guarantee uniqueness</p>
<p>It may contain extra attributes that are not needed</p>
<p>Think of it as “definitely unique, maybe overkill.”</p>

<h3>Example Table: STUDENT</h3>

<table>
    <tr>
        <th>RollNo</th>
        <th>Email</th>
        <th>Phone</th>
        <th>Name</th>
    </tr>
    <tr>
        <td>101</td>
        <td>a@nitc.ac.in</td>
        <td>9876</td>
        <td>Abhi</td>
    </tr>
    <tr>
        <td>102</td>
        <td>b@nitc.ac.in</td>
        <td>9123</td>
        <td>Ravi</td>
    </tr>
</table>

<h3>Super Keys</h3>
<ul>
    <li>{RollNo}</li>
    <li>{Email}</li>
    <li>{RollNo, Name}</li>
    <li>{RollNo, Email}</li>
    <li>{Email, Phone}</li>
</ul>

<p>If it uniquely identifies a row, it qualifies. Even if it’s absurdly large.</p>

<h3>Textual Diagram</h3>
<p>All Super Keys</p>
<pre>
┌──────────────────────────┐
│ {RollNo}                 │
│ {Email}                  │
│ {RollNo, Name}           │
│ {RollNo, Email}          │
│ {Email, Phone}           │
│ ... many more            │
└──────────────────────────┘
</pre>

<h2>2. Candidate Key</h2>

<h3>Definition</h3>
<p>A candidate key is a minimal super key.</p>

<p>Uniquely identifies a tuple</p>
<p>No proper subset of it can do the same</p>
<p>“Minimal” is the keyword examiners adore</p>

<h3>From the Same Table</h3>
<p>Candidate Keys</p>
<ul>
    <li>{RollNo}</li>
    <li>{Email}</li>
</ul>

<p>Why not {RollNo, Name}?</p>
<p>Because {RollNo} alone already works. Extra attribute = rejected.</p>

<h3>Textual Diagram</h3>
<p>Super Keys</p>
<pre>
┌────────────────────────────┐
│ {RollNo}   ← Candidate Key │
│ {Email}    ← Candidate Key │
│ {RollNo, Name}             │
│ {RollNo, Email}            │
└────────────────────────────┘
</pre>

<p>Candidate keys are the smallest survivors.</p>

<h2>3. Primary Key</h2>

<h3>Definition</h3>
<p>A primary key is one candidate key chosen by the database designer to identify tuples.</p>

<p>Must be unique</p>
<p>Must be NOT NULL</p>
<p>Only one primary key per table</p>

<p>Reality check: when multiple candidate keys exist, humans panic and pick one.</p>

<h3>Example</h3>
<p>Primary Key chosen: RollNo</p>

<table>
    <tr>
        <th>RollNo (PK)</th>
        <th>Email</th>
        <th>Phone</th>
        <th>Name</th>
    </tr>
    <tr>
        <td>101</td>
        <td>a@nitc.ac.in</td>
        <td>9876</td>
        <td>Abhi</td>
    </tr>
    <tr>
        <td>102</td>
        <td>b@nitc.ac.in</td>
        <td>9123</td>
        <td>Ravi</td>
    </tr>
</table>

<p>Email stays unique, but RollNo gets the crown.</p>

<h3>Textual Diagram</h3>
<p>Candidate Keys</p>
<pre>
┌─────────────────────┐
│ {RollNo}  ← PK      │
│ {Email}             │
└─────────────────────┘
</pre>

<p>Primary key = chosen one, not only one.</p>

<h2>4. Foreign Key</h2>

<h3>Definition</h3>
<p>A foreign key is an attribute in one table that references the primary key of another table.</p>

<p>Enforces referential integrity</p>
<p>Prevents orphan records</p>
<p>Exists solely to keep humans from ruining data</p>

<h3>Example Tables</h3>

<h4>STUDENT</h4>
<table>
    <tr>
        <th>RollNo (PK)</th>
        <th>Name</th>
    </tr>
    <tr>
        <td>101</td>
        <td>Abhi</td>
    </tr>
    <tr>
        <td>102</td>
        <td>Ravi</td>
    </tr>
</table>

<h4>ENROLLMENT</h4>
<table>
    <tr>
        <th>EnrollID</th>
        <th>RollNo (FK)</th>
        <th>Course</th>
    </tr>
    <tr>
        <td>1</td>
        <td>101</td>
        <td>DBMS</td>
    </tr>
    <tr>
        <td>2</td>
        <td>102</td>
        <td>OS</td>
    </tr>
</table>

<p>Here:</p>
<p>ENROLLMENT.RollNo is a foreign key</p>
<p>It references STUDENT.RollNo</p>
<p>You can’t insert RollNo = 999 unless you enjoy constraint violations.</p>

<h3>Textual Diagram</h3>
<pre>
STUDENT                         ENROLLMENT
┌──────────────┐               ┌───────────────┐
│ RollNo (PK)  │◄──────────────│ RollNo (FK)   │
│ Name         │               │ Course        │
└──────────────┘               └───────────────┘
</pre>

<h2>5. Relationship Between All Keys</h2>
<pre>
Super Key
┌───────────────────────────────┐
│ Candidate Keys                │
│ ┌───────────────────────────┐ │
│ │ Primary Key                │ │
│ └───────────────────────────┘ │
└───────────────────────────────┘
</pre>

<p>Foreign key lives outside this hierarchy, connecting tables like a nervous messenger.</p>

<h2>6. One-Line Exam Differentiation (Very Important)</h2>

<table>
    <tr>
        <th>Key Type</th>
        <th>Uniqueness</th>
        <th>Minimal</th>
        <th>Chosen</th>
        <th>References Other Table</th>
    </tr>
    <tr>
        <td>Super Key</td>
        <td>Yes</td>
        <td>No</td>
        <td>No</td>
        <td>No</td>
    </tr>
    <tr>
        <td>Candidate Key</td>
        <td>Yes</td>
        <td>Yes</td>
        <td>No</td>
        <td>No</td>
    </tr>
    <tr>
        <td>Primary Key</td>
        <td>Yes</td>
        <td>Yes</td>
        <td>Yes</td>
        <td>No</td>
    </tr>
    <tr>
        <td>Foreign Key</td>
        <td>No</td>
        <td>—</td>
        <td>—</td>
        <td>Yes</td>
    </tr>
</table>

<h2>1. What is a Relationship?</h2>

<p>A relationship represents an association between two or more entities.</p>

<p>It answers questions like:</p>

<ul>
    <li>Which student enrolls in which course?</li>
    <li>Which employee works in which department?</li>
</ul>

<p>If entities are nouns, relationships are the verbs keeping them busy.</p>

<h2>2. Relationship Set</h2>

<p>A relationship set is a collection of similar relationships.</p>

<ul>
    <li>Entity → Individual object</li>
    <li>Entity Set → Collection of entities</li>
    <li>Relationship → Association between entities</li>
    <li>Relationship Set → Collection of associations of the same type</li>
</ul>

<p><strong>Example</strong></p>

<p>Entity Sets: Student, Course</p>

<p>Relationship: Student A enrolls in Course B</p>

<p>Relationship Set: ENROLLS</p>

<h2>3. Degree of a Relationship</h2>

<p>The degree is the number of participating entity sets.</p>

<h3>(a) Unary Relationship (Degree 1)</h3>

<p>Relationship within the same entity set.</p>

<p>Example: Employee supervises Employee</p>

<pre>
Employee
   | supervises
Employee
</pre>

<h3>(b) Binary Relationship (Degree 2)</h3>

<p>Most common. Between two entity sets.</p>

<p>Example: Student enrolls in Course</p>

<pre>
Student -------- ENROLLS -------- Course
</pre>

<h3>(c) Ternary Relationship (Degree 3)</h3>

<p>Between three entity sets.</p>

<p>Example: Supplier supplies Part to Project</p>

<pre>
Supplier
    |
    | supplies
    |
Part -------- Project
</pre>

<h2>4. Attributes of a Relationship</h2>

<p>Relationships can have their own attributes.</p>

<p>These attributes do not belong to either entity alone.</p>

<p>Example</p>

<p>Relationship: ENROLLS</p>

<p>Attributes: Grade, Semester</p>

<pre>
Student ---- ENROLLS (Grade, Semester) ---- Course
</pre>

<p>Why not put Grade in Student or Course?</p>

<p>Because grades depend on both the student and the course.</p>

<h2>5. Cardinality Constraints</h2>

<p>Cardinality defines how many entities can participate in a relationship.</p>

<h3>(a) One-to-One (1:1)</h3>

<p>One entity is related to at most one entity.</p>

<p>Example: Person – Passport</p>

<pre>
Person -------- HAS -------- Passport
  (1)                      (1)
</pre>

<h3>(b) One-to-Many (1:N)</h3>

<p>One entity relates to many entities.</p>

<p>Example: Department – Employee</p>

<pre>
Department -------- HAS -------- Employee
   (1)                     (N)
</pre>

<h3>(c) Many-to-Many (M:N)</h3>

<p>Entities on both sides can have many relationships.</p>

<p>Example: Student – Course</p>

<pre>
Student -------- ENROLLS -------- Course
   (M)                      (N)
</pre>

<h2>6. Participation Constraints</h2>

<p>Defines whether participation is mandatory or optional.</p>

<h3>(a) Total Participation</h3>

<p>Every entity must participate.</p>

<p>Example: Every employee must belong to a department</p>

<pre>
Employee ==WORKS_IN== Department
   (Total)
</pre>

<p>(Double line indicates total participation.)</p>

<h3>(b) Partial Participation</h3>

<p>Some entities may not participate.</p>

<p>Example: Some customers may not place orders</p>

<pre>
Customer ---- PLACES ---- Order
   (Partial)
</pre>

<h2>7. Identifying Relationship (Weak Entity)</h2>

<p>A weak entity cannot exist without a strong entity.</p>

<p>Example</p>

<p>Strong Entity: Employee</p>

<p>Weak Entity: Dependent</p>

<p>Relationship: DEPENDS_ON</p>

<pre>
Employee ==DEPENDS_ON== Dependent
</pre>

<p>Double diamond → identifying relationship</p>

<p>Partial key identifies weak entity</p>

<h2>8. Relationship Set vs Entity Set (Important Difference)</h2>

<table border="1" cellpadding="8" cellspacing="0">
    <tr>
        <th>Feature</th>
        <th>Entity Set</th>
        <th>Relationship Set</th>
    </tr>
    <tr>
        <td>Represents</td>
        <td>Objects</td>
        <td>Associations</td>
    </tr>
    <tr>
        <td>Has attributes</td>
        <td>Yes</td>
        <td>Yes</td>
    </tr>
    <tr>
        <td>Has primary key</td>
        <td>Yes</td>
        <td>No (uses entity keys)</td>
    </tr>
    <tr>
        <td>Example</td>
        <td>Student</td>
        <td>ENROLLS</td>
    </tr>
</table>

<h2>9. Mapping Relationship Sets to Tables</h2>

<p><strong>Binary M:N Relationship</strong></p>

<p>Create a separate table.</p>

<p>Example: ENROLLS</p>

<table border="1" cellpadding="8" cellspacing="0">
    <tr>
        <th>Student_ID</th>
        <th>Course_ID</th>
        <th>Grade</th>
    </tr>
</table>

<p>Primary Key = (Student_ID, Course_ID)</p>

<p><strong>Binary 1:N Relationship</strong></p>

<p>Add foreign key on the N side.</p>

<p>Example: Department–Employee</p>

<table border="1" cellpadding="8" cellspacing="0">
    <tr>
        <th>Employee_ID</th>
        <th>Name</th>
        <th>Dept_ID</th>
    </tr>
</table>
<h1>Cardinality and Participation Constraints (ER Model)</h1>

<p>These constraints describe how entities are allowed to participate in relationships. In short:</p>

<p><strong>Cardinality</strong> answers “how many?”</p>
<p><strong>Participation</strong> answers “must or optional?”</p>

<p>They are different. People mix them up. Marks are lost. Life goes on.</p>

<h2>1. Cardinality Constraint</h2>

<h3>Definition</h3>

<p>A cardinality constraint specifies the number of entities of one set that can be associated with entities of another set through a relationship.</p>

<h3>Types of Cardinality</h3>

<h4>1. One-to-One (1:1)</h4>

<p>One entity in A is related to at most one entity in B.</p>
<p>And vice versa.</p>

<p><strong>Example:</strong><br>
Person ↔ Passport<br>
One person has one passport. One passport belongs to one person.</p>

<p><strong>Textual ER Diagram</strong></p>

<pre>
[Person] 1 ───── has ───── 1 [Passport]
</pre>

<h4>2. One-to-Many (1:N)</h4>

<p>One entity in A can be related to many entities in B.</p>
<p>Each entity in B is related to only one entity in A.</p>

<p><strong>Example:</strong><br>
Department ↔ Employee<br>
A department has many employees. An employee belongs to one department.</p>

<p><strong>Textual ER Diagram</strong></p>

<pre>
[Department] 1 ───── employs ───── N [Employee]
</pre>

<h4>3. Many-to-One (N:1)</h4>

<p>Multiple entities in A relate to a single entity in B.</p>

<p><strong>Example:</strong><br>
Employee ↔ Project Manager<br>
Many employees report to one manager.</p>

<p><strong>Textual ER Diagram</strong></p>

<pre>
[Employee] N ───── reports_to ───── 1 [Manager]
</pre>

<h4>4. Many-to-Many (M:N)</h4>

<p>Multiple entities in A can be related to multiple entities in B.</p>

<p><strong>Example:</strong><br>
Student ↔ Course<br>
A student enrolls in many courses. A course has many students.</p>

<p><strong>Textual ER Diagram</strong></p>

<pre>
[Student] M ───── enrolls ───── N [Course]
</pre>

<h3>Cardinality Ratio Summary</h3>

<table border="1" cellpadding="8" cellspacing="0">
    <tr>
        <th>Relationship</th>
        <th>Meaning</th>
    </tr>
    <tr>
        <td>1:1</td>
        <td>One entity ↔ One entity</td>
    </tr>
    <tr>
        <td>1:N</td>
        <td>One entity ↔ Many entities</td>
    </tr>
    <tr>
        <td>N:1</td>
        <td>Many entities ↔ One entity</td>
    </tr>
    <tr>
        <td>M:N</td>
        <td>Many entities ↔ Many entities</td>
    </tr>
</table>

<h2>2. Participation Constraint</h2>

<h3>Definition</h3>

<p>A participation constraint specifies whether participation in a relationship is mandatory or optional for an entity.</p>

<p>In human terms:</p>

<p>“Does this entity HAVE to be in this relationship to exist?”</p>

<h3>Types of Participation</h3>

<h4>1. Total Participation (Mandatory)</h4>

<p>Every entity must participate in at least one relationship instance.</p>

<p>Shown using double line in ER diagrams.</p>

<p><strong>Example:</strong><br>
Employee ↔ Department<br>
Every employee must belong to a department.</p>

<p><strong>Textual ER Diagram</strong></p>

<pre>
[Employee] ══ works_in ───── [Department]
</pre>

<p><strong>Meaning:</strong><br>
No employee can exist without a department.</p>

<h4>2. Partial Participation (Optional)</h4>

<p>Some entities may not participate in the relationship.</p>

<p>Shown using single line.</p>

<p><strong>Example:</strong><br>
Department ↔ Employee<br>
A department may exist even if it has no employees.</p>

<p><strong>Textual ER Diagram</strong></p>

<pre>
[Department] ───── employs ───── [Employee]
</pre>

<h3>3. Cardinality vs Participation (Side-by-Side)</h3>

<table border="1" cellpadding="8" cellspacing="0">
    <tr>
        <th>Aspect</th>
        <th>Cardinality</th>
        <th>Participation</th>
    </tr>
    <tr>
        <td>Question answered</td>
        <td>How many?</td>
        <td>Mandatory or optional?</td>
    </tr>
    <tr>
        <td>Focus</td>
        <td>Number of entities</td>
        <td>Existence dependency</td>
    </tr>
    <tr>
        <td>Representation</td>
        <td>1, N, M</td>
        <td>Single line / Double line</td>
    </tr>
    <tr>
        <td>Example</td>
        <td>One department → many employees</td>
        <td>Employee must belong to department</td>
    </tr>
</table>

<h2>4. Combined Example (Very Important for Exams)</h2>

<h3>Scenario</h3>

<p>University database.</p>

<p>A student must enroll in at least one course</p>
<p>A course may have zero or more students</p>

<h3>Constraints</h3>

<p><strong>Cardinality:</strong> M:N</p>

<p><strong>Participation:</strong><br>
Student → Total<br>
Course → Partial</p>

<p><strong>Textual ER Diagram</strong></p>

<pre>
[Student] ══ enrolls ══ M ───── N ───── [Course]
</pre>

<p><strong>Interpretation:</strong></p>

<p>A student cannot exist without enrollment.</p>
<p>A course can exist without students.</p>

<h2>5. Another Classic Example (Weak Entity Case)</h2>

<h3>Scenario</h3>

<p>Company ↔ Dependent</p>

<p>A dependent cannot exist without an employee</p>

<h3>Constraints</h3>

<p><strong>Cardinality:</strong> 1:N</p>

<p><strong>Participation:</strong><br>
Dependent → Total<br>
Employee → Partial</p>

<p><strong>Textual ER Diagram</strong></p>

<pre>
[Employee] ───── has ───── N ══ [Dependent]
</pre>

<p>This is how examiners check if you understand existence dependency, not just symbols.</p>

<h2>6. Minimum–Maximum Notation (Advanced but Useful)</h2>

<p>Instead of 1, N, we sometimes specify ranges.</p>

<p><strong>Example:</strong><br>
Employee works on 1 to 3 projects.</p>

<pre>
[Employee] (1,3) ───── works_on ───── (0,N) [Project]
</pre>

<p>Employee: must work on at least 1, at most 3 projects</p>
<p>Project: optional, unlimited employees</p>

<h2>7. Common Mistakes (Avoid These)</h2>

<ul>
    <li>Saying 1:N automatically means total participation. It doesn’t.</li>
    <li>Forgetting that cardinality ≠ participation</li>
    <li>Not mentioning both sides of the relationship</li>
    <li>Drawing total participation without explaining “why mandatory”</li>
</ul>
<h1>Relational algebra</h1>

<p>Fine. Back to first principles. The boring foundations that quietly decide whether you pass DBMS or stare at the question paper like it betrayed you.</p>

<p>I’ll go slow, precise, and exam-proof. No fluff, no motivational nonsense.</p>

<h2>1. Relation</h2>

<h3>Definition</h3>
<p>A relation is a table in the relational model.</p>

<p><strong>Formally:</strong><br>
A relation is a set of tuples defined over a fixed set of attributes.</p>

<p><strong>Key word:</strong> set</p>

<p><strong>Meaning:</strong></p>
<ul>
    <li>No duplicate rows</li>
    <li>Order of rows does not matter</li>
    <li>Order of columns does not matter</li>
</ul>

<h3>Notation</h3>
<pre>RelationName(Attribute1, Attribute2, Attribute3, ...)</pre>

<h3>Example</h3>
<pre>STUDENT(RollNo, Name, Branch, CGPA)</pre>

<p>This entire table is a relation.</p>

<h3>Properties of a Relation</h3>
<ul>
    <li>Relation name is unique</li>
    <li>Each attribute has a unique name</li>
    <li>All values in a column come from the same domain</li>
    <li>Each cell contains atomic (indivisible) values</li>
    <li>No duplicate tuples</li>
</ul>

<h3>Textual Diagram (Relation)</h3>
<pre>
STUDENT
------------------------------------------------
| RollNo |   Name   |  Branch  |   CGPA        |
------------------------------------------------
| 101    | Abhishek |   CSE    |   8.7         |
| 102    | Rahul    |   ECE    |   8.1         |
| 103    | Neha     |   ME     |   7.9         |
------------------------------------------------
</pre>

<p>This entire structure = one relation</p>

<h2>2. Tuple</h2>

<h3>Definition</h3>
<p>A tuple is a single row in a relation.</p>

<p><strong>Formally:</strong><br>
A tuple is an ordered set of attribute values.</p>

<h3>Example</h3>
<p>From the STUDENT relation:</p>
<pre>(101, Abhishek, CSE, 8.7)</pre>

<p>This is one tuple.</p>

<h3>Key Points About Tuples</h3>
<ul>
    <li>Each tuple represents one real-world entity</li>
    <li>No two tuples are identical in a relation</li>
    <li>Number of tuples = cardinality of relation</li>
</ul>

<h3>Cardinality Example</h3>
<p>If STUDENT has 3 rows:</p>
<pre>Cardinality(STUDENT) = 3</pre>

<h3>Textual Diagram (Tuple Highlighted)</h3>
<pre>
STUDENT
------------------------------------------------
| RollNo |   Name   |  Branch  |   CGPA        |
------------------------------------------------
| 101    | Abhishek |   CSE    |   8.7   <-- tuple
------------------------------------------------
</pre>

<p>That one row you’re pointing at = tuple</p>

<h2>3. Attribute</h2>

<h3>Definition</h3>
<p>An attribute is a column in a relation.</p>

<p><strong>Formally:</strong><br>
An attribute represents a property or characteristic of an entity.</p>

<h3>Example</h3>
<p>In STUDENT relation:</p>
<ul>
    <li>RollNo</li>
    <li>Name</li>
    <li>Branch</li>
    <li>CGPA</li>
</ul>

<p>Each of these is an attribute.</p>

<h3>Domain</h3>
<p>Each attribute has a domain (allowed values).</p>

<table>
    <tr>
        <th>Attribute</th>
        <th>Domain Example</th>
    </tr>
    <tr>
        <td>RollNo</td>
        <td>Positive integers</td>
    </tr>
    <tr>
        <td>Name</td>
        <td>Alphabetic strings</td>
    </tr>
    <tr>
        <td>Branch</td>
        <td>{CSE, ECE, ME, CE}</td>
    </tr>
    <tr>
        <td>CGPA</td>
        <td>0.0 – 10.0</td>
    </tr>
</table>

<h3>Textual Diagram (Attribute Highlighted)</h3>
<pre>
STUDENT
------------------------------------------------
| RollNo |   Name   |  Branch  |   CGPA        |
------------------------------------------------
   ^
   |
 Attribute
</pre>

<p>That vertical slice = attribute</p>

<h3>Relation vs Tuple vs Attribute (One-Glance Table)</h3>
<table>
    <tr>
        <th>Term</th>
        <th>Meaning</th>
        <th>Real-life analogy</th>
    </tr>
    <tr>
        <td>Relation</td>
        <td>Table</td>
        <td>Register</td>
    </tr>
    <tr>
        <td>Tuple</td>
        <td>Row</td>
        <td>One student entry</td>
    </tr>
    <tr>
        <td>Attribute</td>
        <td>Column</td>
        <td>Field like Name, RollNo</td>
    </tr>
</table>

<h2>Schema vs Instance (Important Exam Trap)</h2>

<h3>Relation Schema</h3>
<ul>
    <li>Structure of relation</li>
</ul>
<pre>STUDENT(RollNo, Name, Branch, CGPA)</pre>

<h3>Relation Instance</h3>
<ul>
    <li>Actual data at a moment</li>
</ul>
<pre>
{ (101, Abhishek, CSE, 8.7),
  (102, Rahul, ECE, 8.1) }
</pre>

<p>Schema is fixed, instance changes.</p>
<h1>1. What Is a Domain in DBMS?</h1>

<p>A domain is the set of all valid values that an attribute can take.</p>

<p>Think of it as:</p>
<ul>
    <li>A type</li>
    <li>With rules</li>
    <li>And boundaries</li>
</ul>

<p>So your database doesn’t accept nonsense and smile about it.</p>

<p><strong>Formal definition:</strong><br>
A domain is a logical definition of permissible values for an attribute, including data type, range, and constraints.</p>

<h1>2. Why Domains Exist (Because Humans Are Creative With Wrong Input)</h1>

<p>Without domains:</p>
<ul>
    <li>Age = "twenty five"</li>
    <li>Salary = -9000</li>
    <li>Date = 31-Feb-2025</li>
</ul>

<p>With domains:</p>
<p>Database says “no” and means it.</p>

<h1>3. Components of a Domain</h1>

<p>A domain is not just a data type. It includes:</p>

<ul>
    <li>
        <strong>Data type</strong>
        <ul>
            <li>INT, CHAR, VARCHAR, DATE, FLOAT</li>
        </ul>
    </li>
    <li>
        <strong>Size / Length</strong>
        <ul>
            <li>VARCHAR(20), CHAR(10)</li>
        </ul>
    </li>
    <li>
        <strong>Range of values</strong>
        <ul>
            <li>Age: 0 to 120</li>
            <li>Marks: 0 to 100</li>
        </ul>
    </li>
    <li>
        <strong>Format (optional)</strong>
        <ul>
            <li>Email pattern</li>
            <li>Phone number pattern</li>
        </ul>
    </li>
    <li>
        <strong>Constraints</strong>
        <ul>
            <li>NOT NULL</li>
            <li>CHECK</li>
            <li>DEFAULT</li>
        </ul>
    </li>
</ul>

<h1>4. Example: Student Database</h1>

<h2>Attributes and Domains</h2>

<table>
    <tr>
        <th>Attribute</th>
        <th>Domain</th>
    </tr>
    <tr>
        <td>StudentID</td>
        <td>Integer &gt; 0</td>
    </tr>
    <tr>
        <td>Name</td>
        <td>VARCHAR(30), NOT NULL</td>
    </tr>
    <tr>
        <td>Age</td>
        <td>Integer between 18 and 30</td>
    </tr>
    <tr>
        <td>CGPA</td>
        <td>Float between 0.0 and 10.0</td>
    </tr>
    <tr>
        <td>Email</td>
        <td>Valid email format</td>
    </tr>
</table>

<h1>5. Textual Diagram: Attribute–Domain Mapping</h1>

<pre>
+------------------+        +-----------------------------+
|     ATTRIBUTE    | -----> |           DOMAIN            |
+------------------+        +-----------------------------+
| StudentID        |        | INTEGER, > 0                |
| Name             |        | VARCHAR(30), NOT NULL       |
| Age              |        | INTEGER, 18 ≤ Age ≤ 30      |
| CGPA             |        | FLOAT, 0.0 ≤ CGPA ≤ 10.0    |
| Email            |        | VARCHAR(50), Email format   |
+------------------+        +-----------------------------+
</pre>

<p><strong>Attribute doesn’t decide rules.</strong><br>
<strong>Domain does. Authority matters.</strong></p>

<h1>6. Domain in SQL (Practical Example)</h1>

<h2>Creating a Domain (SQL Standard)</h2>

<pre>
CREATE DOMAIN AgeDomain INT
CHECK (VALUE BETWEEN 18 AND 30);

CREATE DOMAIN CGPADomain FLOAT
CHECK (VALUE >= 0.0 AND VALUE <= 10.0);
</pre>

<h2>Using the Domain</h2>

<pre>
CREATE TABLE Student (
    StudentID INT PRIMARY KEY,
    Name VARCHAR(30) NOT NULL,
    Age AgeDomain,
    CGPA CGPADomain
);
</pre>

<p>Now every table using AgeDomain follows the same rules.<br>
Consistency achieved. Humans prevented from freelancing.</p>

<h1>7. Domain vs Attribute (Very Exam-Friendly)</h1>

<table>
    <tr>
        <th>Aspect</th>
        <th>Domain</th>
        <th>Attribute</th>
    </tr>
    <tr>
        <td>Definition</td>
        <td>Set of allowed values</td>
        <td>Column in a table</td>
    </tr>
    <tr>
        <td>Reusability</td>
        <td>Reusable</td>
        <td>Table-specific</td>
    </tr>
    <tr>
        <td>Controls</td>
        <td>Type, range, constraints</td>
        <td>Uses domain rules</td>
    </tr>
    <tr>
        <td>Example</td>
        <td>Age: 18–30</td>
        <td>Student.Age</td>
    </tr>
</table>

<h1>8. Domain Constraints</h1>

<p>Domain constraints ensure:</p>
<ul>
    <li>Data correctness</li>
    <li>Uniform validation</li>
    <li>Reduced redundancy</li>
</ul>

<h2>Example Constraint</h2>

<pre>
Age ∈ { x | 18 ≤ x ≤ 30 }
</pre>

<p>Anything outside? Rejected. No debate.</p>

<h1>Schema vs Instance (In Depth)</h1>

<h2>1. What is a Schema?</h2>

<p>A schema is the logical blueprint of the database.</p>

<p>Think of it as the architectural plan. It defines what the database looks like, not what it currently contains.</p>

<h3>Key Characteristics of Schema</h3>
<ul>
    <li>Defined using DDL (CREATE, ALTER)</li>
    <li>Describes structure, not data</li>
    <li>Changes rarely</li>
    <li>Exists even if the database is empty</li>
    <li>Independent of time</li>
</ul>

<h3>What Schema Specifies</h3>
<ul>
    <li>Table names</li>
    <li>Attributes (columns)</li>
    <li>Data types</li>
    <li>Constraints (PRIMARY KEY, FOREIGN KEY, UNIQUE, CHECK)</li>
    <li>Relationships between tables</li>
</ul>

<h3>Example: Student Schema</h3>
<pre>
STUDENT(StudentID INT PRIMARY KEY,
        Name VARCHAR(50),
        Branch VARCHAR(10),
        Age INT)
</pre>

<p>This tells the DBMS:</p>
<ul>
    <li>What columns exist</li>
    <li>What type of data is allowed</li>
    <li>What rules must be followed</li>
</ul>

<p>No actual students yet. Just rules. Bureaucracy at its finest.</p>

<h2>2. What is an Instance?</h2>

<p>An instance is the actual data stored in the database at a specific moment in time.</p>

<p>This is the living, breathing part that keeps changing whenever:</p>
<ul>
    <li>A row is inserted</li>
    <li>A row is deleted</li>
    <li>A row is updated</li>
</ul>

<h3>Key Characteristics of Instance</h3>
<ul>
    <li>Defined using DML (INSERT, UPDATE, DELETE)</li>
    <li>Represents current data</li>
    <li>Changes frequently</li>
    <li>Time-dependent</li>
    <li>Exists only when data exists</li>
</ul>

<h3>Example: Student Instance (at time T₁)</h3>
<table>
    <tr>
        <th>StudentID</th>
        <th>Name</th>
        <th>Branch</th>
        <th>Age</th>
    </tr>
    <tr>
        <td>101</td>
        <td>Ravi</td>
        <td>CSE</td>
        <td>20</td>
    </tr>
    <tr>
        <td>102</td>
        <td>Anita</td>
        <td>ECE</td>
        <td>21</td>
    </tr>
</table>

<p>Two rows. Two humans. Plenty of potential mistakes.</p>

<h2>3. Schema vs Instance: Core Difference</h2>

<table>
    <tr>
        <th>Feature</th>
        <th>Schema</th>
        <th>Instance</th>
    </tr>
    <tr>
        <td>Meaning</td>
        <td>Structure of database</td>
        <td>Actual data</td>
    </tr>
    <tr>
        <td>Defined by</td>
        <td>DDL</td>
        <td>DML</td>
    </tr>
    <tr>
        <td>Changes</td>
        <td>Rarely</td>
        <td>Frequently</td>
    </tr>
    <tr>
        <td>Time dependent</td>
        <td>No</td>
        <td>Yes</td>
    </tr>
    <tr>
        <td>Example</td>
        <td>Table definition</td>
        <td>Table contents</td>
    </tr>
    <tr>
        <td>Also called</td>
        <td>Intension</td>
        <td>Extension</td>
    </tr>
</table>

<p><strong>Remember this:</strong></p>
<p>Schema is the plan. Instance is the snapshot.</p>

<h2>4. Textual Diagram (Very Exam-Friendly)</h2>

<pre>
DATABASE
│
├── Schema (Structure)
│   └── STUDENT(StudentID, Name, Branch, Age)
│
└── Instance (Data at Time T₁)
    ┌───────────┬────────┬────────┬─────┐
    │ StudentID │ Name   │ Branch │ Age │
    ├───────────┼────────┼────────┼─────┤
    │ 101       │ Ravi   │ CSE    │ 20  │
    │ 102       │ Anita  │ ECE    │ 21  │
    └───────────┴────────┴────────┴─────┘
</pre>

<p>If you redraw this in the exam, the evaluator will relax slightly.</p>

<h2>5. Time-Based View (Important Concept)</h2>

<p>Same schema, different instances.</p>

<p><strong>Schema:</strong></p>
<pre>STUDENT(StudentID, Name, Branch, Age)</pre>

<p><strong>Instance at T₁:</strong></p>
<pre>
{ (101, Ravi, CSE, 20) }
</pre>

<p><strong>Instance at T₂:</strong></p>
<pre>
{ (101, Ravi, CSE, 21),
  (103, Neha, ME, 20) }
</pre>

<p>Schema stayed the same.<br>
Instance aged, grew, and caused storage problems.</p>

<h2>6. Real-Life Analogy (Because Humans Need Stories)</h2>

<p><strong>Schema →</strong> College admission form format</p>
<p><strong>Instance →</strong> Filled admission forms today</p>

<p>The form does not change every day.<br>
The students filling it do.</p>
<h1>Relational Database Constraints</h1>

<h2>1. What Are Relational Database Constraints?</h2>

<p>Constraints are rules enforced by the DBMS to maintain:</p>
<ul>
    <li>Accuracy</li>
    <li>Consistency</li>
    <li>Integrity</li>
</ul>

<p>They prevent garbage data from entering the database, which humans are otherwise very enthusiastic about.</p>

<h2>2. Types of Relational Database Constraints</h2>

<h3>1️⃣ Domain Constraint</h3>

<p><strong>Definition:</strong><br>
Restricts the values an attribute can take.</p>

<p><strong>Enforced by:</strong></p>
<ul>
    <li>Data type</li>
    <li>Size</li>
    <li>Range</li>
    <li>Format</li>
</ul>

<p><strong>Example</strong></p>
<pre>Age INT CHECK (Age >= 18)</pre>

<p><strong>Textual Diagram</strong></p>
<pre>
STUDENT
--------------------
Age ∈ {18, 19, 20, ...}
Age ∉ {-1, 0, 12, "twenty"}
</pre>

<p>If the value doesn’t belong to the domain, the DBMS shuts the door.</p>

<h3>2️⃣ Key Constraint</h3>

<p><strong>Definition:</strong><br>
Ensures uniqueness of tuples in a relation.</p>

<p><strong>Types of Keys</strong></p>
<ul>
    <li>Super Key</li>
    <li>Candidate Key</li>
    <li>Primary Key</li>
    <li>Alternate Key</li>
</ul>

<p><strong>Example</strong></p>
<pre>RollNo INT PRIMARY KEY</pre>

<p><strong>Textual Diagram</strong></p>
<pre>
STUDENT
------------------------
RollNo | Name
------------------------
101    | Asha
102    | Ravi
101    | Neha   ❌ (Duplicate)
</pre>

<p>Primary keys do not tolerate clones.</p>

<h3>3️⃣ Entity Integrity Constraint</h3>

<p><strong>Definition:</strong><br>
Primary key cannot be NULL.</p>

<p><strong>Rule</strong></p>
<p>No attribute of a primary key can be NULL.</p>

<p><strong>Example</strong></p>
<pre>RollNo INT PRIMARY KEY</pre>

<p><strong>Textual Diagram</strong></p>
<pre>
STUDENT
------------------------
RollNo | Name
------------------------
NULL   | Aman   ❌
103    | Kiran  ✔
</pre>

<p>A row without identity is existentially unacceptable.</p>

<h3>4️⃣ Referential Integrity Constraint</h3>

<p><strong>Definition:</strong><br>
Ensures relationships between tables remain valid.</p>

<p>A foreign key must either:</p>
<ul>
    <li>Match a primary key in the referenced table, or</li>
    <li>Be NULL</li>
</ul>

<p><strong>Example</strong></p>
<pre>FOREIGN KEY (DeptID) REFERENCES DEPARTMENT(DeptID)</pre>

<p><strong>Textual Diagram</strong></p>
<pre>
DEPARTMENT
----------------
DeptID | DeptName
----------------
10     | CSE
20     | ECE

STUDENT
----------------------
RollNo | DeptID
----------------------
101    | 10   ✔
102    | 30   ❌ (No such department)
</pre>

<p>No imaginary departments allowed.</p>

<h3>5️⃣ CHECK Constraint</h3>

<p><strong>Definition:</strong><br>
Ensures attribute values satisfy a condition.</p>

<p><strong>Example</strong></p>
<pre>Salary INT CHECK (Salary > 0)</pre>

<p><strong>Textual Diagram</strong></p>
<pre>
EMPLOYEE
--------------------
Salary
--------------------
45000 ✔
-3000 ❌
</pre>

<p>Reality-based numbers only.</p>

<h3>6️⃣ NOT NULL Constraint</h3>

<p><strong>Definition:</strong><br>
Prevents NULL values in a column.</p>

<p><strong>Example</strong></p>
<pre>Name VARCHAR(50) NOT NULL</pre>

<p><strong>Textual Diagram</strong></p>
<pre>
EMPLOYEE
--------------------
Name
--------------------
"Rohit" ✔
NULL    ❌
</pre>

<p>If it’s required, it’s required.</p>

<h3>7️⃣ UNIQUE Constraint</h3>

<p><strong>Definition:</strong><br>
Ensures all values in a column are distinct.</p>

<p><strong>Example</strong></p>
<pre>Email VARCHAR(100) UNIQUE</pre>

<p><strong>Textual Diagram</strong></p>
<pre>
USERS
--------------------------
Email
--------------------------
a@x.com ✔
b@x.com ✔
a@x.com ❌
</pre>

<p>You get one identity. No duplicates.</p>

<h3>8️⃣ DEFAULT Constraint</h3>

<p><strong>Definition:</strong><br>
Provides a default value when none is supplied.</p>

<p><strong>Example</strong></p>
<pre>Status VARCHAR(10) DEFAULT 'ACTIVE'</pre>

<p><strong>Textual Diagram</strong></p>
<pre>
USER
--------------------
Status
--------------------
(NULL input) → ACTIVE
</pre>

<p>The database fills in the blanks because humans forget.</p>

<h2>3. Constraint Summary Table</h2>

<table>
    <tr>
        <th>Constraint Type</th>
        <th>Purpose</th>
    </tr>
    <tr>
        <td>Domain</td>
        <td>Valid value range</td>
    </tr>
    <tr>
        <td>Key</td>
        <td>Uniqueness</td>
    </tr>
    <tr>
        <td>Entity Integrity</td>
        <td>PK cannot be NULL</td>
    </tr>
    <tr>
        <td>Referential Integrity</td>
        <td>Valid table relationships</td>
    </tr>
    <tr>
        <td>CHECK</td>
        <td>Condition enforcement</td>
    </tr>
    <tr>
        <td>NOT NULL</td>
        <td>Mandatory attribute</td>
    </tr>
    <tr>
        <td>UNIQUE</td>
        <td>Distinct values</td>
    </tr>
    <tr>
        <td>DEFAULT</td>
        <td>Automatic value assignment</td>
    </tr>
</table>

<h2>4. Complete Example (All Constraints Together)</h2>

<pre>
CREATE TABLE DEPARTMENT (
    DeptID INT PRIMARY KEY,
    DeptName VARCHAR(50) NOT NULL
);

CREATE TABLE STUDENT (
    RollNo INT PRIMARY KEY,
    Name VARCHAR(50) NOT NULL,
    Age INT CHECK (Age >= 18),
    Email VARCHAR(100) UNIQUE,
    DeptID INT,
    FOREIGN KEY (DeptID) REFERENCES DEPARTMENT(DeptID)
);
</pre>

<h3>Relationship Diagram</h3>

<pre>
DEPARTMENT (DeptID PK)
        ▲
        |
STUDENT (DeptID FK)
</pre>

<p>Everything connected. Nothing imaginary. Order restored.</p>
<h1>Codd’s Rules (Relational Database Rules)</h1>

<p><strong>Proposed by:</strong> Dr. E. F. Codd<br>
<strong>Purpose:</strong> To define what a true Relational DBMS (RDBMS) must satisfy.</p>

<p><strong>Total rules:</strong> 12 (Rule 0 to Rule 12)</p>

<h2>Rule 0: Foundation Rule</h2>

<p>A system must manage databases entirely through relational capabilities.</p>

<h3>Meaning</h3>
<p>If a DBMS claims to be relational, everything must be done using relations (tables).</p>

<h3>Example</h3>

<p><strong>Bad system:</strong></p>
<ul>
    <li>Uses tables for data</li>
    <li>Uses separate file system for constraints or metadata</li>
</ul>

<p><strong>Good system:</strong></p>
<ul>
    <li>Data, constraints, views, security all stored as tables</li>
</ul>

<h2>Rule 1: Information Rule</h2>

<p>All information is represented logically as values in tables.</p>

<h3>Meaning</h3>
<p>No pointers, no objects, no secret files.<br>
Everything lives in rows and columns.</p>

<h3>Example</h3>

<p>STUDENT table:</p>

<table>
    <tr>
        <th>RollNo</th>
        <th>Name</th>
        <th>Dept</th>
    </tr>
    <tr>
        <td>101</td>
        <td>Rahul</td>
        <td>CSE</td>
    </tr>
    <tr>
        <td>102</td>
        <td>Anita</td>
        <td>ECE</td>
    </tr>
</table>

<p>Even metadata like table names is stored in system tables.</p>

<h2>Rule 2: Guaranteed Access Rule</h2>

<p>Every atomic value is accessible using:</p>
<ul>
    <li>Table name</li>
    <li>Primary key</li>
    <li>Column name</li>
</ul>

<h3>Example</h3>

<p>Access Rahul’s department:</p>

<pre>
SELECT Dept
FROM STUDENT
WHERE RollNo = 101;
</pre>

<p>No navigation. No pointers. No ritual chanting.</p>

<h2>Rule 3: Systematic Treatment of NULL Values</h2>

<p>NULLs must be supported and handled uniformly.</p>

<h3>Meaning</h3>
<ul>
    <li>NULL ≠ 0</li>
    <li>NULL ≠ empty string</li>
    <li>NULL means unknown / missing / not applicable</li>
</ul>

<h3>Example</h3>

<table>
    <tr>
        <th>RollNo</th>
        <th>Name</th>
        <th>Phone</th>
    </tr>
    <tr>
        <td>101</td>
        <td>Rahul</td>
        <td>NULL</td>
    </tr>
</table>

<p>Operations involving NULL follow 3-valued logic:</p>
<ul>
    <li>TRUE</li>
    <li>FALSE</li>
    <li>UNKNOWN</li>
</ul>

<h2>Rule 4: Dynamic Online Catalog</h2>

<p>Database description (metadata) must be stored as tables.</p>

<h3>Meaning</h3>
<p>Schema info should be queryable using SQL.</p>

<h3>Example</h3>

<table>
    <tr>
        <th>TableName</th>
        <th>Rows</th>
    </tr>
    <tr>
        <td>STUDENT</td>
        <td>200</td>
    </tr>
    <tr>
        <td>COURSE</td>
        <td>50</td>
    </tr>
</table>

<p>Query metadata like normal data:</p>

<pre>
SELECT TableName FROM SYSTEM_TABLES;
</pre>

<h2>Rule 5: Comprehensive Data Sublanguage Rule</h2>

<p>At least one language must support:</p>
<ul>
    <li>Data definition</li>
    <li>Data manipulation</li>
    <li>View definition</li>
    <li>Integrity constraints</li>
    <li>Authorization</li>
    <li>Transactions</li>
</ul>

<p>That language is SQL.</p>

<h3>Example</h3>

<pre>
CREATE TABLE STUDENT (...);
SELECT * FROM STUDENT;
GRANT SELECT ON STUDENT TO user1;
COMMIT;
</pre>

<h2>Rule 6: View Updating Rule</h2>

<p>All theoretically updatable views must be updatable.</p>

<h3>Example</h3>

<p>Base table:</p>

<table>
    <tr>
        <th>RollNo</th>
        <th>Name</th>
        <th>Dept</th>
    </tr>
</table>

<p>View:</p>

<pre>
CREATE VIEW CSE_STUDENTS AS
SELECT RollNo, Name
FROM STUDENT
WHERE Dept = 'CSE';
</pre>

<p>Update view:</p>

<pre>
INSERT INTO CSE_STUDENTS VALUES (105, 'Amit');
</pre>

<p>Should reflect in STUDENT table.</p>

<p>Most DBMS quietly fail here.</p>

<h2>Rule 7: High-Level Insert, Update, Delete</h2>

<p>Operations must work on sets, not just one row at a time.</p>

<h3>Example</h3>

<pre>
UPDATE STUDENT
SET Dept = 'AI'
WHERE Dept = 'CSE';
</pre>

<p>No loops. No row-by-row suffering.</p>

<h2>Rule 8: Physical Data Independence</h2>

<p>Changes in physical storage should not affect applications.</p>

<h3>Example</h3>
<ul>
    <li>Move data from HDD to SSD</li>
    <li>Change file organization</li>
</ul>

<p>Applications remain unchanged.</p>

<pre>
User Query
   |
SQL Layer
   |
Logical Schema
   |
Physical Storage (changed)
</pre>

<h2>Rule 9: Logical Data Independence</h2>

<p>Changes in logical schema should not break applications.</p>

<h3>Example</h3>

<pre>
ALTER TABLE STUDENT ADD Email VARCHAR(50);
</pre>

<p>Old queries still work.</p>

<h2>Rule 10: Integrity Independence</h2>

<p>Integrity constraints must be stored in the database, not application code.</p>

<h3>Example</h3>

<pre>
CREATE TABLE STUDENT (
  RollNo INT PRIMARY KEY,
  Dept   VARCHAR(10) CHECK (Dept IN ('CSE','ECE','ME'))
);
</pre>

<p>Rules live in DB, not in Java if-else nightmares.</p>

<h2>Rule 11: Distribution Independence</h2>

<p>Users shouldn’t know where data is physically located.</p>

<h3>Example</h3>

<pre>
STUDENT table
   |
+-------------------+
| Server A (India)  |
| Server B (USA)    |
+-------------------+
</pre>

<p>Query remains:</p>

<pre>
SELECT * FROM STUDENT;
</pre>

<p>No geography trauma.</p>

<h2>Rule 12: Non-Subversion Rule</h2>

<p>Low-level access must not bypass relational constraints.</p>

<h3>Meaning</h3>
<p>You cannot use internal APIs or file access to violate:</p>
<ul>
    <li>Constraints</li>
    <li>Security</li>
    <li>Integrity rules</li>
</ul>

<h3>Example</h3>
<p>If PRIMARY KEY exists, no internal tool should insert duplicates.</p>

<h2>Summary Table</h2>

<table>
    <tr>
        <th>Rule</th>
        <th>Purpose</th>
    </tr>
    <tr><td>0</td><td>Relational foundation</td></tr>
    <tr><td>1</td><td>All data in tables</td></tr>
    <tr><td>2</td><td>Guaranteed access</td></tr>
    <tr><td>3</td><td>Proper NULL handling</td></tr>
    <tr><td>4</td><td>Metadata as tables</td></tr>
    <tr><td>5</td><td>Full SQL support</td></tr>
    <tr><td>6</td><td>View updatability</td></tr>
    <tr><td>7</td><td>Set-level operations</td></tr>
    <tr><td>8</td><td>Physical independence</td></tr>
    <tr><td>9</td><td>Logical independence</td></tr>
    <tr><td>10</td><td>Integrity in DB</td></tr>
    <tr><td>11</td><td>Distribution independence</td></tr>
    <tr><td>12</td><td>No rule bypassing</td></tr>
</table>
<h1>5. Relational Algebra – Basic Operations</h1>

<p><strong>Relational Algebra</strong> is a procedural query language.<br>
You tell the DBMS how to get the result, not just what you want. Yes, control freak energy.</p>

<h2>Common Relation Used in Examples</h2>

<table>
    <tr>
        <th>SID</th>
        <th>Name</th>
        <th>Dept</th>
        <th>CGPA</th>
    </tr>
    <tr>
        <td>101</td>
        <td>Anil</td>
        <td>CSE</td>
        <td>8.5</td>
    </tr>
    <tr>
        <td>102</td>
        <td>Beena</td>
        <td>ECE</td>
        <td>7.2</td>
    </tr>
    <tr>
        <td>103</td>
        <td>Chitra</td>
        <td>CSE</td>
        <td>9.1</td>
    </tr>
    <tr>
        <td>104</td>
        <td>Deepak</td>
        <td>ME</td>
        <td>6.8</td>
    </tr>
</table>

<h2>1. Selection ( σ )</h2>

<h3>Purpose</h3>
<p>Selects rows (tuples) based on a condition.</p>

<h3>Syntax</h3>
<pre>σ condition (Relation)</pre>

<h3>Example</h3>
<p>Find students from CSE department.</p>
<pre>σ Dept = 'CSE' (STUDENT)</pre>

<h3>Textual Diagram</h3>
<pre>
STUDENT
   |
   |  σ Dept = 'CSE'
   v
RESULT
</pre>

<h3>Result</h3>
<table>
    <tr>
        <th>SID</th>
        <th>Name</th>
        <th>Dept</th>
        <th>CGPA</th>
    </tr>
    <tr>
        <td>101</td>
        <td>Anil</td>
        <td>CSE</td>
        <td>8.5</td>
    </tr>
    <tr>
        <td>103</td>
        <td>Chitra</td>
        <td>CSE</td>
        <td>9.1</td>
    </tr>
</table>

<h3>Notes</h3>
<ul>
    <li>Works on rows</li>
    <li>Condition uses comparison operators: =, &gt;, &lt;, ≥, ≤, ≠</li>
</ul>

<h2>2. Projection ( π )</h2>

<h3>Purpose</h3>
<p>Selects columns (attributes).</p>

<h3>Syntax</h3>
<pre>π attribute_list (Relation)</pre>

<h3>Example</h3>
<p>Get only Name and CGPA.</p>
<pre>π Name, CGPA (STUDENT)</pre>

<h3>Textual Diagram</h3>
<pre>
STUDENT
   |
   |  π Name, CGPA
   v
RESULT
</pre>

<h3>Result</h3>
<table>
    <tr>
        <th>Name</th>
        <th>CGPA</th>
    </tr>
    <tr>
        <td>Anil</td>
        <td>8.5</td>
    </tr>
    <tr>
        <td>Beena</td>
        <td>7.2</td>
    </tr>
    <tr>
        <td>Chitra</td>
        <td>9.1</td>
    </tr>
    <tr>
        <td>Deepak</td>
        <td>6.8</td>
    </tr>
</table>

<h3>Notes</h3>
<ul>
    <li>Removes duplicate rows</li>
    <li>Works on columns</li>
</ul>

<h2>3. Union ( ∪ )</h2>

<h3>Purpose</h3>
<p>Combines tuples from two relations.</p>

<h3>Conditions</h3>
<ul>
    <li>Same number of attributes</li>
    <li>Same domains</li>
    <li>Same attribute order</li>
</ul>

<h3>Relations</h3>

<h4>CSE_STUDENTS</h4>
<table>
    <tr>
        <th>SID</th>
        <th>Name</th>
    </tr>
    <tr>
        <td>101</td>
        <td>Anil</td>
    </tr>
    <tr>
        <td>103</td>
        <td>Chitra</td>
    </tr>
</table>

<h4>ECE_STUDENTS</h4>
<table>
    <tr>
        <th>SID</th>
        <th>Name</th>
    </tr>
    <tr>
        <td>102</td>
        <td>Beena</td>
    </tr>
    <tr>
        <td>105</td>
        <td>Farah</td>
    </tr>
</table>

<h3>Operation</h3>
<pre>CSE_STUDENTS ∪ ECE_STUDENTS</pre>

<h3>Textual Diagram</h3>
<pre>
CSE_STUDENTS      ECE_STUDENTS
      \               /
       \             /
           UNION
              |
              v
           RESULT
</pre>

<h3>Result</h3>
<table>
    <tr>
        <th>SID</th>
        <th>Name</th>
    </tr>
    <tr>
        <td>101</td>
        <td>Anil</td>
    </tr>
    <tr>
        <td>103</td>
        <td>Chitra</td>
    </tr>
    <tr>
        <td>102</td>
        <td>Beena</td>
    </tr>
    <tr>
        <td>105</td>
        <td>Farah</td>
    </tr>
</table>

<h2>4. Set Difference ( − )</h2>

<h3>Purpose</h3>
<p>Returns tuples present in first relation but not in second.</p>

<h3>Example</h3>
<p>Students in CSE but not in ECE.</p>
<pre>CSE_STUDENTS − ECE_STUDENTS</pre>

<h3>Textual Diagram</h3>
<pre>
CSE_STUDENTS -----
                   \
                    DIFFERENCE
                   /
ECE_STUDENTS -----
</pre>

<h3>Result</h3>
<table>
    <tr>
        <th>SID</th>
        <th>Name</th>
    </tr>
    <tr>
        <td>101</td>
        <td>Anil</td>
    </tr>
    <tr>
        <td>103</td>
        <td>Chitra</td>
    </tr>
</table>

<h2>5. Cartesian Product ( × )</h2>

<h3>Purpose</h3>
<p>Combines every tuple of one relation with every tuple of another.</p>

<h3>Relations</h3>

<h4>STUDENT(SID, Name)</h4>
<table>
    <tr>
        <th>SID</th>
        <th>Name</th>
    </tr>
    <tr>
        <td>101</td>
        <td>Anil</td>
    </tr>
    <tr>
        <td>102</td>
        <td>Beena</td>
    </tr>
</table>

<h4>COURSE(CID, CourseName)</h4>
<table>
    <tr>
        <th>CID</th>
        <th>CourseName</th>
    </tr>
    <tr>
        <td>C1</td>
        <td>DBMS</td>
    </tr>
    <tr>
        <td>C2</td>
        <td>OS</td>
    </tr>
</table>

<h3>Operation</h3>
<pre>STUDENT × COURSE</pre>

<h3>Textual Diagram</h3>
<pre>
STUDENT     COURSE
    |         |
     \       /
   CARTESIAN PRODUCT
           |
           v
        RESULT
</pre>

<h3>Result</h3>
<table>
    <tr>
        <th>SID</th>
        <th>Name</th>
        <th>CID</th>
        <th>Course</th>
    </tr>
    <tr>
        <td>101</td>
        <td>Anil</td>
        <td>C1</td>
        <td>DBMS</td>
    </tr>
    <tr>
        <td>101</td>
        <td>Anil</td>
        <td>C2</td>
        <td>OS</td>
    </tr>
    <tr>
        <td>102</td>
        <td>Beena</td>
        <td>C1</td>
        <td>DBMS</td>
    </tr>
    <tr>
        <td>102</td>
        <td>Beena</td>
        <td>C2</td>
        <td>OS</td>
    </tr>
</table>

<h3>Notes</h3>
<ul>
    <li>Produces m × n rows</li>
    <li>Rarely used alone</li>
    <li>Usually followed by selection</li>
</ul>

<h2>Summary Table</h2>
<table>
    <tr>
        <th>Operation</th>
        <th>Symbol</th>
        <th>Works On</th>
        <th>Purpose</th>
    </tr>
    <tr>
        <td>Selection</td>
        <td>σ</td>
        <td>Rows</td>
        <td>Filters tuples</td>
    </tr>
    <tr>
        <td>Projection</td>
        <td>π</td>
        <td>Columns</td>
        <td>Filters attributes</td>
    </tr>
    <tr>
        <td>Union</td>
        <td>∪</td>
        <td>Relations</td>
        <td>Combine tuples</td>
    </tr>
    <tr>
        <td>Difference</td>
        <td>−</td>
        <td>Relations</td>
        <td>Subtract tuples</td>
    </tr>
    <tr>
        <td>Cartesian</td>
        <td>×</td>
        <td>Relations</td>
        <td>Combine all tuples</td>
    </tr>
</table>
<h1>Relational Algebra – Derived Operations (In Depth)</h1>

<p>
Derived operations are not primitive. They are built using basic operations like selection,
projection, Cartesian product, etc.<br>
They exist because writing everything as ×, σ, π makes humans sad.
</p>

<p>We’ll use one consistent schema so your brain doesn’t revolt.</p>

<h2>Example Relations</h2>

<h3>STUDENT</h3>
<table>
    <tr>
        <th>SID</th>
        <th>Name</th>
        <th>Dept</th>
    </tr>
    <tr><td>1</td><td>Ravi</td><td>CSE</td></tr>
    <tr><td>2</td><td>Anita</td><td>ECE</td></tr>
    <tr><td>3</td><td>Mohan</td><td>CSE</td></tr>
</table>

<h3>COURSE</h3>
<table>
    <tr>
        <th>CID</th>
        <th>Title</th>
        <th>Dept</th>
    </tr>
    <tr><td>C1</td><td>DBMS</td><td>CSE</td></tr>
    <tr><td>C2</td><td>CN</td><td>ECE</td></tr>
    <tr><td>C3</td><td>AI</td><td>CSE</td></tr>
</table>

<h3>ENROLL</h3>
<table>
    <tr>
        <th>SID</th>
        <th>CID</th>
    </tr>
    <tr><td>1</td><td>C1</td></tr>
    <tr><td>1</td><td>C3</td></tr>
    <tr><td>2</td><td>C2</td></tr>
    <tr><td>3</td><td>C1</td></tr>
</table>

<h2>1. Join (⨝)</h2>

<p>
A join combines related tuples from two relations based on a condition.<br>
Formally: Selection over Cartesian Product.
</p>

<h3>General Form</h3>
<pre>R ⨝condition S = σ(condition)(R × S)</pre>

<h3>1.1 Theta Join (⨝θ)</h3>

<p>
Join using any comparison operator: =, &lt;, &gt;, ≤, ≥, ≠
</p>

<h4>Example</h4>
<p>Students enrolled in courses (matching SID):</p>

<pre>STUDENT ⨝ STUDENT.SID = ENROLL.SID ENROLL</pre>

<h4>Textual Diagram</h4>
<pre>
STUDENT × ENROLL
        |
        v
σ(STUDENT.SID = ENROLL.SID)
        |
        v
Result Relation
</pre>

<h4>Result</h4>
<table>
    <tr>
        <th>SID</th>
        <th>Name</th>
        <th>Dept</th>
        <th>SID</th>
        <th>CID</th>
    </tr>
    <tr><td>1</td><td>Ravi</td><td>CSE</td><td>1</td><td>C1</td></tr>
    <tr><td>1</td><td>Ravi</td><td>CSE</td><td>1</td><td>C3</td></tr>
    <tr><td>2</td><td>Anita</td><td>ECE</td><td>2</td><td>C2</td></tr>
    <tr><td>3</td><td>Mohan</td><td>CSE</td><td>3</td><td>C1</td></tr>
</table>

<h3>1.2 Equi Join</h3>

<p>
Theta join using only equality (=).<br>
Same as above, just more polite.
</p>

<pre>STUDENT ⨝ STUDENT.SID = ENROLL.SID ENROLL</pre>

<p>Duplicate attributes remain. That’s the price you pay.</p>

<h3>1.3 Natural Join (⨝)</h3>

<p>
Automatically joins on same attribute names and removes duplicate columns.
</p>

<h4>Example</h4>
<p>Join ENROLL and COURSE on CID:</p>

<pre>ENROLL ⨝ COURSE</pre>

<h4>Textual Diagram</h4>
<pre>
ENROLL        COURSE
  SID CID  ⨝   CID Title Dept
        |
        v
Common attribute: CID
</pre>

<h4>Result</h4>
<table>
    <tr>
        <th>SID</th>
        <th>CID</th>
        <th>Title</th>
        <th>Dept</th>
    </tr>
    <tr><td>1</td><td>C1</td><td>DBMS</td><td>CSE</td></tr>
    <tr><td>1</td><td>C3</td><td>AI</td><td>CSE</td></tr>
    <tr><td>2</td><td>C2</td><td>CN</td><td>ECE</td></tr>
    <tr><td>3</td><td>C1</td><td>DBMS</td><td>CSE</td></tr>
</table>

<p>No duplicate CID column. Natural join cleans up after itself.</p>

<h2>2. Intersection (∩)</h2>

<p>Returns tuples common to both relations.</p>

<h3>Conditions</h3>
<ul>
    <li>Same number of attributes</li>
    <li>Same domains</li>
</ul>

<h3>Example</h3>
<pre>
R(A) = {1,2,3,4}
S(A) = {3,4,5}
</pre>

<pre>R ∩ S</pre>

<h4>Result</h4>
<table>
    <tr><th>A</th></tr>
    <tr><td>3</td></tr>
    <tr><td>4</td></tr>
</table>

<h4>Textual Diagram</h4>
<pre>
   R        S
 1 2 3 4  3 4 5
      │
      └── common tuples
</pre>

<h2>3. Division (÷)</h2>

<p>The operation everyone pretends to understand.</p>

<p>Used for “for all” queries.</p>

<h3>Classic Meaning</h3>
<p>Find entities related to all entities in another relation.</p>

<h3>Example</h3>
<p>Find students who are enrolled in all CSE courses.</p>

<h4>Step 1: Identify relations</h4>
<pre>
ENROLL(SID, CID)
CSE_COURSE(CID)
</pre>

<p>Let:</p>
<pre>CSE_COURSE = σ(Dept = 'CSE')(COURSE)</pre>

<h4>Step 2: Division</h4>
<pre>ENROLL ÷ CSE_COURSE</pre>

<h4>Textual Diagram</h4>
<pre>
ENROLL(SID, CID)
 ┌───────────────┐
 │ 1 C1          │
 │ 1 C3          │
 │ 3 C1          │
 └───────────────┘
        ÷
CSE_COURSE(CID)
 ┌─────────┐
 │ C1      │
 │ C3      │
 └─────────┘
        ↓
Result(SID)
</pre>

<h4>Result</h4>
<table>
    <tr><th>SID</th></tr>
    <tr><td>1</td></tr>
</table>

<p>Student 1 is enrolled in every CSE course. Others are slackers.</p>

<h2>4. Join Variants Summary</h2>

<table>
    <tr>
        <th>Join Type</th>
        <th>Condition</th>
        <th>Duplicate Columns</th>
    </tr>
    <tr>
        <td>Theta Join</td>
        <td>Any condition</td>
        <td>Yes</td>
    </tr>
    <tr>
        <td>Equi Join</td>
        <td>Equality only</td>
        <td>Yes</td>
    </tr>
    <tr>
        <td>Natural Join</td>
        <td>Same attribute names</td>
        <td>No</td>
    </tr>
</table>
<h1>SQL</h1>
<h2>DDL (Data Definition Language)</h2>

<h3>Purpose:</h3>
<p>
DDL commands define, modify, or delete the structure of database objects like tables,
schemas, indexes.
</p>

<h3>Key property:</h3>
<ul>
    <li>Auto-commit in most DBMS</li>
    <li>Changes are permanent</li>
    <li>A mistake here lives forever</li>
</ul>

<h2>1. CREATE</h2>

<h3>What it does</h3>
<p>Creates database objects such as:</p>
<ul>
    <li>Database</li>
    <li>Table</li>
    <li>View</li>
    <li>Index</li>
</ul>

<h3>CREATE TABLE – In Depth</h3>

<h4>Syntax</h4>
<pre>
CREATE TABLE Student (
    roll_no INT PRIMARY KEY,
    name VARCHAR(50) NOT NULL,
    dept VARCHAR(10),
    cgpa DECIMAL(3,2),
    email VARCHAR(100) UNIQUE
);
</pre>

<h4>Textual Diagram (After CREATE)</h4>
<table>
    <tr>
        <th>roll_no (PK)</th>
        <th>name</th>
        <th>dept</th>
        <th>cgpa</th>
        <th>email</th>
    </tr>
    <tr>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
    </tr>
</table>

<p>
Structure exists. Rows do not. An empty box waiting for bad life choices.
</p>

<h3>CREATE DATABASE</h3>
<pre>
CREATE DATABASE University;
</pre>

<h3>CREATE INDEX</h3>
<pre>
CREATE INDEX idx_dept ON Student(dept);
</pre>

<p>
Improves search speed, increases storage cost. Nothing in life is free.
</p>

<h2>2. DROP</h2>

<h3>What it does</h3>
<ul>
    <li>Permanently deletes a database object</li>
    <li>Removes structure + data</li>
    <li>Cannot be rolled back</li>
</ul>

<h3>DROP TABLE – In Depth</h3>

<h4>Syntax</h4>
<pre>
DROP TABLE Student;
</pre>

<h4>Textual Diagram (After DROP)</h4>
<table>
    <tr>
        <th>Student Table</th>
    </tr>
    <tr>
        <td>DOES NOT EXIST</td>
    </tr>
</table>

<p>
No structure. No data. No regrets from the DBMS.
</p>

<h3>DROP DATABASE</h3>
<pre>
DROP DATABASE University;
</pre>

<p>
Entire database erased. One command. Maximum chaos.
</p>

<h2>3. ALTER</h2>

<h3>What it does</h3>
<p>Modifies the structure of an existing table:</p>
<ul>
    <li>Add column</li>
    <li>Modify column</li>
    <li>Rename column</li>
    <li>Drop column</li>
    <li>Add or remove constraints</li>
</ul>

<h3>ALTER – ADD COLUMN</h3>
<pre>
ALTER TABLE Student
ADD phone VARCHAR(15);
</pre>

<table>
    <tr>
        <th>roll_no</th>
        <th>name</th>
        <th>dept</th>
        <th>cgpa</th>
        <th>email</th>
        <th>phone</th>
    </tr>
</table>

<p>
Old data stays. New column gets NULL by default because the DBMS is lazy.
</p>

<h3>ALTER – MODIFY COLUMN</h3>
<pre>
ALTER TABLE Student
MODIFY cgpa DECIMAL(4,2);
</pre>

<p>
Changes data type or size. Existing data must behave or it breaks.
</p>

<h3>ALTER – DROP COLUMN</h3>
<pre>
ALTER TABLE Student
DROP phone;
</pre>

<table>
    <tr>
        <th>roll_no</th>
        <th>name</th>
        <th>dept</th>
        <th>cgpa</th>
        <th>email</th>
    </tr>
</table>

<p>
Column gone. Data gone. Still no rollback.
</p>

<h3>ALTER – ADD CONSTRAINT</h3>
<pre>
ALTER TABLE Student
ADD CONSTRAINT chk_cgpa CHECK (cgpa <= 10);
</pre>

<p>
Rules are enforced. Students with 11 CGPA are no longer welcome.
</p>

<h2>4. TRUNCATE</h2>

<h3>What it does</h3>
<ul>
    <li>Deletes all rows from a table</li>
    <li>Keeps table structure</li>
    <li>Faster than DELETE</li>
    <li>Cannot use WHERE clause</li>
    <li>Cannot be rolled back (usually)</li>
</ul>

<h3>Syntax</h3>
<pre>
TRUNCATE TABLE Student;
</pre>

<h3>Textual Diagram (Before TRUNCATE)</h3>
<table>
    <tr>
        <th>roll_no</th>
        <th>name</th>
        <th>dept</th>
        <th>cgpa</th>
        <th>email</th>
    </tr>
    <tr>
        <td>101</td>
        <td>Rahul</td>
        <td>CSE</td>
        <td>8.2</td>
        <td>r@x.com</td>
    </tr>
    <tr>
        <td>102</td>
        <td>Anita</td>
        <td>ECE</td>
        <td>9.1</td>
        <td>a@x.com</td>
    </tr>
</table>

<h3>Textual Diagram (After TRUNCATE)</h3>
<table>
    <tr>
        <th>roll_no</th>
        <th>name</th>
        <th>dept</th>
        <th>cgpa</th>
        <th>email</th>
    </tr>
    <tr>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
        <td>-</td>
    </tr>
</table>

<p>
Structure intact. Data erased. Cleaner than DROP, deadlier than DELETE.
</p>

<h2>DDL Command Comparison (Exam Favorite)</h2>

<table>
    <tr>
        <th>Command</th>
        <th>Deletes Structure</th>
        <th>Deletes Data</th>
        <th>Rollback</th>
        <th>WHERE</th>
    </tr>
    <tr>
        <td>CREATE</td>
        <td>No</td>
        <td>No</td>
        <td>No</td>
        <td>No</td>
    </tr>
    <tr>
        <td>DROP</td>
        <td>Yes</td>
        <td>Yes</td>
        <td>No</td>
        <td>No</td>
    </tr>
    <tr>
        <td>ALTER</td>
        <td>Partial</td>
        <td>No</td>
        <td>No</td>
        <td>No</td>
    </tr>
    <tr>
        <td>TRUNCATE</td>
        <td>No</td>
        <td>Yes (All)</td>
        <td>No</td>
        <td>No</td>
    </tr>
</table>
<h1>DML (Data Manipulation Language)</h1>

<p>DML commands are used to work with the data inside tables, not the table structure itself.</p>

<h3>Core DML commands:</h3>
<ul>
    <li><strong>SELECT</strong> – read data</li>
    <li><strong>INSERT</strong> – add new data</li>
    <li><strong>UPDATE</strong> – modify existing data</li>
    <li><strong>DELETE</strong> – remove data</li>
</ul>

<p>We’ll use one table throughout so your brain doesn’t have to context-switch every 10 seconds.</p>

<h2>Example Table: STUDENT</h2>

<h3>Table Structure</h3>

<table>
    <tr>
        <th>sid (PK)</th>
        <th>name</th>
        <th>branch</th>
        <th>marks</th>
    </tr>
    <tr>
        <td>1</td>
        <td>Rahul</td>
        <td>CSE</td>
        <td>85</td>
    </tr>
    <tr>
        <td>2</td>
        <td>Anjali</td>
        <td>ECE</td>
        <td>78</td>
    </tr>
    <tr>
        <td>3</td>
        <td>Abhishek</td>
        <td>CSE</td>
        <td>92</td>
    </tr>
    <tr>
        <td>4</td>
        <td>Neha</td>
        <td>ME</td>
        <td>65</td>
    </tr>
</table>

<h3>Textual ER-ish view:</h3>
<pre>
[ STUDENT ]
   |
   |-- sid (Primary Key)
   |-- name
   |-- branch
   |-- marks
</pre>

<h2>1. SELECT – Retrieve Data</h2>

<h3>Purpose</h3>
<p>Fetch data from one or more tables. Read-only. Harmless. Until someone forgets a WHERE.</p>

<h3>Basic Syntax</h3>
<pre>
SELECT column_list
FROM table_name
WHERE condition;
</pre>

<h3>Example 1: Select All Records</h3>
<pre>
SELECT * FROM STUDENT;
</pre>

<h3>Output:</h3>
<table>
    <tr>
        <th>sid</th>
        <th>name</th>
        <th>branch</th>
        <th>marks</th>
    </tr>
    <tr>
        <td>1</td>
        <td>Rahul</td>
        <td>CSE</td>
        <td>85</td>
    </tr>
    <tr>
        <td>2</td>
        <td>Anjali</td>
        <td>ECE</td>
        <td>78</td>
    </tr>
    <tr>
        <td>3</td>
        <td>Abhishek</td>
        <td>CSE</td>
        <td>92</td>
    </tr>
    <tr>
        <td>4</td>
        <td>Neha</td>
        <td>ME</td>
        <td>65</td>
    </tr>
</table>

<h3>Textual flow:</h3>
<pre>
STUDENT TABLE
     ↓
SELECT *
     ↓
ALL ROWS RETURNED
</pre>

<h3>Example 2: Select Specific Columns</h3>
<pre>
SELECT name, marks
FROM STUDENT;
</pre>

<h3>Example 3: WHERE Clause</h3>
<pre>
SELECT name, marks
FROM STUDENT
WHERE branch = 'CSE';
</pre>

<h3>Result:</h3>
<pre>
Rahul     85
Abhishek  92
</pre>

<h3>Textual diagram:</h3>
<pre>
STUDENT
  |
  |-- filter: branch = 'CSE'
  |
RESULT SET
</pre>

<h3>Example 4: Aggregate Functions</h3>
<pre>
SELECT AVG(marks) AS avg_marks
FROM STUDENT;
</pre>

<h3>Example 5: ORDER BY</h3>
<pre>
SELECT name, marks
FROM STUDENT
ORDER BY marks DESC;
</pre>

<h2>2. INSERT – Add New Data</h2>

<h3>Purpose</h3>
<p>Insert new rows into a table. One wrong value and constraints start screaming.</p>

<h3>Syntax</h3>
<pre>
INSERT INTO table_name (column1, column2, ...)
VALUES (value1, value2, ...);
</pre>

<h3>Example 1: Insert Full Row</h3>
<pre>
INSERT INTO STUDENT (sid, name, branch, marks)
VALUES (5, 'Karan', 'CSE', 88);
</pre>

<h3>Updated table row:</h3>
<pre>
| 5 | Karan | CSE | 88 |
</pre>

<h3>Example 2: Insert Without Column List (Not Recommended)</h3>
<pre>
INSERT INTO STUDENT
VALUES (6, 'Pooja', 'ECE', 74);
</pre>

<h3>Textual diagram:</h3>
<pre>
INSERT COMMAND
     ↓
New tuple created
     ↓
Stored in STUDENT
</pre>

<h3>Example 3: Insert Multiple Rows</h3>
<pre>
INSERT INTO STUDENT (sid, name, branch, marks)
VALUES
(7, 'Amit', 'ME', 69),
(8, 'Riya', 'CSE', 91);
</pre>

<h2>3. UPDATE – Modify Existing Data</h2>

<h3>Purpose</h3>
<p>Change existing records. Dangerous if you forget WHERE. Entire table will “update itself”.</p>

<h3>Syntax</h3>
<pre>
UPDATE table_name
SET column = value
WHERE condition;
</pre>

<h3>Example 1: Update One Record</h3>
<pre>
UPDATE STUDENT
SET marks = 80
WHERE sid = 2;
</pre>

<h3>Example 2: Update Multiple Rows</h3>
<pre>
UPDATE STUDENT
SET marks = marks + 5
WHERE branch = 'ME';
</pre>

<h3>Before:</h3>
<pre>Neha → 65</pre>

<h3>After:</h3>
<pre>Neha → 70</pre>

<h3>Textual diagram:</h3>
<pre>
STUDENT
  |
  |-- WHERE branch = 'ME'
  |
  |-- UPDATE marks
</pre>

<h3>Example 3: Update Multiple Columns</h3>
<pre>
UPDATE STUDENT
SET branch = 'AI', marks = 95
WHERE name = 'Abhishek';
</pre>

<p>Yes, your name is now officially immortalized in SQL examples.</p>

<h2>4. DELETE – Remove Data</h2>

<h3>Purpose</h3>
<p>Delete rows from a table. No undo unless you’re inside a transaction.</p>

<h3>Syntax</h3>
<pre>
DELETE FROM table_name
WHERE condition;
</pre>

<h3>Example 1: Delete Specific Row</h3>
<pre>
DELETE FROM STUDENT
WHERE sid = 4;
</pre>

<p>Neha has left the database. Tragic.</p>

<h3>Example 2: Delete Multiple Rows</h3>
<pre>
DELETE FROM STUDENT
WHERE marks < 70;
</pre>

<h3>Example 3: Delete All Rows</h3>
<pre>
DELETE FROM STUDENT;
</pre>

<p>Table exists. Data does not.<br>
Different from TRUNCATE which is DDL and faster.</p>

<h3>Textual diagram:</h3>
<pre>
DELETE
  |
  |-- condition applied
  |
Rows removed permanently
</pre>

<h2>DML vs DDL (Quick Reality Check)</h2>

<table>
    <tr>
        <th>Feature</th>
        <th>DML</th>
        <th>DDL</th>
    </tr>
    <tr>
        <td>Affects</td>
        <td>Data</td>
        <td>Structure</td>
    </tr>
    <tr>
        <td>Rollback</td>
        <td>Yes (if transaction)</td>
        <td>No</td>
    </tr>
    <tr>
        <td>Example</td>
        <td>INSERT</td>
        <td>CREATE</td>
    </tr>
</table>
<h1>DCL (Data Control Language)</h1>

<h2>Purpose</h2>
<p>Controls access permissions on database objects like tables, views, procedures, etc.</p>

<h3>Two main commands</h3>
<ul>
    <li><strong>GRANT</strong> → give privileges</li>
    <li><strong>REVOKE</strong> → take privileges back</li>
</ul>

<h2>Why DCL Exists (aka why trust is limited)</h2>
<p>Imagine:</p>
<ul>
    <li>One user deletes all records</li>
    <li>Another leaks data</li>
    <li>A third runs <strong>DROP TABLE</strong> accidentally because caffeine</li>
</ul>
<p>DCL exists to prevent chaos.</p>

<h2>Privileges in DBMS</h2>

<h3>Common Privileges</h3>
<table>
    <tr>
        <th>Privilege</th>
        <th>Meaning</th>
    </tr>
    <tr>
        <td>SELECT</td>
        <td>Read data</td>
    </tr>
    <tr>
        <td>INSERT</td>
        <td>Add new rows</td>
    </tr>
    <tr>
        <td>UPDATE</td>
        <td>Modify data</td>
    </tr>
    <tr>
        <td>DELETE</td>
        <td>Remove data</td>
    </tr>
    <tr>
        <td>ALL</td>
        <td>All privileges</td>
    </tr>
    <tr>
        <td>REFERENCES</td>
        <td>Use as foreign key</td>
    </tr>
</table>

<h2>GRANT Command</h2>

<h3>Syntax</h3>
<pre>
GRANT privilege_list
ON object_name
TO user_or_role
[WITH GRANT OPTION];
</pre>

<h3>Example Scenario</h3>

<p><strong>Table: Student</strong></p>
<table>
    <tr>
        <th>roll</th>
        <th>name</th>
        <th>branch</th>
        <th>cgpa</th>
    </tr>
    <tr>
        <td>101</td>
        <td>Rahul</td>
        <td>CSE</td>
        <td>8.2</td>
    </tr>
    <tr>
        <td>102</td>
        <td>Neha</td>
        <td>ECE</td>
        <td>8.5</td>
    </tr>
</table>

<p><strong>Users:</strong></p>
<ul>
    <li>admin</li>
    <li>faculty</li>
    <li>student_user</li>
</ul>

<h3>Example 1: Grant SELECT Permission</h3>
<pre>
GRANT SELECT
ON Student
TO faculty;
</pre>

<ul>
    <li>✔ faculty can read data</li>
    <li>✖ cannot modify it</li>
    <li>✖ cannot delete it</li>
</ul>

<h3>Textual Diagram</h3>
<pre>
        admin
          |
     GRANT SELECT
          |
       faculty
          |
       SELECT
       Student
</pre>

<h3>Example 2: Grant Multiple Privileges</h3>
<pre>
GRANT SELECT, INSERT, UPDATE
ON Student
TO faculty;
</pre>

<p>faculty can:</p>
<ul>
    <li>View records</li>
    <li>Add new students</li>
    <li>Update CGPA</li>
</ul>

<p>Still cannot delete. Power is rationed.</p>

<h3>Example 3: WITH GRANT OPTION</h3>
<pre>
GRANT SELECT
ON Student
TO faculty
WITH GRANT OPTION;
</pre>

<p>Now faculty can pass SELECT permission to others.</p>

<pre>
-- executed by faculty
GRANT SELECT
ON Student
TO student_user;
</pre>

<h3>Diagram (Privilege Propagation)</h3>
<pre>
admin
  |
  | SELECT (with grant option)
  v
faculty
  |
  | SELECT
  v
student_user
</pre>

<p>This is how privilege chains are born.</p>

<h2>REVOKE Command</h2>

<p>When someone abuses power or just graduates.</p>

<h3>Syntax</h3>
<pre>
REVOKE privilege_list
ON object_name
FROM user_or_role;
</pre>

<h3>Example 1: Revoke SELECT Permission</h3>
<pre>
REVOKE SELECT
ON Student
FROM faculty;
</pre>

<p>faculty can no longer read the table.</p>

<h3>Cascading Effect (Important for exams)</h3>
<p>If faculty had WITH GRANT OPTION, revoking from faculty also revokes from users they granted to.</p>

<pre>
admin → faculty → student_user
</pre>

<p>Revoke from faculty = student_user also loses access.</p>

<h3>Diagram (Cascade Revoke)</h3>
<pre>
admin
  |
  X  SELECT revoked
  |
faculty
  |
  X  SELECT revoked
  |
student_user
</pre>

<p>Everyone cries. Database remains safe.</p>

<h2>GRANT vs REVOKE (Quick Comparison)</h2>
<table>
    <tr>
        <th>Feature</th>
        <th>GRANT</th>
        <th>REVOKE</th>
    </tr>
    <tr>
        <td>Purpose</td>
        <td>Give permission</td>
        <td>Remove permission</td>
    </tr>
    <tr>
        <td>Direction</td>
        <td>Admin → User</td>
        <td>Admin → User</td>
    </tr>
    <tr>
        <td>Grant option</td>
        <td>Yes</td>
        <td>Removes it</td>
    </tr>
    <tr>
        <td>Security</td>
        <td>Enables access</td>
        <td>Restricts access</td>
    </tr>
</table>

<h2>Important Exam Points (Do Not Skip)</h2>
<ul>
    <li>DCL controls authorization, not data</li>
    <li>GRANT can propagate permissions</li>
    <li>REVOKE can cause cascading revocation</li>
    <li>Only object owner or DBA can grant/revoke</li>
    <li>Works on tables, views, procedures, schemas</li>
</ul>

<h2>Real-World Use Case</h2>
<ul>
    <li>Admin → full access</li>
    <li>Faculty → read/write student records</li>
    <li>Students → read-only access</li>
    <li>External users → zero trust</li>
</ul>
<h1>Transaction Control Language (TCL)</h1>

<p>TCL commands control transactions, not data structure.<br>
They decide when changes become permanent and how far back you can undo your mistakes.</p>

<h3>Core TCL commands:</h3>
<ul>
    <li>COMMIT</li>
    <li>ROLLBACK</li>
    <li>SAVEPOINT</li>
</ul>

<h2>What Is a Transaction?</h2>

<p>A transaction is a logical unit of work.</p>

<p><strong>Example:</strong></p>
<p>Transfer money:</p>
<ol>
    <li>Debit account A</li>
    <li>Credit account B</li>
</ol>

<p>Both must succeed or both must fail. No half-baked reality.</p>

<h2>ACID Reminder (Because Exams Love This)</h2>
<ul>
    <li><strong>Atomicity:</strong> All or nothing</li>
    <li><strong>Consistency:</strong> Database rules stay intact</li>
    <li><strong>Isolation:</strong> Transactions don’t interfere</li>
    <li><strong>Durability:</strong> Once committed, it survives crashes and bad life choices</li>
</ul>

<p>TCL exists mainly for Atomicity and Durability.</p>

<h2>1. COMMIT</h2>

<h3>Meaning</h3>
<p>COMMIT makes all changes permanent.<br>
After this, rollback can’t save you. The database remembers forever.</p>

<h3>Example Table</h3>
<pre>
CREATE TABLE Accounts (
    acc_id INT PRIMARY KEY,
    name VARCHAR(20),
    balance INT
);

INSERT INTO Accounts VALUES
(1, 'Alice', 5000),
(2, 'Bob', 3000);
</pre>

<h3>Transaction Example</h3>
<pre>
UPDATE Accounts
SET balance = balance - 1000
WHERE acc_id = 1;

UPDATE Accounts
SET balance = balance + 1000
WHERE acc_id = 2;

COMMIT;
</pre>

<h3>What Happens?</h3>
<ul>
    <li>Alice → 4000</li>
    <li>Bob → 4000</li>
    <li>Changes are permanent</li>
</ul>

<h3>Textual Diagram</h3>
<pre>
START TRANSACTION
      |
      |-- Debit Alice (-1000)
      |
      |-- Credit Bob (+1000)
      |
   COMMIT
      |
  Changes saved forever
</pre>

<h3>Key Points</h3>
<ul>
    <li>Ends the transaction</li>
    <li>Releases locks</li>
    <li>Makes changes durable</li>
    <li>Cannot be undone</li>
</ul>

<h2>2. ROLLBACK</h2>

<h3>Meaning</h3>
<p>ROLLBACK cancels all changes made in the current transaction.</p>

<p>Basically:</p>
<p><em>“Nope. Pretend none of this happened.”</em></p>

<h3>Example</h3>
<pre>
UPDATE Accounts
SET balance = balance - 2000
WHERE acc_id = 1;

ROLLBACK;
</pre>

<h3>Result</h3>
<ul>
    <li>Alice’s balance stays unchanged</li>
    <li>Database state returns to last COMMIT</li>
</ul>

<h3>Textual Diagram</h3>
<pre>
START TRANSACTION
      |
      |-- Update balance
      |
   ERROR / DECISION
      |
  ROLLBACK
      |
 Database restored
</pre>

<h3>Important Notes</h3>
<ul>
    <li>Works only before COMMIT</li>
    <li>Rolls back entire transaction</li>
    <li>Automatically triggered on system crash (using logs)</li>
</ul>

<h2>3. SAVEPOINT</h2>

<h3>Meaning</h3>
<p>A SAVEPOINT is a checkpoint inside a transaction.<br>
You can rollback partially, not all the way.</p>

<p>For people who want control but not commitment.</p>

<h3>Example</h3>
<pre>
SAVEPOINT sp1;

UPDATE Accounts
SET balance = balance - 500
WHERE acc_id = 1;

SAVEPOINT sp2;

UPDATE Accounts
SET balance = balance - 1000
WHERE acc_id = 1;

ROLLBACK TO sp2;
COMMIT;
</pre>

<h3>What Happens?</h3>
<ul>
    <li>First deduction (−500) stays</li>
    <li>Second deduction (−1000) is undone</li>
    <li>Final balance change = −500</li>
</ul>

<h3>Textual Diagram</h3>
<pre>
START TRANSACTION
      |
   SAVEPOINT sp1
      |
   Update -500
      |
   SAVEPOINT sp2
      |
   Update -1000
      |
ROLLBACK TO sp2
      |
   COMMIT
</pre>

<h3>Syntax</h3>
<pre>
SAVEPOINT savepoint_name;
ROLLBACK TO savepoint_name;
</pre>

<h3>Rules</h3>
<ul>
    <li>Multiple savepoints allowed</li>
    <li>Savepoints removed after COMMIT</li>
    <li>Useful in complex transactions</li>
</ul>

<h2>Combined Example (Realistic)</h2>
<pre>
START TRANSACTION;

INSERT INTO Accounts VALUES (3, 'Charlie', 2000);

SAVEPOINT s1;

UPDATE Accounts
SET balance = balance - 500
WHERE acc_id = 3;

ROLLBACK TO s1;

COMMIT;
</pre>

<h3>Result</h3>
<ul>
    <li>Charlie is inserted</li>
    <li>Balance change is undone</li>
    <li>Insert remains</li>
</ul>

<h2>COMMIT vs ROLLBACK vs SAVEPOINT (Quick Table)</h2>
<table>
    <tr>
        <th>Command</th>
        <th>Purpose</th>
        <th>Undo Possible?</th>
    </tr>
    <tr>
        <td>COMMIT</td>
        <td>Save changes permanently</td>
        <td>❌ No</td>
    </tr>
    <tr>
        <td>ROLLBACK</td>
        <td>Undo all changes</td>
        <td>✅ Yes</td>
    </tr>
    <tr>
        <td>SAVEPOINT</td>
        <td>Mark partial rollback point</td>
        <td>✅ Partial</td>
    </tr>
</table>
<h1>Constraints in DBMS (In Depth)</h1>

<h2>What is a Constraint?</h2>
<p>
A constraint is a rule enforced on table columns to ensure data accuracy, consistency, and integrity.
</p>

<p>
If data violates a constraint, the DBMS refuses to cooperate. As it should.
</p>

<h2>Types of Constraints</h2>

<h3>1. NOT NULL Constraint</h3>
<p>Ensures a column cannot have NULL values.</p>

<h4>Why it exists</h4>
<p>Some data is not optional. A student without an ID is just vibes.</p>

<h4>Example</h4>
<pre>
CREATE TABLE Student (
    id INT NOT NULL,
    name VARCHAR(50),
    age INT
);
</pre>

<p>❌ Invalid:</p>
<pre>
INSERT INTO Student (name, age) VALUES ('Abhi', 21);
</pre>

<h4>Textual Diagram</h4>
<p>Student Table</p>
<table>
    <tr>
        <th>id</th>
        <th>name</th>
        <th>age</th>
    </tr>
    <tr>
        <td>❌</td>
        <td>Abhi</td>
        <td>21</td>
    </tr>
</table>

<h3>2. UNIQUE Constraint</h3>
<p>Ensures all values in a column are different.</p>

<h4>Why it exists</h4>
<p>Two users with the same email is how security incidents are born.</p>

<h4>Example</h4>
<pre>
CREATE TABLE Users (
    user_id INT,
    email VARCHAR(100) UNIQUE
);
</pre>

<p>❌ Invalid:</p>
<pre>
INSERT INTO Users VALUES (1, 'a@gmail.com');
INSERT INTO Users VALUES (2, 'a@gmail.com');
</pre>

<h4>Diagram</h4>
<table>
    <tr>
        <th>user_id</th>
        <th>email</th>
    </tr>
    <tr>
        <td>1</td>
        <td>a@gmail.com</td>
    </tr>
    <tr>
        <td>2</td>
        <td>a@gmail.com ❌</td>
    </tr>
</table>

<h3>3. PRIMARY KEY Constraint</h3>
<p>Combines NOT NULL + UNIQUE</p>
<p>Uniquely identifies each row</p>

<h4>Rules</h4>
<ul>
    <li>Only one primary key per table</li>
    <li>Can be composite (multiple columns)</li>
</ul>

<h4>Example</h4>
<pre>
CREATE TABLE Employee (
    emp_id INT PRIMARY KEY,
    name VARCHAR(50),
    dept VARCHAR(20)
);
</pre>

<p>❌ Invalid:</p>
<pre>
INSERT INTO Employee VALUES (NULL, 'Ram', 'IT');
INSERT INTO Employee VALUES (101, 'Shyam', 'HR');
INSERT INTO Employee VALUES (101, 'Mohan', 'Sales');
</pre>

<h4>Diagram</h4>
<table>
    <tr>
        <th>emp_id</th>
        <th>name</th>
        <th>dept</th>
    </tr>
    <tr>
        <td>101</td>
        <td>Ram</td>
        <td>IT</td>
    </tr>
    <tr>
        <td>101 ❌</td>
        <td>Mohan</td>
        <td>Sales</td>
    </tr>
</table>

<h3>4. FOREIGN KEY Constraint</h3>
<p>Creates a relationship between two tables.</p>

<h4>Why it exists</h4>
<p>So orphan records don’t roam free.</p>

<h4>Example</h4>
<pre>
CREATE TABLE Department (
    dept_id INT PRIMARY KEY,
    dept_name VARCHAR(50)
);

CREATE TABLE Employee (
    emp_id INT PRIMARY KEY,
    name VARCHAR(50),
    dept_id INT,
    FOREIGN KEY (dept_id) REFERENCES Department(dept_id)
);
</pre>

<p>❌ Invalid:</p>
<pre>
INSERT INTO Employee VALUES (1, 'Abhi', 99);
</pre>

<p>(if dept_id 99 doesn’t exist)</p>

<h4>Textual Diagram</h4>
<table>
    <tr>
        <th colspan="2">Department</th>
        <th colspan="3">Employee</th>
    </tr>
    <tr>
        <th>dept_id</th>
        <th>dept_name</th>
        <th>emp_id</th>
        <th>name</th>
        <th>dept_id</th>
    </tr>
    <tr>
        <td>10</td>
        <td>IT</td>
        <td>1</td>
        <td>Abhi</td>
        <td>10</td>
    </tr>
    <tr>
        <td></td>
        <td></td>
        <td>2</td>
        <td>Raj</td>
        <td>99 ❌</td>
    </tr>
</table>

<h3>5. CHECK Constraint</h3>
<p>Restricts values based on a condition.</p>

<h4>Example</h4>
<pre>
CREATE TABLE Student (
    id INT PRIMARY KEY,
    age INT CHECK (age >= 18),
    marks INT CHECK (marks BETWEEN 0 AND 100)
);
</pre>

<p>❌ Invalid:</p>
<pre>
INSERT INTO Student VALUES (1, 16, 90);
</pre>

<h4>Diagram</h4>
<table>
    <tr>
        <th>id</th>
        <th>age</th>
        <th>marks</th>
    </tr>
    <tr>
        <td>1</td>
        <td>16 ❌</td>
        <td>90</td>
    </tr>
</table>

<h3>6. DEFAULT Constraint</h3>
<p>Assigns a default value when none is provided.</p>

<h4>Example</h4>
<pre>
CREATE TABLE Orders (
    order_id INT PRIMARY KEY,
    status VARCHAR(20) DEFAULT 'Pending'
);

INSERT INTO Orders (order_id) VALUES (101);
</pre>

<h4>Result</h4>
<table>
    <tr>
        <th>order_id</th>
        <th>status</th>
    </tr>
    <tr>
        <td>101</td>
        <td>Pending</td>
    </tr>
</table>

<h3>7. Composite Constraints</h3>
<p>Multiple columns together form a constraint.</p>

<h4>Example (Composite Primary Key)</h4>
<pre>
CREATE TABLE Enrollment (
    student_id INT,
    course_id INT,
    PRIMARY KEY (student_id, course_id)
);
</pre>

<h4>Meaning</h4>
<p>One student cannot enroll in the same course twice.</p>

<h4>Diagram</h4>
<table>
    <tr>
        <th>student_id</th>
        <th>course_id</th>
    </tr>
    <tr>
        <td>1</td>
        <td>CS101</td>
    </tr>
    <tr>
        <td>1</td>
        <td>CS101 ❌</td>
    </tr>
</table>

<h2>Constraint Summary Table</h2>
<table>
    <tr>
        <th>Constraint</th>
        <th>Purpose</th>
    </tr>
    <tr>
        <td>NOT NULL</td>
        <td>No empty values</td>
    </tr>
    <tr>
        <td>UNIQUE</td>
        <td>All values distinct</td>
    </tr>
    <tr>
        <td>PRIMARY KEY</td>
        <td>Unique + Not Null</td>
    </tr>
    <tr>
        <td>FOREIGN KEY</td>
        <td>Referential integrity</td>
    </tr>
    <tr>
        <td>CHECK</td>
        <td>Conditional validation</td>
    </tr>
    <tr>
        <td>DEFAULT</td>
        <td>Automatic default value</td>
    </tr>
</table>
<h1>What is a JOIN?</h1>

<p>A JOIN combines rows from two (or more) tables based on a related column, usually a primary key–foreign key relationship.</p>

<p>Assume this setup. Simple. Clean. No tricks.</p>

<h2>Table: Students</h2>
<table>
    <tr>
        <th>student_id</th>
        <th>name</th>
    </tr>
    <tr><td>1</td><td>Abhi</td></tr>
    <tr><td>2</td><td>Ravi</td></tr>
    <tr><td>3</td><td>Neha</td></tr>
    <tr><td>4</td><td>Kiran</td></tr>
</table>

<h2>Table: Enrollments</h2>
<table>
    <tr>
        <th>student_id</th>
        <th>course</th>
    </tr>
    <tr><td>1</td><td>DBMS</td></tr>
    <tr><td>2</td><td>OS</td></tr>
    <tr><td>2</td><td>CN</td></tr>
    <tr><td>5</td><td>AI</td></tr>
</table>

<h3>Notice:</h3>
<ul>
    <li>student_id = 5 exists only in Enrollments</li>
    <li>student_id = 3,4 exist only in Students</li>
</ul>

<p>This imbalance is where joins show their personality.</p>

<h2>1. INNER JOIN</h2>

<h3>Concept</h3>
<p>Returns only matching rows from both tables.</p>
<p>If there is no match, the row is ignored. Cold. Efficient.</p>

<h3>Textual Diagram</h3>
<pre>Students ∩ Enrollments
(Only common student_id values)</pre>

<h3>SQL Code</h3>
<pre>
SELECT s.student_id, s.name, e.course
FROM Students s
INNER JOIN Enrollments e
ON s.student_id = e.student_id;
</pre>

<h3>Result</h3>
<table>
    <tr>
        <th>student_id</th>
        <th>name</th>
        <th>course</th>
    </tr>
    <tr><td>1</td><td>Abhi</td><td>DBMS</td></tr>
    <tr><td>2</td><td>Ravi</td><td>OS</td></tr>
    <tr><td>2</td><td>Ravi</td><td>CN</td></tr>
</table>

<h3>Key Takeaway</h3>
<ul>
    <li>Drops students with no courses</li>
    <li>Drops enrollments with no student</li>
    <li>Most commonly used join</li>
</ul>

<h2>2. LEFT JOIN (LEFT OUTER JOIN)</h2>

<h3>Concept</h3>
<p>Returns all rows from the left table and matching rows from the right table.</p>
<p>If there’s no match, you get NULLs on the right.</p>

<p>Left table feelings matter more.</p>

<h3>Textual Diagram</h3>
<pre>Students ⟕ Enrollments
(All Students + matching Enrollments)</pre>

<h3>SQL Code</h3>
<pre>
SELECT s.student_id, s.name, e.course
FROM Students s
LEFT JOIN Enrollments e
ON s.student_id = e.student_id;
</pre>

<h3>Result</h3>
<table>
    <tr>
        <th>student_id</th>
        <th>name</th>
        <th>course</th>
    </tr>
    <tr><td>1</td><td>Abhi</td><td>DBMS</td></tr>
    <tr><td>2</td><td>Ravi</td><td>OS</td></tr>
    <tr><td>2</td><td>Ravi</td><td>CN</td></tr>
    <tr><td>3</td><td>Neha</td><td>NULL</td></tr>
    <tr><td>4</td><td>Kiran</td><td>NULL</td></tr>
</table>

<h3>Use Case</h3>
<pre>
Find students without enrollments

WHERE e.course IS NULL;
</pre>

<h2>3. RIGHT JOIN (RIGHT OUTER JOIN)</h2>

<h3>Concept</h3>
<p>Returns all rows from the right table and matching rows from the left.</p>
<p>Same logic as LEFT JOIN, just flipped. Rarely loved. Occasionally useful.</p>

<h3>Textual Diagram</h3>
<pre>Students ⟖ Enrollments
(All Enrollments + matching Students)</pre>

<h3>SQL Code</h3>
<pre>
SELECT s.student_id, s.name, e.course
FROM Students s
RIGHT JOIN Enrollments e
ON s.student_id = e.student_id;
</pre>

<h3>Result</h3>
<table>
    <tr>
        <th>student_id</th>
        <th>name</th>
        <th>course</th>
    </tr>
    <tr><td>1</td><td>Abhi</td><td>DBMS</td></tr>
    <tr><td>2</td><td>Ravi</td><td>OS</td></tr>
    <tr><td>2</td><td>Ravi</td><td>CN</td></tr>
    <tr><td>NULL</td><td>NULL</td><td>AI</td></tr>
</table>

<h3>Insight</h3>
<ul>
    <li>student_id = 5 has no matching student</li>
    <li>Produces NULLs on the left</li>
    <li>Most people replace RIGHT JOIN with LEFT JOIN by swapping tables because sanity.</li>
</ul>

<h2>4. FULL JOIN (FULL OUTER JOIN)</h2>

<h3>Concept</h3>
<p>Returns all rows from both tables.</p>
<ul>
    <li>Matches where possible</li>
    <li>NULLs where not</li>
</ul>

<p>Everyone gets included. No judgment.</p>

<h3>Textual Diagram</h3>
<pre>Students ∪ Enrollments
(All rows from both sides)</pre>

<h3>SQL Code</h3>
<pre>
SELECT s.student_id, s.name, e.course
FROM Students s
FULL OUTER JOIN Enrollments e
ON s.student_id = e.student_id;
</pre>

<h3>Result</h3>
<table>
    <tr>
        <th>student_id</th>
        <th>name</th>
        <th>course</th>
    </tr>
    <tr><td>1</td><td>Abhi</td><td>DBMS</td></tr>
    <tr><td>2</td><td>Ravi</td><td>OS</td></tr>
    <tr><td>2</td><td>Ravi</td><td>CN</td></tr>
    <tr><td>3</td><td>Neha</td><td>NULL</td></tr>
    <tr><td>4</td><td>Kiran</td><td>NULL</td></tr>
    <tr><td>NULL</td><td>NULL</td><td>AI</td></tr>
</table>

<h3>Note</h3>
<p>Not supported directly in MySQL</p>

<pre>
Can be simulated using UNION

SELECT ...
FROM Students s
LEFT JOIN Enrollments e
ON s.student_id = e.student_id

UNION

SELECT ...
FROM Students s
RIGHT JOIN Enrollments e
ON s.student_id = e.student_id;
</pre>

<h2>One-Glance Comparison</h2>
<ul>
    <li>INNER JOIN  → Only matches</li>
    <li>LEFT JOIN   → All left + matches</li>
    <li>RIGHT JOIN  → All right + matches</li>
    <li>FULL JOIN   → Everything</li>
</ul>
<h1>Subqueries in SQL (In Depth)</h1>

<h2>What is a Subquery?</h2>

<p>A subquery is a query written inside another SQL query.</p>

<ul>
    <li>Inner query executes first (usually)</li>
    <li>Result is used by the outer query</li>
</ul>

<p>Can appear in:</p>
<ul>
    <li>SELECT</li>
    <li>FROM</li>
    <li>WHERE</li>
    <li>HAVING</li>
</ul>

<p><strong>Basic syntax:</strong></p>
<pre>
SELECT column
FROM table
WHERE column OPERATOR (SELECT column FROM table);
</pre>

<h2>Types of Subqueries</h2>
<ul>
    <li>Nested (Non-correlated) Subquery</li>
    <li>Correlated Subquery</li>
</ul>

<p>Let’s dissect them slowly, like a DBMS viva examiner would.</p>

<h2>1. Nested Subquery (Non-Correlated)</h2>

<h3>Definition</h3>
<ul>
    <li>A nested subquery is independent of the outer query.</li>
    <li>Inner query runs once</li>
    <li>Outer query uses the result</li>
    <li>No reference to outer query columns inside the subquery</li>
</ul>

<p>Think of it as:</p>
<p><em>“Get some result first, then filter using it.”</em></p>

<h3>Example Table</h3>

<table>
    <tr>
        <th>id</th>
        <th>name</th>
        <th>dept</th>
        <th>salary</th>
    </tr>
    <tr>
        <td>1</td>
        <td>Asha</td>
        <td>IT</td>
        <td>60000</td>
    </tr>
    <tr>
        <td>2</td>
        <td>Ravi</td>
        <td>HR</td>
        <td>40000</td>
    </tr>
    <tr>
        <td>3</td>
        <td>Neha</td>
        <td>IT</td>
        <td>75000</td>
    </tr>
    <tr>
        <td>4</td>
        <td>Aman</td>
        <td>SALES</td>
        <td>50000</td>
    </tr>
</table>

<h3>Example 1: Salary Greater Than Average Salary</h3>

<pre>
SELECT name, salary
FROM EMPLOYEE
WHERE salary &gt; (
    SELECT AVG(salary)
    FROM EMPLOYEE
);
</pre>

<h3>Execution Flow</h3>

<p>Inner query runs:</p>
<pre>SELECT AVG(salary) FROM EMPLOYEE;</pre>

<p>Result → 56250</p>
<p>Outer query filters employees with salary &gt; 56250</p>

<h3>Textual Diagram</h3>
<pre>
Step 1:
EMPLOYEE
   |
   |--> AVG(salary) = 56250
   |
Step 2:
EMPLOYEE
   |
   |--> salary > 56250
         |
         --> Asha, Neha
</pre>

<h3>Example 2: Employees in IT Department</h3>

<pre>
SELECT name
FROM EMPLOYEE
WHERE dept = (
    SELECT dept
    FROM EMPLOYEE
    WHERE name = 'Neha'
);
</pre>

<p>Inner query returns IT. Outer query uses it. Simple. Predictable. Boring. Efficient.</p>

<h3>Key Characteristics</h3>
<ul>
    <li>Executed once</li>
    <li>Faster than correlated subqueries</li>
    <li>Easier to optimize</li>
    <li>Common in exams</li>
</ul>

<h2>2. Correlated Subquery</h2>

<h3>Definition</h3>
<ul>
    <li>A correlated subquery depends on the outer query.</li>
    <li>Inner query executes once per row of the outer query</li>
    <li>References outer query columns</li>
    <li>Slower but powerful</li>
</ul>

<p>Think of it as:</p>
<p><em>“For each row, run another tiny query.”</em></p>

<p>Yes, it’s as expensive as it sounds.</p>

<h3>Example 1: Employees Earning More Than Their Department Average</h3>

<pre>
SELECT e1.name, e1.salary, e1.dept
FROM EMPLOYEE e1
WHERE salary &gt; (
    SELECT AVG(e2.salary)
    FROM EMPLOYEE e2
    WHERE e2.dept = e1.dept
);
</pre>

<h3>How It Executes</h3>

<p>For each employee, SQL:</p>
<ul>
    <li>Finds average salary of that employee’s department</li>
    <li>Compares employee salary with it</li>
</ul>

<h3>Textual Diagram</h3>

<pre>
Outer Query Row: Asha (IT)
   |
   |--> Inner Query:
         AVG(salary) WHERE dept = IT
         = 67500
   |
   |--> 60000 > 67500 ❌

Outer Query Row: Neha (IT)
   |
   |--> AVG(salary) = 67500
   |
   |--> 75000 > 67500 ✅

Outer Query Row: Ravi (HR)
   |
   |--> AVG(salary) = 40000
   |
   |--> 40000 > 40000 ❌
</pre>

<h3>Output</h3>

<table>
    <tr>
        <th>name</th>
        <th>salary</th>
        <th>dept</th>
    </tr>
    <tr>
        <td>Neha</td>
        <td>75000</td>
        <td>IT</td>
    </tr>
</table>

<h3>Example 2: Highest Salary in Each Department</h3>

<pre>
SELECT name, dept, salary
FROM EMPLOYEE e1
WHERE salary = (
    SELECT MAX(e2.salary)
    FROM EMPLOYEE e2
    WHERE e2.dept = e1.dept
);
</pre>

<h3>Why Correlated Subqueries Matter</h3>
<ul>
    <li>Useful when comparison is row-specific</li>
    <li>Often replaced by JOIN + GROUP BY for performance</li>
    <li>Loved by examiners, tolerated by DBAs</li>
</ul>

<h2>Nested vs Correlated (Comparison Table)</h2>

<table>
    <tr>
        <th>Feature</th>
        <th>Nested</th>
        <th>Correlated</th>
    </tr>
    <tr>
        <td>Dependency</td>
        <td>Independent</td>
        <td>Depends on outer query</td>
    </tr>
    <tr>
        <td>Execution</td>
        <td>Once</td>
        <td>Once per row</td>
    </tr>
    <tr>
        <td>Performance</td>
        <td>Faster</td>
        <td>Slower</td>
    </tr>
    <tr>
        <td>Complexity</td>
        <td>Simple</td>
        <td>Complex</td>
    </tr>
    <tr>
        <td>Optimization</td>
        <td>Easy</td>
        <td>Hard</td>
    </tr>
</table>

<h2>When to Use What</h2>

<p><strong>Use nested subquery when:</strong></p>
<ul>
    <li>Inner result is fixed</li>
    <li>Same value applies to all rows</li>
</ul>

<p><strong>Use correlated subquery when:</strong></p>
<ul>
    <li>Calculation varies per row</li>
    <li>Row-by-row comparison needed</li>
</ul>

<h2>Interview Favorite Question</h2>

<p><strong>Q:</strong> Can correlated subqueries be rewritten using JOINs?<br>
<strong>A:</strong> Yes, and they usually should be for performance.</p>

<h3>Example rewrite:</h3>

<pre>
SELECT e.name, e.salary, e.dept
FROM EMPLOYEE e
JOIN (
    SELECT dept, AVG(salary) avg_sal
    FROM EMPLOYEE
    GROUP BY dept
) d
ON e.dept = d.dept
WHERE e.salary > d.avg_sal;
</pre>
<h1>Views in DBMS</h1>

<h2>1. Definition</h2>
<p>A view is a virtual table derived from one or more base tables. It does not store data physically (except for materialized views) but provides a customized representation of the data.</p>
<p>Think of it as a lens: you don’t touch the original table, but you see exactly what you want.</p>

<h2>2. Properties of Views</h2>
<ul>
    <li>Virtual Table: Data is fetched from base tables when queried.</li>
    <li>Derived from SELECT queries: Can involve joins, filters, aggregates.</li>
    <li>Can be updatable or read-only: Depending on underlying query.</li>
    <li>Security: Hide sensitive columns or rows from users.</li>
</ul>

<h2>3. Types of Views</h2>

<h3>Simple View</h3>

<h4>Definition</h4>
<p>A Simple View:</p>
<ul>
    <li>Is based on a single table.</li>
    <li>Does not contain joins, aggregates, or GROUP BY.</li>
    <li>Usually updatable (you can INSERT, UPDATE, DELETE through it).</li>
    <li>Can hide columns or filter rows for convenience or security.</li>
</ul>
<p>Think of it as a custom window into a single table.</p>

<h4>Characteristics</h4>
<ul>
    <li>Derived from one base table only.</li>
    <li>Cannot include: joins with other tables, aggregate functions like SUM, COUNT, GROUP BY, or DISTINCT.</li>
    <li>Can be used for querying and updating the base table.</li>
</ul>

<h4>Advantages</h4>
<ul>
    <li>Security: Hide sensitive columns.</li>
    <li>Simplifies queries for end-users.</li>
    <li>Can rename columns for clarity.</li>
</ul>

<h4>Example Scenario</h4>
<table>
    <tr><th>RollNo</th><th>Name</th><th>Branch</th><th>Marks</th></tr>
    <tr><td>1</td><td>Abhi</td><td>CSE</td><td>90</td></tr>
    <tr><td>2</td><td>Rahul</td><td>ECE</td><td>85</td></tr>
    <tr><td>3</td><td>Sneha</td><td>CSE</td><td>78</td></tr>
</table>

<h4>Create a Simple View</h4>
<pre>
CREATE VIEW StudentMarks AS
SELECT Name, Marks
FROM Students;
</pre>

<h4>Query the View</h4>
<pre>
SELECT * FROM StudentMarks;
</pre>

<table>
    <tr><th>Name</th><th>Marks</th></tr>
    <tr><td>Abhi</td><td>90</td></tr>
    <tr><td>Rahul</td><td>85</td></tr>
    <tr><td>Sneha</td><td>78</td></tr>
</table>

<h4>Textual Diagram</h4>
<pre>
      +-----------+
      | Students  |
      +-----------+
      | RollNo    |
      | Name      |
      | Branch    |
      | Marks     |
      +-----------+
            |
            | SELECT Name, Marks
            v
      +----------------+
      | StudentMarks   |  <- SIMPLE VIEW
      +----------------+
      | Name           |
      | Marks          |
      +----------------+
</pre>

<h4>Updating Through Simple View</h4>
<pre>
-- Update a student's marks
UPDATE StudentMarks
SET Marks = 95
WHERE Name = 'Abhi';

-- Delete a student
DELETE FROM StudentMarks
WHERE Name = 'Rahul';

-- Insert a new student (requires all non-nullable columns)
INSERT INTO Students (RollNo, Name, Branch, Marks)
VALUES (4, 'Anita', 'CSE', 88);
</pre>

<p>All changes automatically affect the base table Students, because the view is just a window.</p>

<h4>Drop the View</h4>
<pre>
DROP VIEW StudentMarks;
</pre>

<p>Summary: Simple View = single table, no joins/aggregates, can be updated. Great for security, simplicity, and hiding details. Acts as a shortcut for repeated queries.</p>

<h3>Complex View</h3>

<h4>Definition</h4>
<p>A complex view is a virtual table derived from more than one base table or involves aggregations, joins, GROUP BY, HAVING, UNION, or subqueries.</p>
<p>Unlike simple views, complex views are often read-only because the database cannot always guarantee how an update affects multiple tables.</p>

<h4>Characteristics</h4>
<ul>
    <li>Based on multiple tables (joins).</li>
    <li>Can include aggregates like SUM, AVG, COUNT.</li>
    <li>Can filter rows using WHERE/HAVING.</li>
    <li>Often read-only.</li>
    <li>Can include computed columns.</li>
</ul>

<h4>Advantages</h4>
<ul>
    <li>Simplifies complex queries into a single virtual table.</li>
    <li>Hides complexity from end users.</li>
    <li>Provides a customized report-like view of data.</li>
    <li>Can enhance security by exposing only necessary columns.</li>
</ul>

<h4>Example Scenario</h4>
<p>We have two tables:</p>

<table>
    <tr><th>RollNo</th><th>Name</th><th>Branch</th><th>Marks</th></tr>
    <tr><td>1</td><td>Abhi</td><td>CSE</td><td>90</td></tr>
    <tr><td>2</td><td>Rahul</td><td>ECE</td><td>85</td></tr>
    <tr><td>3</td><td>Sneha</td><td>CSE</td><td>78</td></tr>
    <tr><td>4</td><td>Priya</td><td>ECE</td><td>92</td></tr>
</table>

<table>
    <tr><th>FacultyID</th><th>Name</th><th>Branch</th></tr>
    <tr><td>F1</td><td>Dr. Kumar</td><td>CSE</td></tr>
    <tr><td>F2</td><td>Dr. Das</td><td>ECE</td></tr>
</table>

<h4>Complex View SQL Code</h4>
<pre>
CREATE VIEW BranchReport AS
SELECT 
    s.Branch,
    COUNT(s.RollNo) AS TotalStudents,
    AVG(s.Marks) AS AvgMarks,
    f.Name AS FacultyName
FROM Students s
JOIN Faculty f
ON s.Branch = f.Branch
GROUP BY s.Branch, f.Name;
</pre>

<h4>Querying the View</h4>
<pre>
SELECT * FROM BranchReport;
</pre>

<table>
    <tr><th>Branch</th><th>TotalStudents</th><th>AvgMarks</th><th>FacultyName</th></tr>
    <tr><td>CSE</td><td>2</td><td>84</td><td>Dr. Kumar</td></tr>
    <tr><td>ECE</td><td>2</td><td>88.5</td><td>Dr. Das</td></tr>
</table>

<h4>Textual Diagram</h4>
<pre>
  +-----------+       +---------+
  | Students  |       | Faculty |
  +-----------+       +---------+
  | RollNo    |       | FacultyID
  | Name      |       | Name
  | Branch    |       | Branch
  | Marks     |
  +-----------+       +---------+
         \             /
          \  JOIN ON Branch
           \         /
            v
      +----------------------+
      | BranchReport VIEW    |
      +----------------------+
      | Branch               |
      | TotalStudents        | <- COUNT
      | AvgMarks             | <- AVG
      | FacultyName          |
      +----------------------+
</pre>

<h3>Materialized View</h3>

<h4>Definition</h4>
<p>A materialized view (MV) is a precomputed, stored view that contains the results of a query. Unlike regular views, it physically stores data.</p>
<ul>
    <li>Helps speed up queries.</li>
    <li>Needs refresh to stay consistent with base tables.</li>
</ul>

<h4>Key Points</h4>
<ul>
    <li>Stored physically on disk.</li>
    <li>Can be refreshed:
        <ul>
            <li>Complete refresh: Recompute the whole MV.</li>
            <li>Fast/Incremental refresh: Update only changed data (if supported).</li>
        </ul>
    </li>
    <li>Used in data warehousing for aggregation-heavy queries.</li>
    <li>Improves query performance but takes storage space.</li>
</ul>

<h4>Advantages</h4>
<ul>
    <li>Faster query execution.</li>
    <li>Useful for complex aggregations.</li>
    <li>Can be indexed like a regular table.</li>
</ul>

<h4>Disadvantages</h4>
<ul>
    <li>Needs storage.</li>
    <li>Refreshing can be costly.</li>
    <li>May get out of sync with base tables if not refreshed properly.</li>
</ul>

<h4>Example Scenario</h4>
<table>
    <tr><th>SaleID</th><th>Product</th><th>Quantity</th><th>Price</th></tr>
    <tr><td>1</td><td>Laptop</td><td>2</td><td>50000</td></tr>
    <tr><td>2</td><td>Mouse</td><td>5</td><td>500</td></tr>
    <tr><td>3</td><td>Laptop</td><td>1</td><td>50000</td></tr>
    <tr><td>4</td><td>Keyboard</td><td>2</td><td>1000</td></tr>
</table>

<h4>Creating a Materialized View</h4>
<pre>
CREATE MATERIALIZED VIEW ProductSales AS
SELECT Product, SUM(Quantity*Price) AS TotalSales
FROM Sales
GROUP BY Product
WITH DATA;   -- Stores the data physically
</pre>

<h4>Querying the MV</h4>
<pre>
SELECT * FROM ProductSales;
</pre>

<table>
    <tr><th>Product</th><th>TotalSales</th></tr>
    <tr><td>Laptop</td><td>150000</td></tr>
    <tr><td>Mouse</td><td>2500</td></tr>
    <tr><td>Keyboard</td><td>2000</td></tr>
</table>

<h4>Refreshing the MV</h4>
<pre>
-- Complete Refresh
REFRESH MATERIALIZED VIEW ProductSales;

-- Fast/Incremental Refresh (DBMS-dependent)
</pre>

<h4>Textual Diagram</h4>
<pre>
  +------------+
  |   Sales    |  <- Base Table
  +------------+
  | SaleID     |
  | Product    |
  | Quantity   |
  | Price      |
  +------------+
        |
        | Aggregate: SUM(Quantity*Price) GROUP BY Product
        v
  +---------------------+
  |   ProductSales      |  <- Materialized View
  +---------------------+
  | Product             |
  | TotalSales          |
  +---------------------+
(Stored physically on disk, needs refresh to sync)
</pre>
<h1>1. What is an Index?</h1>

<p>An index is a data structure that improves the speed of data retrieval from a table at the cost of extra space and maintenance overhead. Think of it as the index in a book—you don’t read every page, you jump straight to the relevant section.</p>

<h3>Why use it?</h3>
<ul>
    <li>Fast searching (WHERE, JOIN, ORDER BY, GROUP BY)</li>
    <li>Efficient range queries</li>
</ul>

<h3>Drawbacks</h3>
<ul>
    <li>Takes extra storage</li>
    <li>Slows down INSERT, UPDATE, DELETE</li>
</ul>

<h2>2. Types of Indexes</h2>

<h3>1. What is a Single-Level (Primary) Index?</h3>
<p>A Single-Level Index is the simplest form of indexing. It has one level of index table pointing directly to the actual records.</p>

<p><strong>Primary Index means:</strong></p>
<ul>
    <li>Built on primary key (unique, not null)</li>
    <li>Typically a clustered index, meaning the table is stored in the order of the key</li>
    <li>Dense vs Sparse: Usually sparse because we can point to blocks rather than each row (to save space)</li>
</ul>

<p><strong>Key Idea:</strong> Index table = key + pointer to block of records. Only one level, unlike B+ trees which are multi-level.</p>

<h3>2. Structure / Components</h3>
<ul>
    <li><strong>Index Key</strong> → The primary key of the table</li>
    <li><strong>Pointer</strong> → Points to the disk block containing the record</li>
</ul>

<h3>Textual Diagram (Sparse Primary Index)</h3>

<p>Suppose a Student table:</p>
<table>
    <tr><th>ID</th><th>Name</th><th>Age</th></tr>
    <tr><td>101</td><td>Abhi</td><td>21</td></tr>
    <tr><td>102</td><td>Raj</td><td>20</td></tr>
    <tr><td>103</td><td>Anya</td><td>22</td></tr>
    <tr><td>104</td><td>Tina</td><td>21</td></tr>
    <tr><td>105</td><td>Sara</td><td>23</td></tr>
</table>

<p>Assume each disk block stores 2 records.</p>

<p><strong>Data Blocks:</strong></p>
<ul>
    <li>Block 1 → 101, 102</li>
    <li>Block 2 → 103, 104</li>
    <li>Block 3 → 105</li>
</ul>

<p><strong>Primary Index Table (Sparse)</strong></p>
<table>
    <tr><th>Key</th><th>Pointer</th></tr>
    <tr><td>101</td><td>→ Block1</td></tr>
    <tr><td>103</td><td>→ Block2</td></tr>
    <tr><td>105</td><td>→ Block3</td></tr>
</table>

<h3>How it works</h3>
<p>Search for ID=104</p>
<ul>
    <li>Index table tells: 104 > 103 → go to Block2 → scan inside Block2 → find 104</li>
</ul>
<p>Fewer blocks scanned than full table → faster</p>

<h3>3. Advantages of Single-Level (Primary) Index</h3>
<ul>
    <li>Faster search compared to linear scan</li>
    <li>Easy to implement</li>
    <li>Reduces I/O if sparse index is used</li>
</ul>

<h3>Drawbacks</h3>
<ul>
    <li>Not suitable for huge tables → index table becomes large</li>
    <li>Insertion/deletion may require shifting in index table (if clustered)</li>
</ul>

<h3>4. SQL Example</h3>
<pre>
-- Create a table with primary key (auto primary index)
CREATE TABLE Student (
    ID INT PRIMARY KEY,   -- automatically creates a primary index
    Name VARCHAR(50),
    Age INT
);

-- Insert sample records
INSERT INTO Student VALUES (101, 'Abhi', 21);
INSERT INTO Student VALUES (102, 'Raj', 20);
INSERT INTO Student VALUES (103, 'Anya', 22);
INSERT INTO Student VALUES (104, 'Tina', 21);
INSERT INTO Student VALUES (105, 'Sara', 23);

-- Query using primary key (uses index)
SELECT * FROM Student WHERE ID = 104;

-- Drop table if needed
DROP TABLE Student;
</pre>

<h3>Notes</h3>
<ul>
    <li>In most RDBMS (MySQL, SQL Server, Oracle), PRIMARY KEY automatically creates a clustered primary index.</li>
    <li>Sparse primary index is typically handled internally, you don’t create it manually.</li>
</ul>
<h1>1. What is a Secondary Index?</h1>

<p>A secondary index is an index built on a non-primary key column (or a non-clustering key in case of clustered tables).</p>

<ul>
    <li>It does not affect the physical order of rows in the table.</li>
    <li>Allows fast retrieval on columns that are not unique or not primary.</li>
    <li>Can be dense or sparse.</li>
</ul>

<p><strong>Key points:</strong></p>
<ul>
    <li>Primary index → unique, one per table</li>
    <li>Secondary index → can have duplicates, multiple allowed per table</li>
</ul>

<h2>2. Why Secondary Index?</h2>

<ul>
    <li>Speeds up queries on non-key columns.</li>
    <li>Improves performance for joins, filters, and range queries on non-primary key columns.</li>
</ul>

<h3>Downside:</h3>
<ul>
    <li>Extra storage</li>
    <li>Slows INSERT/UPDATE/DELETE due to index maintenance</li>
</ul>

<h2>3. Example Table</h2>
<table>
    <tr><th>ID</th><th>Name</th><th>Age</th><th>Branch</th></tr>
    <tr><td>101</td><td>Abhi</td><td>21</td><td>CSE</td></tr>
    <tr><td>102</td><td>Raj</td><td>20</td><td>ECE</td></tr>
    <tr><td>103</td><td>Anya</td><td>22</td><td>CSE</td></tr>
    <tr><td>104</td><td>Tina</td><td>21</td><td>ME</td></tr>
    <tr><td>105</td><td>Ravi</td><td>23</td><td>ECE</td></tr>
</table>

<p>Primary key: ID</p>
<p>Secondary index: Branch</p>

<h2>4. Textual Diagram of Secondary Index</h2>

<p>Secondary Index on Branch (non-clustered):</p>
<table>
    <tr><th>Branch</th><th>Pointers</th></tr>
    <tr><td>CSE</td><td>→ Row1, Row3</td></tr>
    <tr><td>ECE</td><td>→ Row2, Row5</td></tr>
    <tr><td>ME</td><td>→ Row4</td></tr>
</table>

<p>Query: <code>SELECT * FROM Student WHERE Branch='ECE';</code></p>
<ul>
    <li>Without index: scan all 5 rows</li>
    <li>With secondary index: jump directly to Row2 and Row5</li>
</ul>

<p>Notice that the actual table rows are not in Branch order; the index is separate.</p>

<h3>B+ Tree Representation (Simplified)</h3>
<pre>
         [CSE | ECE | ME]
        /     |     \
  Row1,Row3  Row2,Row5  Row4
</pre>

<p>Leaf nodes contain pointers to table rows.</p>
<p>Searching for a branch → log(n) instead of full scan</p>

<h2>5. SQL Code Example</h2>
<pre>
-- Create the table
CREATE TABLE Student (
    ID INT PRIMARY KEY,
    Name VARCHAR(50),
    Age INT,
    Branch VARCHAR(10)
);

-- Insert data
INSERT INTO Student VALUES
(101,'Abhi',21,'CSE'),
(102,'Raj',20,'ECE'),
(103,'Anya',22,'CSE'),
(104,'Tina',21,'ME'),
(105,'Ravi',23,'ECE');

-- Create secondary index on Branch
CREATE INDEX idx_branch ON Student(Branch);

-- Query using secondary index
SELECT * FROM Student WHERE Branch='ECE';

-- Drop the secondary index
DROP INDEX idx_branch ON Student;
</pre>

<h2>6. Notes</h2>
<ul>
    <li>Secondary index can have duplicate keys (multiple students in same branch).</li>
    <li>Good candidate columns: frequently searched but not primary key, like Name, Department, Status, etc.</li>
    <li>Secondary index is non-clustered by default in most DBMS (except some systems allow clustered secondary indexes).</li>
</ul>
<h1>1. What is a Dense Index?</h1>

<p>A Dense Index is an index in which every search key value in the table has a corresponding entry in the index.</p>
<ul>
    <li>Every row in the table has an index entry.</li>
    <li>Can be primary (on primary key) or secondary (on non-key attributes).</li>
    <li>Speeds up searches significantly, because you don’t skip any key.</li>
</ul>

<h3>Comparison</h3>
<table>
    <tr>
        <th>Feature</th>
        <th>Dense Index</th>
        <th>Sparse Index</th>
    </tr>
    <tr>
        <td>Index entry for every record?</td>
        <td>Yes</td>
        <td>No (only some records)</td>
    </tr>
    <tr>
        <td>Space</td>
        <td>More</td>
        <td>Less</td>
    </tr>
    <tr>
        <td>Search speed</td>
        <td>Fast</td>
        <td>Slightly slower</td>
    </tr>
</table>

<h2>2. Structure of Dense Index</h2>

<p>Suppose we have a table Student:</p>
<table>
    <tr><th>ID</th><th>Name</th><th>Age</th></tr>
    <tr><td>101</td><td>Abhi</td><td>21</td></tr>
    <tr><td>102</td><td>Raj</td><td>20</td></tr>
    <tr><td>103</td><td>Anya</td><td>22</td></tr>
    <tr><td>104</td><td>Tina</td><td>21</td></tr>
</table>

<p><strong>Dense Index on ID:</strong></p>
<table>
    <tr><th>Key</th><th>Pointer to Row</th></tr>
    <tr><td>101</td><td>Row 1</td></tr>
    <tr><td>102</td><td>Row 2</td></tr>
    <tr><td>103</td><td>Row 3</td></tr>
    <tr><td>104</td><td>Row 4</td></tr>
</table>

<h3>How search works</h3>
<p>Query: <code>SELECT * FROM Student WHERE ID = 103;</code></p>
<ul>
    <li>Index lookup: Jump to 103 → Row 3</li>
    <li>No need to scan other rows.</li>
</ul>

<h3>Textual Diagram (B+ Tree style)</h3>
<pre>
       [102]
      /    \
   [101]  [103,104]
</pre>
<p>Internal nodes contain keys for navigation. Leaf nodes contain all keys (dense) and pointers to actual table rows. Search is O(log n) instead of linear scan.</p>

<h2>3. Example Use Case</h2>

<p>Table: Employees</p>
<table>
    <tr><th>EmpID</th><th>Name</th><th>Salary</th></tr>
    <tr><td>1</td><td>Alice</td><td>5000</td></tr>
    <tr><td>2</td><td>Bob</td><td>4500</td></tr>
    <tr><td>3</td><td>Carol</td><td>5500</td></tr>
    <tr><td>4</td><td>Dave</td><td>6000</td></tr>
</table>

<p><strong>Dense index on EmpID:</strong></p>
<table>
    <tr><th>EmpID</th><th>Pointer</th></tr>
    <tr><td>1</td><td>Row1</td></tr>
    <tr><td>2</td><td>Row2</td></tr>
    <tr><td>3</td><td>Row3</td></tr>
    <tr><td>4</td><td>Row4</td></tr>
</table>

<p>Query: <code>SELECT * FROM Employee WHERE EmpID = 3;</code></p>
<p>Index directly points to Row3 → Carol.</p>

<h2>4. SQL Code Example</h2>
<pre>
-- Create table
CREATE TABLE Employee (
    EmpID INT PRIMARY KEY,
    Name VARCHAR(50),
    Salary INT
);

-- Primary key automatically creates a dense index
-- Secondary dense index on Name
CREATE INDEX idx_name ON Employee(Name);

-- Query using index
SELECT * FROM Employee WHERE Name = 'Carol';

-- Drop index
DROP INDEX idx_name ON Employee;
</pre>

<h3>Notes</h3>
<ul>
    <li>Dense indexes are ideal for columns that are frequently searched.</li>
    <li>They consume more space than sparse indexes because every record is indexed.</li>
</ul>
<h1>1. What is a Sparse Index?</h1>

<p>A sparse index is an index in which not every search key has an entry. Instead, only some keys are stored in the index, typically one per block or page of data.</p>

<ul>
    <li>Reduces index size → less storage.</li>
    <li>Needs a full table scan within a block after finding the block via index.</li>
    <li>Usually used with clustered indexes, where data is sorted on the search key.</li>
</ul>

<p><strong>Contrast with dense index:</strong></p>
<ul>
    <li>Dense index: Entry for every record.</li>
    <li>Sparse index: Entry for only some records (usually first record of each block/page).</li>
</ul>

<h2>2. When to Use Sparse Index</h2>
<ul>
    <li>Large tables where full indexing is expensive.</li>
    <li>Data is sorted on the search key.</li>
    <li>Faster than scanning the entire table but slower than dense index.</li>
</ul>

<h2>3. Example Table: Student</h2>
<table>
    <tr><th>ID</th><th>Name</th><th>Age</th></tr>
    <tr><td>101</td><td>Abhi</td><td>21</td></tr>
    <tr><td>102</td><td>Raj</td><td>20</td></tr>
    <tr><td>103</td><td>Anya</td><td>22</td></tr>
    <tr><td>104</td><td>Tina</td><td>21</td></tr>
    <tr><td>105</td><td>John</td><td>23</td></tr>
    <tr><td>106</td><td>Sara</td><td>20</td></tr>
</table>

<p>Assume block/page size = 2 rows.</p>

<h2>4. Sparse Index Construction</h2>

<p><strong>Step 1:</strong> Divide table into blocks (2 rows each)</p>
<ul>
    <li>Block 1: 101 Abhi, 102 Raj</li>
    <li>Block 2: 103 Anya, 104 Tina</li>
    <li>Block 3: 105 John, 106 Sara</li>
</ul>

<p><strong>Step 2:</strong> Create sparse index (one entry per block)</p>

<table>
    <tr><th>Key</th><th>Pointer to Block</th></tr>
    <tr><td>101</td><td>→ Block 1</td></tr>
    <tr><td>103</td><td>→ Block 2</td></tr>
    <tr><td>105</td><td>→ Block 3</td></tr>
</table>

<p>Notice not every record is in the index. When searching, first locate the block, then scan within the block.</p>

<h2>5. Textual Diagram</h2>

<p><strong>Sparse Index Table:</strong></p>
<table>
    <tr><th>Key</th><th>Pointer</th></tr>
    <tr><td>101</td><td>Block 1</td></tr>
    <tr><td>103</td><td>Block 2</td></tr>
    <tr><td>105</td><td>Block 3</td></tr>
</table>

<p><strong>Data Blocks:</strong></p>
<ul>
    <li>Block 1: 101 Abhi, 102 Raj</li>
    <li>Block 2: 103 Anya, 104 Tina</li>
    <li>Block 3: 105 John, 106 Sara</li>
</ul>

<h3>Query Example</h3>
<pre>
SELECT * FROM Student WHERE ID = 104;

Step 1: Sparse index → 104 ≥ 103 → Block 2
Step 2: Scan Block 2 → Find 104 Tina
</pre>

<h2>6. SQL Simulation</h2>
<p>SQL doesn’t support “sparse index” explicitly, but you can simulate the idea with a clustered index or partial index in some DBMS.</p>
<pre>
-- Sorted table on ID (clustered index)
CREATE TABLE Student (
    ID INT PRIMARY KEY,
    Name VARCHAR(50),
    Age INT
);

-- Non-clustered index on every 2nd row (simulate sparse index)
-- Not exact in SQL, but conceptually:
CREATE INDEX idx_sparse ON Student(ID);
</pre>

<p>The DBMS decides whether to make dense or sparse index internally for clustered tables.</p>
<p>Sparse indexes are more of a conceptual thing in textbooks and storage engines.</p>

<h2>7. Summary</h2>
<ul>
    <li>Sparse index = fewer entries → less space</li>
    <li>Works best with sorted/clustered data</li>
    <li>Slower than dense for single record search, faster for block-level access</li>
    <li>Typically used in B+ tree structures for primary key indexing</li>
</ul>
<h1>1. What is a Clustered Index?</h1>

<p>A clustered index determines the physical order of data rows in a table.</p>
<ul>
    <li>Table rows are stored in the order of the clustered index key.</li>
    <li>A table can have only one clustered index because the data rows can only be sorted one way.</li>
    <li>Often automatically created when you define a PRIMARY KEY.</li>
</ul>

<p><strong>Analogy:</strong> Think of a library where all books are arranged by ISBN. If you want a book with a particular ISBN, you don’t scan shelves randomly; you go straight to the right position.</p>

<h3>Pros:</h3>
<ul>
    <li>Very fast range queries (BETWEEN, &lt;, &gt;)</li>
    <li>Efficient for sorting</li>
</ul>

<h3>Cons:</h3>
<ul>
    <li>Slower INSERT/UPDATE if new rows break the order (table may need to rearrange)</li>
    <li>Only one per table</li>
</ul>

<h2>2. Clustered vs Non-Clustered Index</h2>
<table>
    <tr>
        <th>Feature</th>
        <th>Clustered</th>
        <th>Non-Clustered</th>
    </tr>
    <tr>
        <td>Physical order</td>
        <td>Data rows sorted</td>
        <td>Data rows separate</td>
    </tr>
    <tr>
        <td>Number per table</td>
        <td>1</td>
        <td>Multiple allowed</td>
    </tr>
    <tr>
        <td>Storage</td>
        <td>B+ tree leaf nodes point to actual rows</td>
        <td>Leaf nodes store pointers to rows</td>
    </tr>
    <tr>
        <td>Ideal for</td>
        <td>Range queries, ORDER BY</td>
        <td>Columns frequently searched but not sorted</td>
    </tr>
</table>

<h2>3. Textual Diagram of Clustered Index</h2>

<p>Let’s take a Student table:</p>
<table>
    <tr><th>ID</th><th>Name</th><th>Age</th></tr>
    <tr><td>101</td><td>Abhi</td><td>21</td></tr>
    <tr><td>102</td><td>Raj</td><td>20</td></tr>
    <tr><td>103</td><td>Anya</td><td>22</td></tr>
    <tr><td>104</td><td>Tina</td><td>21</td></tr>
</table>

<p><strong>Clustered Index on ID (primary key):</strong></p>
<pre>
Clustered Index B+ Tree (Simplified):

            [102]
           /    \
       [101]    [103,104]

Leaf nodes point directly to table rows:

[101] → Row with ID=101
[102] → Row with ID=102
[103] → Row with ID=103
[104] → Row with ID=104
</pre>

<p><strong>Query:</strong></p>
<pre>
SELECT * FROM Student WHERE ID = 103;
</pre>
<p>The database goes through the B+ tree, finds 103, and directly accesses the row.</p>
<p>No separate pointer table needed, unlike non-clustered indexes.</p>

<p><strong>Range Query Example:</strong></p>
<pre>
SELECT * FROM Student WHERE ID BETWEEN 101 AND 103;
</pre>
<p>The database can directly access rows 101 → 103 in order, very fast.</p>

<h2>4. SQL Examples</h2>

<h3>Creating Clustered Index</h3>
<pre>
-- PRIMARY KEY automatically creates clustered index in most RDBMS
CREATE TABLE Student (
    ID INT PRIMARY KEY,   -- Clustered index created here
    Name VARCHAR(50),
    Age INT
);

-- Explicit clustered index (SQL Server syntax)
CREATE CLUSTERED INDEX idx_student_id
ON Student(ID);
</pre>

<h3>Query Using Clustered Index</h3>
<pre>
-- Fast lookup using clustered index
SELECT * FROM Student WHERE ID = 104;

-- Fast range query
SELECT * FROM Student WHERE ID BETWEEN 101 AND 103;

-- Sorting uses clustered index
SELECT * FROM Student ORDER BY ID;
</pre>

<h3>Dropping Clustered Index</h3>
<pre>
-- SQL Server
DROP INDEX idx_student_id ON Student;
</pre>

<p><strong>Note:</strong> In MySQL (InnoDB), the PRIMARY KEY is always a clustered index.</p>

<h2>5. Key Points</h2>
<ul>
    <li>Only one clustered index per table</li>
    <li>Leaf nodes store actual data rows</li>
    <li>Best for range queries, ORDER BY, and primary key lookups</li>
    <li>Slower for inserts and updates if they break the physical order</li>
</ul>
<h1>1. What is a Non-Clustered Index?</h1>

<p>A non-clustered index (NCI) is an index where the logical order of the index does not match the physical order of rows in the table.</p>

<ul>
    <li>The table data remains in the original order.</li>
    <li>The index contains pointers to the actual data rows.</li>
    <li>One table can have multiple non-clustered indexes.</li>
    <li>Faster search on columns that are not the primary key.</li>
</ul>

<p>Think of it like a separate lookup table that tells you “where to find this value in the main table.”</p>

<h2>2. How It Works (Textual Diagram)</h2>

<p>Consider a Student table:</p>
<table>
    <tr><th>Row</th><th>ID</th><th>Name</th><th>Age</th></tr>
    <tr><td>1</td><td>101</td><td>Abhi</td><td>21</td></tr>
    <tr><td>2</td><td>102</td><td>Raj</td><td>20</td></tr>
    <tr><td>3</td><td>103</td><td>Anya</td><td>22</td></tr>
    <tr><td>4</td><td>104</td><td>Tina</td><td>21</td></tr>
</table>

<p>Non-Clustered Index on Name:</p>
<table>
    <tr><th>Name</th><th>Row Pointer</th></tr>
    <tr><td>Abhi</td><td>→ Row1</td></tr>
    <tr><td>Anya</td><td>→ Row3</td></tr>
    <tr><td>Raj</td><td>→ Row2</td></tr>
    <tr><td>Tina</td><td>→ Row4</td></tr>
</table>

<p>Physical table rows remain in ID order. Index is sorted on Name for fast searching.</p>

<p>Query example:</p>
<pre>SELECT * FROM Student WHERE Name='Tina';</pre>

<p>Index is used to find Row4 quickly, then fetch actual data from table.</p>

<h3>Visualization with Simple B+ Tree (Non-Clustered)</h3>
<pre>
         [Anya, Raj]
        /          \
   [Abhi]          [Tina]
</pre>
<p>Leaves contain row pointers. Table data is separate. Multiple NCIs can exist for different columns.</p>

<h2>3. SQL Examples</h2>

<h3>Creating a Non-Clustered Index</h3>
<pre>
CREATE TABLE Student (
    ID INT PRIMARY KEY,  -- Clustered index by default
    Name VARCHAR(50),
    Age INT
);

-- Create non-clustered index on Name
CREATE NONCLUSTERED INDEX idx_name
ON Student(Name);

-- Create non-clustered index on Age
CREATE NONCLUSTERED INDEX idx_age
ON Student(Age);
</pre>

<h3>Query Using Non-Clustered Index</h3>
<pre>
-- Finds the row faster using index
SELECT * FROM Student WHERE Name='Anya';

-- Range queries benefit too
SELECT * FROM Student WHERE Age BETWEEN 20 AND 21;
</pre>

<h3>Dropping a Non-Clustered Index</h3>
<pre>
DROP INDEX idx_name ON Student;
</pre>

<h2>4. Key Points</h2>
<ul>
    <li>NCI does not change physical order of table rows.</li>
    <li>Can have many non-clustered indexes on a table.</li>
    <li>Useful for columns frequently searched or joined.</li>
    <li>Slight overhead on insert/update/delete because index must be maintained.</li>
</ul>
<h1>1. Stored Procedures</h1>

<h3>Definition:</h3>
<p>A stored procedure is a set of SQL statements saved in the database, which can be executed repeatedly by calling its name.</p>

<h3>Purpose:</h3>
<ul>
    <li>Reusability</li>
    <li>Reduce network traffic</li>
    <li>Encapsulate business logic</li>
    <li>Improve performance (precompiled)</li>
</ul>

<h3>Types:</h3>
<ul>
    <li>Parameterless</li>
    <li>Parameterized (IN, OUT, INOUT parameters)</li>
</ul>

<h3>Syntax (MySQL Example):</h3>
<pre>
CREATE PROCEDURE procedure_name (parameters)
BEGIN
   -- SQL statements
END;
</pre>

<h3>Parameters:</h3>
<ul>
    <li><strong>IN</strong> → input parameter</li>
    <li><strong>OUT</strong> → output parameter</li>
    <li><strong>INOUT</strong> → both input and output</li>
</ul>

<h3>Example: Salary Update Procedure</h3>
<pre>
DELIMITER //

CREATE PROCEDURE UpdateSalary(IN empID INT, IN increment DECIMAL(10,2))
BEGIN
    UPDATE Employee
    SET Salary = Salary + increment
    WHERE EmployeeID = empID;
END //

DELIMITER ;
</pre>

<h3>Execution:</h3>
<pre>
CALL UpdateSalary(101, 5000);
</pre>

<h3>Textual Diagram:</h3>
<pre>
[Client Application]
        |
        | CALL UpdateSalary(101, 5000)
        v
[Database Stored Procedure Engine]
        |
        | Executes SQL: UPDATE Employee SET Salary=Salary+5000 WHERE EmployeeID=101
        v
[Employee Table Updated]
</pre>

<h1>2. Triggers</h1>

<h3>Definition:</h3>
<p>A trigger is a set of SQL statements that automatically executes when a specific event occurs on a table.</p>

<h3>Purpose:</h3>
<ul>
    <li>Maintain integrity</li>
    <li>Audit changes</li>
    <li>Auto-update logs or counters</li>
</ul>

<h3>Trigger Events:</h3>
<ul>
    <li>INSERT, UPDATE, DELETE</li>
</ul>

<h3>Trigger Timing:</h3>
<ul>
    <li><strong>BEFORE</strong> → Executes before the event</li>
    <li><strong>AFTER</strong> → Executes after the event</li>
</ul>

<h3>Syntax (MySQL Example):</h3>
<pre>
CREATE TRIGGER trigger_name
{BEFORE | AFTER} {INSERT | UPDATE | DELETE}
ON table_name
FOR EACH ROW
BEGIN
    -- SQL statements
END;
</pre>

<h3>Example: Audit Trigger for Salary Changes</h3>
<pre>
DELIMITER //

CREATE TRIGGER SalaryChangeAudit
AFTER UPDATE ON Employee
FOR EACH ROW
BEGIN
    IF OLD.Salary <> NEW.Salary THEN
        INSERT INTO SalaryAudit(EmployeeID, OldSalary, NewSalary, ChangeDate)
        VALUES (OLD.EmployeeID, OLD.Salary, NEW.Salary, NOW());
    END IF;
END //

DELIMITER ;
</pre>

<h3>Explanation:</h3>
<p>Every time a salary is updated, the trigger automatically logs the old and new salary into SalaryAudit table.</p>

<h3>Textual Diagram:</h3>
<pre>
[Update Employee Table]
        |
        | UPDATE Employee SET Salary=Salary+5000 WHERE EmployeeID=101
        v
[Trigger: SalaryChangeAudit]
        |
        | IF salary changed -> INSERT into SalaryAudit
        v
[SalaryAudit Table Updated Automatically]
</pre>

<h3>Stored Procedure vs Trigger:</h3>
<table>
    <tr>
        <th>Feature</th>
        <th>Stored Procedure</th>
        <th>Trigger</th>
    </tr>
    <tr>
        <td>Execution</td>
        <td>Manual (CALL command)</td>
        <td>Automatic (on event)</td>
    </tr>
    <tr>
        <td>Event Dependency</td>
        <td>Not dependent on table events</td>
        <td>Always tied to table events</td>
    </tr>
    <tr>
        <td>Purpose</td>
        <td>Encapsulate logic, reusable</td>
        <td>Maintain integrity, audit, automate</td>
    </tr>
    <tr>
        <td>Parameters</td>
        <td>Can have IN, OUT, INOUT</td>
        <td>Cannot take parameters</td>
    </tr>
    <tr>
        <td>Invocation</td>
        <td>Explicit</td>
        <td>Implicit</td>
    </tr>
</table>
<h1>Normalisation</h1>
<h2>1. Definition</h2>
<p>A <strong>Functional Dependency (FD)</strong> is a constraint between two sets of attributes in a relation.</p>

<p>If we have a relation <strong>R</strong> and attributes <strong>X</strong> and <strong>Y</strong> in R, we say:</p>
<p><strong>X → Y</strong> (read as “X functionally determines Y”) if, for any two tuples in R, whenever the tuples have the same value for X, they must also have the same value for Y.</p>

<ul>
    <li><strong>X</strong> → determinant</li>
    <li><strong>Y</strong> → dependent</li>
</ul>

<p><strong>Key idea:</strong> Knowing X is enough to know Y.</p>

<h1>2. Examples</h1>

<h3>Example 1: Student Table</h3>
<table>
    <tr><th>StudentID</th><th>Name</th><th>Branch</th><th>Phone</th></tr>
    <tr><td>101</td><td>Abhishek</td><td>CSE</td><td>9999999999</td></tr>
    <tr><td>102</td><td>Ravi</td><td>ECE</td><td>8888888888</td></tr>
    <tr><td>103</td><td>Meera</td><td>CSE</td><td>7777777777</td></tr>
</table>

<ul>
    <li>StudentID → Name (Knowing StudentID gives exactly one Name)</li>
    <li>StudentID → Branch (Knowing StudentID gives exactly one Branch)</li>
    <li>Name → Branch (Not necessarily true; two students could have same name but different branches)</li>
</ul>

<h3>Example 2: Course Table</h3>
<table>
    <tr><th>CourseCode</th><th>CourseName</th><th>Credits</th></tr>
    <tr><td>CS101</td><td>DataStruct</td><td>4</td></tr>
    <tr><td>MA101</td><td>Calculus</td><td>3</td></tr>
    <tr><td>CS102</td><td>Algorithms</td><td>4</td></tr>
</table>

<ul>
    <li>CourseCode → CourseName, Credits (yes, uniquely identifies course)</li>
    <li>CourseName → CourseCode? Only if course names are unique (sometimes not)</li>
</ul>

<h1>3. Types of Functional Dependencies</h1>

<ul>
    <li><strong>Trivial FD:</strong> When Y ⊆ X in X → Y. Example: {StudentID, Name} → Name</li>
    <li><strong>Non-trivial FD:</strong> Y ⊈ X in X → Y. Example: StudentID → Branch</li>
    <li><strong>Completely non-trivial:</strong> Y has no overlap with X. Example: StudentID → Branch (assuming StudentID ≠ Branch)</li>
</ul>

<h1>4. Closure of Attributes</h1>
<p>The closure of a set of attributes <strong>X</strong>, written as <strong>X⁺</strong>, is the set of all attributes functionally determined by X.</p>
<p>Example: For StudentID → Name, Branch, Phone,</p>
<p><strong>StudentID⁺ = {StudentID, Name, Branch, Phone}</strong></p>

<h1>5. Rules (Armstrong’s Axioms)</h1>
<ul>
    <li><strong>Reflexivity:</strong> If Y ⊆ X, then X → Y</li>
    <li><strong>Augmentation:</strong> If X → Y, then XZ → YZ</li>
    <li><strong>Transitivity:</strong> If X → Y and Y → Z, then X → Z</li>
    <li>Other derived rules: Union, Decomposition, Pseudo-transitivity</li>
</ul>

<h1>6. Textual Diagram</h1>
<pre>
StudentID ──────> Name
      │
      │
      └─────────> Branch
      │
      └─────────> Phone
</pre>
<p>Arrow shows “functionally determines”. Single determinant can determine multiple attributes.</p>

<h1>7. Importance in DBMS</h1>
<ul>
    <li>Identify keys of a table</li>
    <li>Normalize relations (1NF, 2NF, 3NF, BCNF…)</li>
    <li>Avoid redundancy and anomalies</li>
</ul>
<h1>Attribute Closure</h1>

<h2>1. Definition</h2>
<p>The closure of a set of attributes in a relation is the set of all attributes that can be functionally determined by that set using the given functional dependencies (FDs).</p>

<p><strong>Notation:</strong> If you have a set of attributes <em>X</em> in relation <em>R</em>, the closure of <em>X</em> is denoted as <em>X<sup>+</sup></em>.</p>

<h3>Why it matters:</h3>
<ul>
    <li>To check if <em>X</em> is a superkey</li>
    <li>To test if a functional dependency is implied</li>
    <li>Used in normalization (like BCNF)</li>
</ul>

<h2>2. Steps to compute closure</h2>
<p>Given: Relation <em>R</em> and a set of FDs <em>F</em></p>

<ol>
    <li>Start with <em>X<sup>+</sup> = X</em></li>
    <li>For each FD <em>Y → Z</em> in <em>F</em>:<br>
        If <em>Y ⊆ X<sup>+</sup></em>, then add <em>Z</em> to <em>X<sup>+</sup></em>
    </li>
    <li>Repeat step 2 until no new attributes can be added</li>
</ol>

<h2>3. Example</h2>
<p><strong>Relation:</strong></p>
<p>R(A, B, C, D, E)</p>

<p><strong>Functional Dependencies:</strong></p>
<ul>
    <li>A → B</li>
    <li>B → C</li>
    <li>A → D</li>
    <li>D → E</li>
</ul>

<h3>Compute A<sup>+</sup>:</h3>
<ul>
    <li>Start: A<sup>+</sup> = {A}</li>
    <li>A → B → add B → A<sup>+</sup> = {A, B}</li>
    <li>B → C → add C → A<sup>+</sup> = {A, B, C}</li>
    <li>A → D → add D → A<sup>+</sup> = {A, B, C, D}</li>
    <li>D → E → add E → A<sup>+</sup> = {A, B, C, D, E}</li>
</ul>

<p>No more FDs can add attributes → closure complete</p>

<p>✅ Conclusion: A<sup>+</sup> = {A, B, C, D, E} → A is a superkey.</p>

<h2>4. Textual Diagram</h2>
<pre>
Stepwise closure of A:

A+ = {A}
  |
  v  (A -> B)
A+ = {A, B}
  |
  v  (B -> C)
A+ = {A, B, C}
  |
  v  (A -> D)
A+ = {A, B, C, D}
  |
  v  (D -> E)
A+ = {A, B, C, D, E}  (closure complete)
</pre>

<h2>5. Quick Tips</h2>
<ul>
    <li>If X<sup>+</sup> = R, X is a superkey</li>
    <li>Start with the given attributes and keep applying all FDs until no new attributes appear</li>
    <li>Works the same way for checking whether a FD X → Y is implied: check if Y ⊆ X<sup>+</sup></li>
</ul>
<h1>1. What is 1NF?</h1>

<h3>Definition:</h3>
<p>A relation (table) is in First Normal Form (1NF) if it satisfies all three conditions:</p>
<ul>
    <li>Every column contains atomic (indivisible) values.</li>
    <li>There are no repeating groups or arrays.</li>
    <li>Each row is unique, usually enforced by a primary key.</li>
</ul>
<p>Basically, 1NF says: "Stop putting lists inside cells. One value per column, one row per record."</p>

<h3>2. Why 1NF?</h3>
<ul>
    <li>Makes data easier to query and manipulate.</li>
    <li>Prevents redundancy due to repeating groups.</li>
    <li>Prepares the table for higher normal forms (2NF, 3NF, etc.).</li>
</ul>

<h3>3. Example</h3>

<h4>Unnormalized Table (UNF)</h4>
<table>
    <tr><th>StudentID</th><th>StudentName</th><th>Courses</th></tr>
    <tr><td>101</td><td>Abhishek</td><td>Math, Physics</td></tr>
    <tr><td>102</td><td>Priya</td><td>Chemistry</td></tr>
    <tr><td>103</td><td>Rajesh</td><td>Math, Chemistry</td></tr>
</table>

<p><strong>Problems here:</strong></p>
<ul>
    <li>The Courses column has multiple values (not atomic).</li>
    <li>Hard to query "Which students take Physics?"</li>
</ul>

<h4>Convert to 1NF</h4>
<p>Step: Make each value atomic and remove repeating groups by creating multiple rows.</p>

<table>
    <tr><th>StudentID</th><th>StudentName</th><th>Course</th></tr>
    <tr><td>101</td><td>Abhishek</td><td>Math</td></tr>
    <tr><td>101</td><td>Abhishek</td><td>Physics</td></tr>
    <tr><td>102</td><td>Priya</td><td>Chemistry</td></tr>
    <tr><td>103</td><td>Rajesh</td><td>Math</td></tr>
    <tr><td>103</td><td>Rajesh</td><td>Chemistry</td></tr>
</table>

<ul>
    <li>✅ Now, each column has atomic values.</li>
    <li>✅ No repeating groups.</li>
    <li>✅ Each row is unique if we consider (StudentID, Course) as the primary key.</li>
</ul>

<h3>4. Textual Diagram</h3>
<p>Think of the table like a grid of atomic values:</p>

<pre>
+-----------+------------+---------+
| StudentID | StudentName| Course  |
+-----------+------------+---------+
| 101       | Abhishek   | Math    |
| 101       | Abhishek   | Physics |
| 102       | Priya      | Chemistry|
| 103       | Rajesh     | Math    |
| 103       | Rajesh     | Chemistry|
+-----------+------------+---------+
</pre>

<p>Notice how now every cell contains only one value and there are no lists. That’s the essence of 1NF.</p>
<h1>Second Normal Form (2NF) – Definition</h1>

<p>A relation is in 2NF if:</p>
<ul>
    <li>It is already in 1NF (all attributes are atomic, no repeating groups).</li>
    <li>Every non-prime attribute is fully functionally dependent on the whole of every candidate key.</li>
</ul>

<p><strong>“Fully functionally dependent”</strong> means no partial dependency on a part of a composite key. A non-prime attribute cannot depend on just a subset of a candidate key.</p>

<h2>Step-by-Step</h2>
<ol>
    <li>Identify candidate key(s).</li>
    <li>Check for partial dependencies: non-key attributes depending on part of a composite key.</li>
    <li>Remove partial dependencies by creating new relations.</li>
</ol>

<h2>Example</h2>

<p>Suppose we have a table:</p>
<table>
    <tr><th>StudentID</th><th>CourseID</th><th>StudentName</th><th>CourseName</th><th>Instructor</th></tr>
    <tr><td>101</td><td>C01</td><td>Alice</td><td>Math</td><td>Dr. Smith</td></tr>
    <tr><td>102</td><td>C01</td><td>Bob</td><td>Math</td><td>Dr. Smith</td></tr>
    <tr><td>101</td><td>C02</td><td>Alice</td><td>Physics</td><td>Dr. Jones</td></tr>
</table>

<p><strong>Candidate Key:</strong> (StudentID, CourseID) – since each student can take multiple courses, and each course can have multiple students.</p>

<h3>Step 1: Check for partial dependency</h3>
<ul>
    <li>StudentName depends only on StudentID → partial dependency</li>
    <li>CourseName and Instructor depend only on CourseID → partial dependency</li>
</ul>

<h3>Step 2: Remove partial dependencies</h3>

<h4>Student Table</h4>
<table>
    <tr><th>StudentID</th><th>StudentName</th></tr>
    <tr><td>101</td><td>Alice</td></tr>
    <tr><td>102</td><td>Bob</td></tr>
</table>

<h4>Course Table</h4>
<table>
    <tr><th>CourseID</th><th>CourseName</th><th>Instructor</th></tr>
    <tr><td>C01</td><td>Math</td><td>Dr. Smith</td></tr>
    <tr><td>C02</td><td>Physics</td><td>Dr. Jones</td></tr>
</table>

<h4>Enrollment Table (Relationship)</h4>
<table>
    <tr><th>StudentID</th><th>CourseID</th></tr>
    <tr><td>101</td><td>C01</td></tr>
    <tr><td>102</td><td>C01</td></tr>
    <tr><td>101</td><td>C02</td></tr>
</table>

<p>Now, all non-key attributes are fully dependent on the whole key in their respective tables. ✅</p>

<h2>Textual Diagram Representation</h2>

<h4>Original Table: StudentCourse</h4>
<table>
    <tr><th>StudentID</th><th>CourseID</th><th>StudentName</th><th>CourseName</th><th>Instructor</th></tr>
</table>

<h4>After 2NF:</h4>

<p><strong>Student Table:</strong></p>
<table>
    <tr><th>StudentID</th><th>StudentName</th></tr>
</table>

<p><strong>Course Table:</strong></p>
<table>
    <tr><th>CourseID</th><th>CourseName</th><th>Instructor</th></tr>
</table>

<p><strong>Enrollment Table:</strong></p>
<table>
    <tr><th>StudentID</th><th>CourseID</th></tr>
</table>

<h2>Key Points</h2>
<ul>
    <li>2NF only applies to tables with composite primary keys.</li>
    <li>If a table has a single attribute primary key, it’s automatically in 2NF once it’s in 1NF.</li>
    <li>Eliminates partial dependencies, reducing data redundancy and update anomalies.</li>
</ul>
<h1>1. Definition of 3NF</h1>
<p>A relation (table) is in <strong>3NF</strong> if:</p>
<ul>
    <li>It is already in 2NF (so no partial dependencies).</li>
    <li>No transitive dependency exists between non-prime attributes and the primary key.</li>
</ul>
<p>In simpler words: Every non-key attribute must depend only on the primary key, not on another non-key attribute.</p>

<h2>2. Key Concepts</h2>
<ul>
    <li><strong>Prime Attribute:</strong> Part of the candidate key.</li>
    <li><strong>Non-Prime Attribute:</strong> Not part of any candidate key.</li>
    <li><strong>Transitive Dependency:</strong> A → B → C, where C depends on B (non-key) instead of A (key).</li>
</ul>

<h2>3. Example</h2>
<p>Suppose we have a table storing student details:</p>
<table>
    <tr><th>StudentID</th><th>StudentName</th><th>DeptName</th><th>DeptHead</th></tr>
    <tr><td>101</td><td>Abhishek</td><td>CSE</td><td>Dr. Sharma</td></tr>
    <tr><td>102</td><td>Priya</td><td>ECE</td><td>Dr. Reddy</td></tr>
    <tr><td>103</td><td>Rahul</td><td>CSE</td><td>Dr. Sharma</td></tr>
</table>

<h3>Step 1: Identify keys</h3>
<p><strong>Primary Key:</strong> StudentID</p>

<h3>Step 2: Check for 1NF and 2NF</h3>
<ul>
    <li>Table is already in 1NF (atomic values).</li>
    <li>Table is in 2NF (no partial dependency as StudentID is a single-column key).</li>
</ul>

<h3>Step 3: Check for transitive dependency</h3>
<p>StudentID → DeptName → DeptHead</p>
<p>DeptHead depends on DeptName (non-key) → Transitive dependency exists.</p>

<h3>Step 4: Convert to 3NF</h3>
<p>Break table into two:</p>

<h4>Student Table</h4>
<table>
    <tr><th>StudentID</th><th>StudentName</th><th>DeptName</th></tr>
    <tr><td>101</td><td>Abhishek</td><td>CSE</td></tr>
    <tr><td>102</td><td>Priya</td><td>ECE</td></tr>
    <tr><td>103</td><td>Rahul</td><td>CSE</td></tr>
</table>

<h4>Department Table</h4>
<table>
    <tr><th>DeptName</th><th>DeptHead</th></tr>
    <tr><td>CSE</td><td>Dr. Sharma</td></tr>
    <tr><td>ECE</td><td>Dr. Reddy</td></tr>
</table>

<p>✅ Now, StudentID → StudentName, DeptName and DeptName → DeptHead. No non-key attribute depends on another non-key attribute in the same table. Both tables are in 3NF.</p>

<h2>4. Textual Diagram</h2>
<p>Original Table:</p>
<pre>
StudentID ----> StudentName
      \
       \--> DeptName ----> DeptHead
</pre>

<p>After 3NF decomposition:</p>

<h4>Student Table:</h4>
<pre>
StudentID ----> StudentName
          \
           \--> DeptName
</pre>

<h4>Department Table:</h4>
<pre>
DeptName ----> DeptHead
</pre>
<h1>1. BCNF (Boyce-Codd Normal Form)</h1>

<h3>Definition:</h3>
<p>A relation R is in BCNF if, for every non-trivial functional dependency <strong>X → Y</strong>:</p>
<ul>
    <li><strong>X</strong> is a superkey of the relation.</li>
    <li>Non-trivial FD: Y is not a subset of X.</li>
    <li>Superkey: A set of attributes that can uniquely identify a tuple in the relation.</li>
</ul>
<p>In simple words: Even in 3NF, sometimes a non-key attribute can determine part of a key, causing redundancy. BCNF removes that by making sure every determinant is a superkey.</p>

<h3>BCNF vs 3NF:</h3>
<p>3NF allows a functional dependency where the determinant is not a superkey if the dependent is part of a key. BCNF does not allow this. Every determinant must be a superkey. BCNF is stricter than 3NF.</p>

<h3>Example:</h3>
<p>Relation R(StudentID, Course, Instructor) with FDs:</p>
<ul>
    <li>StudentID, Course → Instructor</li>
    <li>Instructor → Course</li>
</ul>

<h4>Step 1: Candidate Keys</h4>
<p>Candidate key = (StudentID, Course)</p>

<h4>Step 2: Check BCNF</h4>
<ul>
    <li>FD1: (StudentID, Course) → Instructor ✅ determinant is superkey</li>
    <li>FD2: Instructor → Course ❌ determinant is not superkey → violates BCNF</li>
</ul>

<h4>Step 3: Decompose into BCNF</h4>
<ul>
    <li>R1(Instructor, Course)</li>
    <li>R2(StudentID, Instructor)</li>
</ul>

<h3>Textual Diagram:</h3>
<pre>
Original R(StudentID, Course, Instructor):
+-----------+--------+-----------+
| StudentID | Course | Instructor|
+-----------+--------+-----------+
| S1        | C1     | I1        |
| S2        | C2     | I2        |
| S1        | C2     | I2        |
+-----------+--------+-----------+

R1(Instructor, Course):
+-----------+--------+
| Instructor| Course |
+-----------+--------+
| I1        | C1     |
| I2        | C2     |
+-----------+--------+

R2(StudentID, Instructor):
+-----------+-----------+
| StudentID | Instructor|
+-----------+-----------+
| S1        | I1        |
| S2        | I2        |
| S1        | I2        |
+-----------+-----------+
</pre>

<h1>2. Fourth Normal Form (4NF)</h1>

<h3>Definition:</h3>
<p>A relation R is in 4NF if:</p>
<ul>
    <li>It is in BCNF</li>
    <li>It has no non-trivial multivalued dependencies (MVDs)</li>
</ul>
<p>Multivalued dependency (MVD): Denoted as <strong>X →→ Y</strong>, meaning "for each value of X, there is a set of values of Y independent of other attributes."</p>

<h3>Why 4NF is Needed:</h3>
<p>Tables with two independent multi-valued facts about the same entity can cause data redundancy. 4NF splits them to avoid this.</p>

<h3>Example:</h3>
<p>Initial Table: StudentActivities</p>
<table>
    <tr><th>StudentID</th><th>Hobby</th><th>Language</th></tr>
    <tr><td>101</td><td>Chess</td><td>English</td></tr>
    <tr><td>101</td><td>Chess</td><td>French</td></tr>
    <tr><td>101</td><td>Music</td><td>English</td></tr>
    <tr><td>101</td><td>Music</td><td>French</td></tr>
    <tr><td>102</td><td>Football</td><td>Spanish</td></tr>
    <tr><td>102</td><td>Football</td><td>English</td></tr>
</table>

<h3>MVDs:</h3>
<ul>
    <li>StudentID →→ Hobby</li>
    <li>StudentID →→ Language</li>
</ul>

<h3>4NF Decomposition:</h3>
<h4>Table 1: StudentHobbies</h4>
<table>
    <tr><th>StudentID</th><th>Hobby</th></tr>
    <tr><td>101</td><td>Chess</td></tr>
    <tr><td>101</td><td>Music</td></tr>
    <tr><td>102</td><td>Football</td></tr>
</table>

<h4>Table 2: StudentLanguages</h4>
<table>
    <tr><th>StudentID</th><th>Language</th></tr>
    <tr><td>101</td><td>English</td></tr>
    <tr><td>101</td><td>French</td></tr>
    <tr><td>102</td><td>Spanish</td></tr>
    <tr><td>102</td><td>English</td></tr>
</table>

<h1>3. Fifth Normal Form (5NF)</h1>

<h3>Definition:</h3>
<p>Also called Projection-Join Normal Form (PJ/NF). A relation R is in 5NF if every join dependency in R is implied by the candidate keys of R. Essentially, it cannot be decomposed further without losing information.</p>

<h3>When Needed:</h3>
<p>Occurs in many-to-many-to-many relationships, eliminating join dependency anomalies.</p>

<h3>Example:</h3>
<p>Employee-Project-Tool Table:</p>
<table>
    <tr><th>Employee</th><th>Project</th><th>Tool</th></tr>
    <tr><td>Alice</td><td>P1</td><td>Excel</td></tr>
    <tr><td>Alice</td><td>P1</td><td>PowerPoint</td></tr>
    <tr><td>Alice</td><td>P2</td><td>Excel</td></tr>
    <tr><td>Bob</td><td>P1</td><td>Excel</td></tr>
    <tr><td>Bob</td><td>P2</td><td>Word</td></tr>
</table>

<h3>Decompose into 5NF:</h3>
<h4>Employee–Project Table</h4>
<table>
    <tr><th>Employee</th><th>Project</th></tr>
    <tr><td>Alice</td><td>P1</td></tr>
    <tr><td>Alice</td><td>P2</td></tr>
    <tr><td>Bob</td><td>P1</td></tr>
    <tr><td>Bob</td><td>P2</td></tr>
</table>

<h4>Project–Tool Table</h4>
<table>
    <tr><th>Project</th><th>Tool</th></tr>
    <tr><td>P1</td><td>Excel</td></tr>
    <tr><td>P1</td><td>PowerPoint</td></tr>
    <tr><td>P2</td><td>Excel</td></tr>
    <tr><td>P2</td><td>Word</td></tr>
</table>

<h4>Employee–Tool Table</h4>
<table>
    <tr><th>Employee</th><th>Tool</th></tr>
    <tr><td>Alice</td><td>Excel</td></tr>
    <tr><td>Alice</td><td>PowerPoint</td></tr>
    <tr><td>Bob</td><td>Excel</td></tr>
    <tr><td>Bob</td><td>Word</td></tr>
</table>

<h3>Key Points:</h3>
<ul>
    <li>5NF eliminates redundancy caused by join dependencies.</li>
    <li>Tables in 5NF are fully normalized for complex relationships.</li>
    <li>Rarely required unless multiple multi-valued dependencies exist.</li>
</ul>

<h3>Textual Diagram of 5NF Decomposition:</h3>
<pre>
Original Table (Employee-Project-Tool)
         +--------------------------+
         | Employee | Project | Tool |
         +--------------------------+
                  |
                  | Decompose
                  v
+----------------+   +---------------+   +----------------+
| Employee-Project|   | Project-Tool |   | Employee-Tool |
+----------------+   +---------------+   +----------------+
| Employee | Project| | Project | Tool | | Employee | Tool|
+----------------+   +---------------+   +----------------+
</pre>
<h1>Lossless Decomposition</h1>

<h3>Definition:</h3>
<p>Lossless decomposition (or non-loss decomposition) is when you decompose a relation <strong>R</strong> into two or more relations <strong>R1, R2, ..., Rn</strong> such that no information is lost.</p>
<p>Formally: If you decompose R into R1 and R2, the decomposition is lossless if:</p>
<pre>R = R1 ⨝ R2</pre>
<p>Where <strong>⨝</strong> is the natural join. After joining the decomposed tables, you get exactly the original table. Otherwise, it is a lossy decomposition.</p>

<h3>Condition for Lossless Decomposition:</h3>
<p>For a relation <strong>R</strong> with functional dependencies <strong>F</strong>, decompose R into R1 and R2:</p>
<ul>
    <li>Let <strong>R1 ∩ R2 = X</strong> (common attributes)</li>
    <li>Lossless decomposition occurs if: <strong>X → R1</strong> or <strong>X → R2</strong></li>
</ul>
<p>This means the common attributes functionally determine all attributes in at least one of the decomposed relations.</p>

<h3>Example:</h3>
<p>Relation: STUDENT</p>
<table>
    <tr><th>StudentID</th><th>Name</th><th>Dept</th><th>HOD</th></tr>
    <tr><td>101</td><td>Abhi</td><td>CSE</td><td>Dr. Rao</td></tr>
    <tr><td>102</td><td>Priya</td><td>ECE</td><td>Dr. Roy</td></tr>
    <tr><td>103</td><td>Rohan</td><td>CSE</td><td>Dr. Rao</td></tr>
</table>

<p>Functional dependencies:</p>
<ul>
    <li>StudentID → Name, Dept</li>
    <li>Dept → HOD</li>
</ul>

<h4>Decompose STUDENT into two relations:</h4>
<ul>
    <li>R1 = (StudentID, Name, Dept)</li>
    <li>R2 = (Dept, HOD)</li>
</ul>

<h4>Check lossless condition:</h4>
<p>R1 ∩ R2 = Dept</p>
<p>Dept → HOD → common attribute determines all attributes of R2 ✅</p>
<p>Thus, decomposition is lossless.</p>

<h3>Decomposed Relations:</h3>

<h4>R1: (StudentID, Name, Dept)</h4>
<table>
    <tr><th>StudentID</th><th>Name</th><th>Dept</th></tr>
    <tr><td>101</td><td>Abhi</td><td>CSE</td></tr>
    <tr><td>102</td><td>Priya</td><td>ECE</td></tr>
    <tr><td>103</td><td>Rohan</td><td>CSE</td></tr>
</table>

<h4>R2: (Dept, HOD)</h4>
<table>
    <tr><th>Dept</th><th>HOD</th></tr>
    <tr><td>CSE</td><td>Dr. Rao</td></tr>
    <tr><td>ECE</td><td>Dr. Roy</td></tr>
</table>

<h4>Natural Join (R1 ⨝ R2) restores original STUDENT table ✅</h4>

<h3>Key Points:</h3>
<ul>
    <li>Lossless decomposition ensures no spurious tuples after join.</li>
    <li>Mainly used in normalization (3NF, BCNF) to avoid redundancy.</li>
    <li>Always check common attribute → one relation rule for lossless property.</li>
</ul>
<h1>1. What is Dependency Preservation?</h1>

<p>When you decompose a relation (usually to achieve a higher normal form like 3NF or BCNF), you want two things:</p>
<ul>
    <li><strong>Lossless decomposition:</strong> No data is lost.</li>
    <li><strong>Dependency preservation:</strong> All functional dependencies (FDs) of the original relation can still be enforced without joining decomposed relations.</li>
</ul>

<p>Dependency preservation ensures that enforcing constraints (like A → B) doesn’t require you to recombine tables constantly. If this property is violated, maintaining consistency becomes costly.</p>

<h3>Formal Definition:</h3>
<p>Suppose we decompose a relation R into R1, R2, …, Rn. Let F be the set of FDs on R.</p>
<p>The decomposition is dependency-preserving if:</p>
<pre>
(F1 ∪ F2 ∪ … ∪ Fn)+ = F+
</pre>
<p>where Fi are the FDs in Ri (projected FDs).</p>

<h1>2. Example</h1>

<h3>Step 1: Original Relation</h3>
<p>Let’s take a relation:</p>
<pre>
R(StudentID, CourseID, Instructor)
</pre>

<p>Functional dependencies:</p>
<ul>
    <li>StudentID, CourseID → Instructor (Each student-course pair has one instructor)</li>
    <li>Instructor → CourseID (Each instructor teaches only one course)</li>
</ul>

<h3>Step 2: Check for 2NF/3NF Violations</h3>
<p>Suppose we want to decompose to remove partial and transitive dependencies:</p>
<ul>
    <li>Candidate key: (StudentID, CourseID)</li>
    <li>Issue: Instructor → CourseID is a transitive dependency (StudentID, CourseID → Instructor → CourseID)</li>
</ul>

<h3>Step 3: Decompose into 2 Relations</h3>
<ul>
    <li>R1(Instructor, CourseID) → handles Instructor → CourseID</li>
    <li>R2(StudentID, CourseID, Instructor) → handles StudentID, CourseID → Instructor</li>
</ul>

<h3>Step 4: Check Dependency Preservation</h3>
<ul>
    <li>FDs on R1: Instructor → CourseID</li>
    <li>FDs on R2: StudentID, CourseID → Instructor</li>
</ul>

<p>Can we enforce all original FDs without joining?</p>
<ul>
    <li>Original FD: Instructor → CourseID → preserved in R1 ✅</li>
    <li>Original FD: StudentID, CourseID → Instructor → preserved in R2 ✅</li>
</ul>

<p>All FDs are preserved. So this decomposition is dependency-preserving.</p>

<h3>Step 5: Textual Diagram</h3>

<p><strong>Original Relation R:</strong></p>
<table>
    <tr><th>StudentID</th><th>CourseID</th><th>Instructor</th></tr>
    <tr><td>S1</td><td>C1</td><td>I1</td></tr>
    <tr><td>S2</td><td>C1</td><td>I1</td></tr>
    <tr><td>S3</td><td>C2</td><td>I2</td></tr>
</table>

<p><strong>Decomposed Relations:</strong></p>

<p>R1(Instructor, CourseID)</p>
<table>
    <tr><th>Instructor</th><th>CourseID</th></tr>
    <tr><td>I1</td><td>C1</td></tr>
    <tr><td>I2</td><td>C2</td></tr>
</table>

<p>R2(StudentID, CourseID, Instructor)</p>
<table>
    <tr><th>StudentID</th><th>CourseID</th><th>Instructor</th></tr>
    <tr><td>S1</td><td>C1</td><td>I1</td></tr>
    <tr><td>S2</td><td>C1</td><td>I1</td></tr>
    <tr><td>S3</td><td>C2</td><td>I2</td></tr>
</table>

<h3>Key Point</h3>
<ul>
    <li><strong>Dependency-preserving:</strong> You can enforce all original FDs locally in decomposed tables.</li>
    <li><strong>Not dependency-preserving:</strong> Some FDs would require a join of tables to check.</li>
</ul>

<h3>Example of Non-Preserving FD:</h3>
<p>Original relation: R(A, B, C)</p>
<ul>
    <li>FDs: A → B, B → C</li>
    <li>Decomposition: R1(A, B), R2(A, C)</li>
    <li>FD B → C is lost unless you join R1 and R2 → not dependency-preserving.</li>
</ul>
<h1>1. What is a Transaction?</h1>
<p>A transaction is a unit of work in a database that must be completed entirely or not at all.</p>

<h2>ACID Properties of Transactions</h2>
<p>A transaction is a unit of work in a database. To ensure correctness and reliability, every transaction must satisfy ACID:</p>
<ul>
    <li>Atomicity</li>
    <li>Consistency</li>
    <li>Isolation</li>
    <li>Durability</li>
</ul>

<h2>1. Atomicity</h2>
<p><strong>Definition:</strong> A transaction is atomic, meaning it is all or nothing. If any part fails, the entire transaction is rolled back.</p>

<p><strong>Example:</strong> Transfer $100 from Account A to Account B:</p>
<ul>
    <li>Read balance of A</li>
    <li>Subtract $100</li>
    <li>Write balance of A</li>
    <li>Read balance of B</li>
    <li>Add $100</li>
    <li>Write balance of B</li>
</ul>

<p>If step 5 fails (maybe server crash), rollback ensures A’s balance is restored.</p>

<h3>Textual Diagram:</h3>
<pre>
Transaction T1: Transfer $100
-----------------------------------
Step 1: Read A_balance -> 500
Step 2: A_balance = A_balance - 100 -> 400
Step 3: Write A_balance -> 400
Step 4: Read B_balance -> 300
Step 5: B_balance = B_balance + 100 -> 400
Step 6: Write B_balance -> 400
COMMIT

If crash happens at Step 5:

ROLLBACK
A_balance restored to 500
B_balance remains 300
</pre>

<h3>SQL Pseudo-Code:</h3>
<pre>
BEGIN TRANSACTION;

UPDATE accounts SET balance = balance - 100 WHERE acc_id = 1;
UPDATE accounts SET balance = balance + 100 WHERE acc_id = 2;

-- If everything OK
COMMIT;

-- If error occurs
ROLLBACK;
</pre>

<h2>2. Consistency</h2>
<p><strong>Definition:</strong> A transaction moves the database from one consistent state to another, preserving all constraints.</p>

<p><strong>Example:</strong> Total money in accounts should remain the same.</p>
<ul>
    <li>Before transaction: A=500, B=300, Total=800</li>
    <li>After transaction: A=400, B=400, Total=800 ✅</li>
</ul>

<p>Constraints like primary key, foreign key, balance &gt;=0 must remain valid.</p>

<h3>Diagram:</h3>
<pre>
Before T1:  A_balance + B_balance = 800
Transaction: Transfer 100
After T1:   A_balance + B_balance = 800 ✅
</pre>

<h3>SQL Example with CHECK Constraint:</h3>
<pre>
ALTER TABLE accounts
ADD CONSTRAINT check_balance CHECK (balance >= 0);

BEGIN TRANSACTION;
UPDATE accounts SET balance = balance - 100 WHERE acc_id = 1;
-- If balance goes negative, DB throws error → transaction fails
UPDATE accounts SET balance = balance + 100 WHERE acc_id = 2;
COMMIT;
</pre>

<h2>3. Isolation</h2>
<p><strong>Definition:</strong> Concurrent transactions do not interfere with each other. Intermediate results of a transaction are invisible to other transactions until commit.</p>

<p><strong>Example:</strong> Two transactions:</p>
<ul>
    <li>T1: Transfer $100 from A → B</li>
    <li>T2: Add 10% interest to B</li>
</ul>

<p>Without isolation:</p>
<pre>
T1: Read B -> 300
T2: Read B -> 300
T1: B = 300 + 100 -> 400
T2: B = 300*1.1 -> 330
T1: Write B -> 400
T2: Write B -> 330   <-- Lost update, wrong final balance
</pre>

<p>With isolation:</p>
<ul>
    <li>T2 waits until T1 commits</li>
    <li>Final B_balance = 400*1.1 = 440 ✅</li>
</ul>

<h3>Textual Diagram:</h3>
<pre>
Time ->

T1: Read A, Read B, Update A, Update B, COMMIT
T2: Wait
T1 commits
T2: Read B, Apply interest, COMMIT
</pre>

<h3>SQL Pseudo-Code (with lock):</h3>
<pre>
-- Transaction T1
BEGIN TRANSACTION;
SELECT balance FROM accounts WHERE acc_id = 2 FOR UPDATE;
UPDATE accounts SET balance = balance + 100 WHERE acc_id = 2;
COMMIT;
</pre>

<h2>4. Durability</h2>
<p><strong>Definition:</strong> Once a transaction commits, its changes are permanent, even if the system crashes immediately afterward.</p>

<p><strong>Example:</strong></p>
<ul>
    <li>T1 commits, B_balance updated to 400</li>
    <li>Crash occurs → after recovery, B_balance = 400 ✅</li>
</ul>

<p><strong>Implementation:</strong> Changes are written to disk or log files before commit (Write-Ahead Logging).</p>

<h3>Diagram:</h3>
<pre>
Transaction T1: Transfer $100
-----------------------------------
Step 1-5: In-memory updates
Step 6: Write to disk/log
COMMIT -> Changes durable

System crash -> restart
B_balance = 400
</pre>

<h3>SQL Pseudo-Code:</h3>
<pre>
BEGIN TRANSACTION;
UPDATE accounts SET balance = balance - 100 WHERE acc_id = 1;
UPDATE accounts SET balance = balance + 100 WHERE acc_id = 2;
COMMIT; -- Changes now durable on disk
</pre>

<h2>5. Summary Table</h2>
<table>
    <tr>
        <th>Property</th>
        <th>Meaning</th>
        <th>Example</th>
    </tr>
    <tr>
        <td>Atomicity</td>
        <td>All or nothing</td>
        <td>Transfer money, rollback if fail</td>
    </tr>
    <tr>
        <td>Consistency</td>
        <td>Preserves constraints</td>
        <td>Total balance before=after transaction</td>
    </tr>
    <tr>
        <td>Isolation</td>
        <td>Transactions don’t interfere</td>
        <td>Two transactions on B don’t conflict</td>
    </tr>
    <tr>
        <td>Durability</td>
        <td>Changes persist after commit/crash</td>
        <td>B_balance remains after crash</td>
    </tr>
</table>

<h1>Types of Schedule</h1>

<h2>1. Serial Schedule</h2>

<h3>Definition:</h3>
<p>A serial schedule is a schedule in which transactions are executed one after another, without interleaving.</p>
<ul>
    <li>No two transactions overlap.</li>
    <li>Always conflict-free.</li>
    <li>Always produces a correct result.</li>
</ul>
<p><strong>Key Point:</strong> Serial schedules are simple but may be less efficient than interleaved schedules because transactions wait for each other.</p>

<h3>Why Serial Schedules?</h3>
<ul>
    <li>Ensures consistency.</li>
    <li>Avoids conflicts such as lost updates, dirty reads, unrepeatable reads.</li>
</ul>
<p>Think of it as “queue discipline” for transactions. One goes, next waits.</p>

<h3>Example Scenario:</h3>
<p>Banking database table <strong>accounts</strong>:</p>
<table>
<tr><th>acc_id</th><th>balance</th></tr>
<tr><td>1</td><td>5000</td></tr>
<tr><td>2</td><td>3000</td></tr>
</table>

<h4>Transactions:</h4>
<p><strong>T1:</strong> Transfer $100 from A → B</p>
<pre>
T1 Operations:
Read(A)
A = A - 100
Write(A)
Read(B)
B = B + 100
Write(B)
</pre>

<p><strong>T2:</strong> Apply 10% interest on B</p>
<pre>
T2 Operations:
Read(B)
B = B * 1.1
Write(B)
</pre>

<h3>Serial Schedule Examples:</h3>

<p><strong>Serial Schedule 1:</strong> Execute T1 completely, then T2</p>
<pre>
T1: Read(A)
T1: A = A - 100
T1: Write(A)
T1: Read(B)
T1: B = B + 100
T1: Write(B)
T2: Read(B)
T2: B = B * 1.1
T2: Write(B)
</pre>

<p><strong>Serial Schedule 2:</strong> Execute T2 completely, then T1</p>
<pre>
T2: Read(B)
T2: B = B * 1.1
T2: Write(B)
T1: Read(A)
T1: A = A - 100
T1: Write(A)
T1: Read(B)
T1: B = B + 100
T1: Write(B)
</pre>

<h3>Textual Diagram:</h3>
<pre>
Time →
----------------------------------------------------
T1 | Read(A) | A=A-100 | Write(A) | Read(B) | B=B+100 | Write(B)
T2 |                               Read(B) | B=B*1.1 | Write(B)
----------------------------------------------------
</pre>

<h3>SQL Code Example:</h3>

<p><strong>T1: Transfer $100 from A→B</strong></p>
<pre>
BEGIN TRANSACTION;

UPDATE accounts
SET balance = balance - 100
WHERE acc_id = 1;

UPDATE accounts
SET balance = balance + 100
WHERE acc_id = 2;

COMMIT;
</pre>

<p><strong>T2: Apply 10% interest on B</strong></p>
<pre>
BEGIN TRANSACTION;

UPDATE accounts
SET balance = balance * 1.1
WHERE acc_id = 2;

COMMIT;
</pre>

<p>Serial Execution in SQL:</p>
<pre>
-- Execute T1 first
-- Execute T2 after T1 finishes
</pre>

<h3>Advantages:</h3>
<ul>
    <li>Simple and safe.</li>
    <li>Ensures data consistency.</li>
    <li>No need for complex concurrency control.</li>
</ul>

<h3>Disadvantages:</h3>
<ul>
    <li>Poor performance under high load.</li>
    <li>Transactions wait unnecessarily.</li>
</ul>

<hr>

<h2>2. Concurrent (Interleaved) Schedule</h2>

<h3>Definition:</h3>
<p>A concurrent schedule is when two or more transactions execute at the same time, and their operations are interleaved.</p>

<h3>Why bother?</h3>
<ul>
    <li>Improves system throughput and resource utilization.</li>
    <li>Problem: Can lead to conflicts if two transactions access the same data item and at least one is a write.</li>
</ul>

<h3>Types of Conflicts in Concurrent Execution:</h3>
<table>
<tr><th>Conflict Type</th><th>Example</th><th>Issue</th></tr>
<tr><td>Read-Write (RW)</td><td>T1 reads A, T2 writes A</td><td>Lost update, inconsistent reads</td></tr>
<tr><td>Write-Read (WR)</td><td>T1 writes A, T2 reads A</td><td>Dirty read</td></tr>
<tr><td>Write-Write (WW)</td><td>T1 writes A, T2 writes A</td><td>Lost update</td></tr>
</table>

<h3>Example Transactions:</h3>
<p>Table: accounts(acc_id, balance)</p>

<p><strong>T1: Transfer $100 from A to B</strong></p>
<pre>
BEGIN TRANSACTION;

-- Deduct from A
UPDATE accounts SET balance = balance - 100 WHERE acc_id = 1;

-- Add to B
UPDATE accounts SET balance = balance + 100 WHERE acc_id = 2;

COMMIT;
</pre>

<p><strong>T2: Apply 10% interest to B</strong></p>
<pre>
BEGIN TRANSACTION;

UPDATE accounts SET balance = balance * 1.1 WHERE acc_id = 2;

COMMIT;
</pre>

<h3>Interleaved (Concurrent) Schedule Example:</h3>
<pre>
Step  Operation       Transaction
1     Read(A)         T1
2     Read(B)         T2
3     Write(A)        T1
4     B = B*1.1       T2
5     Write(B)        T2
6     Read(B)         T1
7     B = B + 100     T1
8     Write(B)        T1
</pre>
<p>Problem: The final balance of B will not be correct because T1 read B before T2 wrote the interest.</p>

<h3>Textual Diagram of Concurrent Schedule:</h3>
<pre>
Time →
Transaction T1:  | Read(A) |          | Write(A) |                | Read(B) | B=B+100 | Write(B) |
Transaction T2:           | Read(B) | B=B*1.1 | Write(B) |                        
</pre>
<p>Conflicts exist on B: T1 reads B before T2 writes → dirty read.</p>

<h3>Concurrent Schedule with Locking (Pseudo-Code):</h3>
<pre>
// Transaction T1
lock(A);
A = A - 100;
unlock(A);

lock(B);
B_old = B;           // T1 wants to read B
unlock(B);

// Transaction T2
lock(B);
B = B * 1.1;         // Apply interest
unlock(B);

// Transaction T1 continues
lock(B);
B = B_old + 100;     // Add transferred amount
unlock(B);
</pre>
<p>Effect: Locks serialize the access to B and prevent dirty reads and lost updates.</p>

<h3>Notes on Concurrent Schedules:</h3>
<ul>
    <li><strong>Serializability:</strong> Even if transactions interleave, the schedule is correct if it is conflict serializable (equivalent to some serial schedule).</li>
    <li><strong>DBMS Mechanisms:</strong> Two-Phase Locking (2PL), Timestamp ordering, Optimistic concurrency control.</li>
    <li><strong>Advantages:</strong> Higher throughput, better CPU and I/O utilization.</li>
    <li><strong>Disadvantages:</strong> Needs careful concurrency control, deadlocks are possible.</li>
</ul>
<h1>1. What is a Conflict in a Schedule?</h1>

<p>A conflict happens when two operations from different transactions access the same data item and at least one is a write.</p>
<p>Simply: If two transactions touch the same data and one writes, their order matters.</p>

<h3>Operations involved:</h3>
<ul>
    <li>R(X) → Read data item X</li>
    <li>W(X) → Write data item X</li>
</ul>

<h2>2. Types of Conflicts</h2>
<table>
    <tr>
        <th>Conflict Type</th>
        <th>Scenario Example</th>
        <th>Explanation</th>
    </tr>
    <tr>
        <td>Read-Write (RW)</td>
        <td>T1: R(A), T2: W(A)</td>
        <td>T2 writes A after T1 reads it → T1 sees old value.</td>
    </tr>
    <tr>
        <td>Write-Read (WR)</td>
        <td>T1: W(A), T2: R(A)</td>
        <td>T2 reads A after T1 writes → sees new value.</td>
    </tr>
    <tr>
        <td>Write-Write (WW)</td>
        <td>T1: W(A), T2: W(A)</td>
        <td>Both write to A → final value depends on order.</td>
    </tr>
</table>

<p><strong>No conflict:</strong> Two reads (R-R) on same data are fine; order doesn’t matter.</p>

<h2>3. Example Scenario</h2>
<p>Suppose we have two transactions:</p>
<pre>
T1: R(A) → A = A + 50 → W(A)
T2: R(A) → A = A * 2 → W(A)
</pre>

<h3>Step-by-Step Analysis:</h3>
<ul>
    <li>T1 reads A</li>
    <li>T2 reads A</li>
    <li>T1 writes A → Conflict? Yes, T1 W(A) vs T2 R(A) → WR conflict</li>
    <li>T2 writes A → Conflict? Yes, T1 W(A) vs T2 W(A) → WW conflict</li>
</ul>

<p>Conclusion: This schedule has conflicts and may not produce the same result as a serial execution unless carefully ordered.</p>

<h2>4. Textual Diagram of Conflicts</h2>
<pre>
Time → 
T1: R(A)
T2: R(A)
T1: A = A + 50
T1: W(A)   <-- WR conflict with T2
T2: A = A * 2
T2: W(A)   <-- WW conflict with T1
</pre>

<h3>Conflict Graph (Precedence Graph)</h3>
<ul>
    <li>Nodes: T1, T2</li>
    <li>Edges: T1 → T2  (T1 W(A) before T2 R/W(A))</li>
</ul>
<p>Cycle? No → serializable. If there was a cycle, schedule would not be conflict-serializable.</p>

<h2>5. Example with SQL Transactions</h2>

<p>Assume an accounts table:</p>
<pre>
CREATE TABLE accounts (
    acc_id INT PRIMARY KEY,
    balance INT
);
</pre>

<h3>Transactions with Conflicts</h3>

<p><strong>Transaction 1 (T1): Add 50 to Account A</strong></p>
<pre>
BEGIN TRANSACTION;
SELECT balance FROM accounts WHERE acc_id = 1; -- R(A)
UPDATE accounts SET balance = balance + 50 WHERE acc_id = 1; -- W(A)
COMMIT;
</pre>

<p><strong>Transaction 2 (T2): Double Account A</strong></p>
<pre>
BEGIN TRANSACTION;
SELECT balance FROM accounts WHERE acc_id = 1; -- R(A)
UPDATE accounts SET balance = balance * 2 WHERE acc_id = 1; -- W(A)
COMMIT;
</pre>

<h3>Interleaved Schedule (Conflict Example)</h3>
<pre>
T1: SELECT balance FROM accounts WHERE acc_id=1;  -- R(A)
T2: SELECT balance FROM accounts WHERE acc_id=1;  -- R(A)
T1: UPDATE accounts SET balance = balance + 50 WHERE acc_id=1;  -- W(A)  <-- WR conflict
T2: UPDATE accounts SET balance = balance * 2 WHERE acc_id=1;  -- W(A)  <-- WW conflict
</pre>

<p>Without proper locking or isolation, T2 may overwrite T1’s update → lost update problem.</p>

<h2>6. Conflict Resolution in Pseudo-Code</h2>
<p>Use locks to prevent conflicts:</p>
<pre>
// Pseudo-code for locking
lock(A);           // T1 locks A
T1: A = A + 50;
unlock(A);         // release lock

lock(A);           // T2 locks A
T2: A = A * 2;
unlock(A);
</pre>

<p>Locks ensure serializability. Prevents lost updates, dirty reads, unrepeatable reads.</p>
<h1>1. What is Serializability?</h1>
<p>Serializability is the correctness criterion for concurrent schedules in DBMS.</p>
<p>A schedule (sequence of operations from multiple transactions) is <strong>serializable</strong> if it is equivalent to some <strong>serial schedule</strong>.</p>
<p><strong>Serial schedule:</strong> Transactions execute one after another, no interleaving.</p>
<p><strong>Why it matters:</strong> Concurrent execution improves performance, but we must ensure the final database state is the same as some serial execution to avoid inconsistencies.</p>

<h2>2. Types of Serializability</h2>

<h3>1. Conflict Serializability</h3>
<p>A schedule is <strong>conflict serializable</strong> if it can be transformed into a serial schedule by swapping non-conflicting operations.</p>
<p><strong>Conflict:</strong> Two operations cannot be swapped if:</p>
<ul>
    <li>They belong to different transactions</li>
    <li>They access the same data item</li>
    <li>At least one operation is a write</li>
</ul>
<p><strong>Conflicting operation pairs:</strong> Read-Write (RW), Write-Read (WR), Write-Write (WW)</p>
<p>Non-conflicting operations can be swapped without changing the outcome.</p>

<h3>Example</h3>
<p>Transactions:</p>
<pre>
T1: R(A), W(A)
T2: R(A), W(A)
</pre>
<p>Schedule S (Interleaved):</p>
<pre>
S: R1(A), R2(A), W1(A), W2(A)
</pre>

<h4>Step 1: Identify Conflicts</h4>
<table>
    <tr>
        <th>Operation Pair</th>
        <th>Conflict?</th>
        <th>Type</th>
    </tr>
    <tr>
        <td>R1(A) R2(A)</td>
        <td>No</td>
        <td>-</td>
    </tr>
    <tr>
        <td>R1(A) W2(A)</td>
        <td>Yes</td>
        <td>RW</td>
    </tr>
    <tr>
        <td>W1(A) R2(A)</td>
        <td>Yes</td>
        <td>WR</td>
    </tr>
    <tr>
        <td>W1(A) W2(A)</td>
        <td>Yes</td>
        <td>WW</td>
    </tr>
</table>

<h4>Step 2: Build Precedence Graph</h4>
<p><strong>Rules:</strong></p>
<ul>
    <li>Nodes = Transactions (T1, T2)</li>
    <li>Edge T1 → T2 if T1’s operation conflicts and comes before T2’s operation</li>
</ul>
<p>From schedule S:</p>
<pre>
R1(A) before W2(A) → Edge T1 → T2
W1(A) before R2(A) → Edge T1 → T2
W1(A) before W2(A) → Edge T1 → T2
</pre>
<p>Textual Diagram:</p>
<pre>
T1 ---> T2
</pre>
<p>No cycles → Schedule S is conflict serializable. Equivalent serial schedule: T1 → T2</p>

<h4>Non-Serializable Example</h4>
<pre>
Schedule S2: R1(A), W2(A), R2(A), W1(A)
</pre>
<p>Conflicts:</p>
<pre>
W2(A) after R1(A) → Edge T1 → T2
W1(A) after W2(A) → Edge T2 → T1
</pre>
<p>Precedence Graph:</p>
<pre>
T1 ---> T2
T2 ---> T1
</pre>
<p>Cycle exists → Not conflict serializable.</p>

<h3>3. Visual Textual Diagram of Serializable Schedule</h3>
<pre>
Schedule:
Time -->
T1: R(A) --------- W(A)
T2:        R(A) --------- W(A)

Conflicts → T1 → T2
</pre>

<h3>4. Summary</h3>
<ul>
    <li>Conflict serializability ensures concurrent execution correctness.</li>
    <li>Build precedence graph to check: No cycles → conflict serializable, Cycle exists → not conflict serializable.</li>
    <li>Conflicting operations are RW, WR, WW on the same data item.</li>
</ul>

<h3>1. View Serializability</h3>
<p>A schedule is <strong>view serializable</strong> if it is view equivalent to a serial schedule.</p>
<p><strong>View Equivalence Rules:</strong></p>
<ol>
    <li>Same Initial Reads (Read-From): If transaction T reads X in S, it must read the same initial value or the last written value of X in the serial schedule.</li>
    <li>Same Updates (Write): The final write on X must be done by the same transaction in both schedules.</li>
    <li>Preserve Read-From Relationships: If T reads X written by T’, the relationship must remain in the serial schedule.</li>
</ol>
<p>Key point: Every conflict-serializable schedule is view serializable, but not every view-serializable schedule is conflict-serializable.</p>

<h3>2. Example of View Serializability</h3>
<p>Transactions:</p>
<pre>
T1: R(A), W(A)
T2: R(A), W(A)
</pre>
<p>Interleaved Schedule S:</p>
<pre>
S: R1(A), R2(A), W1(A), W2(A)
</pre>

<h4>Step 1: Check conflicts (for conflict serializability)</h4>
<p>Conflict Graph:</p>
<pre>
R1(A) vs R2(A) → no conflict
R1(A) vs W2(A) → RW conflict → T1 → T2
W1(A) vs W2(A) → WW conflict → T1 → T2
Conflict Graph: T1 ---> T2
</pre>

<p>Non-Conflict Serializable Example:</p>
<pre>
S: R1(A), R2(A), W2(A), W1(A)
Conflicts:
R1(A) vs W2(A) → T1 → T2
W2(A) vs W1(A) → T2 → T1
Conflict Graph has a cycle → Not conflict serializable
</pre>

<h4>Step 2: Check View Equivalence</h4>
<ul>
    <li>Initial reads: T1 reads initial A, T2 reads initial A</li>
    <li>Read-from relationship preserved</li>
    <li>Final Writes: Last write on A is W1(A) in both schedules</li>
</ul>
<p>✅ All three conditions satisfied → Schedule is view serializable. Equivalent serial schedule: T2 → T1</p>

<h3>3. Textual Diagram</h3>
<pre>
Schedule S:
Time -->
T1: R(A) -------------         W(A)
T2:       R(A) ----- W(A)

Final write: T1
T2 reads initial value
View equivalent serial schedule: T2 → T1
</pre>

<h3>4. Key Difference from Conflict Serializability</h3>
<table>
    <tr>
        <th>Aspect</th>
        <th>Conflict Serializability</th>
        <th>View Serializability</th>
    </tr>
    <tr>
        <td>How checked</td>
        <td>Conflicting operations</td>
        <td>Read-from & final writes</td>
    </tr>
    <tr>
        <td>Graph cycles</td>
        <td>No cycles allowed</td>
        <td>Cycles allowed if view correct</td>
    </tr>
    <tr>
        <td>Subset relation</td>
        <td>All conflict-serializable schedules are view-serializable</td>
        <td>Some schedules view-serializable but not conflict-serializable</td>
    </tr>
</table>


<h1>1. What is a Precedence Graph?</h1>
<p>A Precedence Graph (or Serializability Graph) is a directed graph used to check if a schedule of transactions is conflict-serializable.</p>
<ul>
    <li><strong>Nodes</strong> = Transactions (T1, T2, …)</li>
    <li><strong>Edges</strong> = Conflicting operations where one transaction must precede another</li>
</ul>
<p>If the graph has no cycles → schedule is conflict-serializable.<br>
If there’s a cycle → schedule is not serializable.</p>

<h2>2. Why Use It?</h2>
<ul>
    <li>Detect conflicts between transactions</li>
    <li>Ensure database consistency when multiple transactions execute concurrently</li>
    <li>Avoid anomalies like:
        <ul>
            <li>Lost update</li>
            <li>Dirty read</li>
            <li>Uncommitted data problem</li>
        </ul>
    </li>
</ul>

<h2>3. Steps to Construct a Precedence Graph</h2>
<ol>
    <li>Identify all transactions in the schedule</li>
    <li>List all operations of each transaction (Read/Write)</li>
    <li>For every pair of operations on the same data item:
        <ul>
            <li>If at least one is a write → conflict</li>
            <li>Draw a directed edge from the earlier transaction to the later transaction</li>
        </ul>
    </li>
    <li>Check for cycles:
        <ul>
            <li>No cycle → serializable</li>
            <li>Cycle → not serializable</li>
        </ul>
    </li>
</ol>

<h2>4. Example Schedule</h2>
<p><strong>Transactions:</strong></p>
<pre>
T1: R(A)  W(A)
T2: R(A)  W(A)
T3: R(B)  W(B)
</pre>

<p><strong>Schedule (interleaved):</strong></p>
<pre>
S: R1(A), R2(A), W1(A), W2(A), R3(B), W3(B)
</pre>

<h3>Step 1: Identify conflicts</h3>
<ul>
    <li>R1(A) vs R2(A) → no conflict (read-read)</li>
    <li>R1(A) vs W2(A) → conflict → edge T1 → T2</li>
    <li>W1(A) vs R2(A) → conflict → edge T1 → T2</li>
    <li>W1(A) vs W2(A) → conflict → edge T1 → T2</li>
</ul>
<p>T3 is independent (B is separate) → no edges</p>

<h3>Step 2: Draw textual diagram</h3>
<pre>
Transactions: T1, T2, T3
Edges: 
T1 ---> T2

Precedence Graph:

T1 --> T2
T3 (no edges)
</pre>
<p>No cycles → schedule is conflict-serializable.</p>

<h2>5. Example: Non-Serializable Schedule</h2>
<pre>
Schedule:

T1: R(A) W(A)
T2: R(A) W(A)
S: R1(A), R2(A), W2(A), W1(A)
</pre>

<h3>Conflicts:</h3>
<ul>
    <li>R1(A) vs W2(A) → T1 → T2</li>
    <li>W1(A) vs W2(A) → T2 → T1</li>
</ul>

<h3>Graph:</h3>
<pre>
T1 --> T2
T2 --> T1
</pre>
<p>Cycle exists → NOT serializable</p>

<h2>6. Algorithm to Construct Precedence Graph (Pseudo-Code)</h2>
<pre><code>
// Input: List of operations in schedule
// Operation = {TransactionID, Type, DataItem}
struct Operation {
    int TID;     // Transaction ID
    char type;   // 'R' or 'W'
    char data;   // Data item
};

struct Operation schedule[MAX];
int n; // number of operations

// Initialize adjacency matrix
int graph[MAX_T][MAX_T] = {0};

for(i=0; i&lt;n; i++){
    for(j=i+1; j&lt;n; j++){
        if(schedule[i].data == schedule[j].data &amp;&amp; 
           (schedule[i].type=='W' || schedule[j].type=='W') &
           &amp;&amp; schedule[i].TID != schedule[j].TID){
            // conflict, add edge from i's TID to j's TID
            graph[schedule[i].TID][schedule[j].TID] = 1;
        }
    }
}

// Function to detect cycle (DFS)
bool hasCycle(int TID, bool visited[], bool recStack[]){
    visited[TID] = true;
    recStack[TID] = true;

    for(int k=0; k&lt;MAX_T; k++){
        if(graph[TID][k]){
            if(!visited[k] &amp;&amp; hasCycle(k, visited, recStack))
                return true;
            else if(recStack[k])
                return true;
        }
    }
    recStack[TID] = false;
    return false;
}

// Check all transactions
bool serializable = true;
bool visited[MAX_T] = {0};
bool recStack[MAX_T] = {0};
for(int t=0; t&lt;MAX_T; t++){
    if(!visited[t] &amp;&amp; hasCycle(t, visited, recStack)){
        serializable = false;
        break;
    }
}

if(serializable)
    printf("Schedule is conflict-serializable\n");
else
    printf("Schedule is NOT conflict-serializable\n");
</code></pre>

<h2>7. Key Takeaways</h2>
<ul>
    <li>Precedence Graph = visual + algorithmic tool to check serializability</li>
    <li>Nodes = transactions, edges = conflicts</li>
    <li>Cycle → non-serializable, no cycle → serializable</li>
    <li>Useful for concurrent transaction management</li>
</ul>
<h1>DBMS Transaction Schedules: Recoverable, Cascadeless & Strict</h1>

<h2>1. Introduction</h2>
<p>In transaction management, schedules determine the order in which operations of transactions (read/write) are executed. Depending on how transactions interact, some schedules are recoverable, cascadeless, or strict. These definitions relate to avoiding inconsistencies and ensuring recoverability after failures.</p>
<p>We assume transactions T1, T2, … and operations R(x), W(x) (read/write item x).</p>

<h2>Recoverable Schedule (In Depth)</h2>

<h3>Definition</h3>
<p>A schedule is recoverable if:</p>
<p>Whenever a transaction Tj reads a value written by another transaction Ti, Ti commits before Tj commits.</p>
<p>Why? To avoid cascading aborts where Tj commits a value that depends on Ti, but then Ti fails.</p>

<h3>Key Points</h3>
<ul>
    <li>Only concerned about read-after-write dependencies between transactions.</li>
    <li>Uncommitted data can be read, but commit order matters.</li>
    <li>Ensures database can be recovered safely if a transaction aborts.</li>
</ul>

<h3>Example 1: Non-Recoverable Schedule</h3>
<pre>
Transactions:
T1: W(A)
T2: R(A)
T2: COMMIT
T1: COMMIT

Analysis:
T2 reads A before T1 commits.
T2 commits before T1.
If T1 aborts, T2 has committed wrong data → not recoverable.

Textual Diagram:

Time →
T1: | W(A) | COMMIT |
T2:       | R(A) | COMMIT |
Problem: T2 depends on uncommitted T1 value.
</pre>

<h3>Example 2: Recoverable Schedule</h3>
<pre>
Transactions:
T1: W(A)
T2: R(A)
T1: COMMIT
T2: COMMIT

Analysis:
T2 reads A before T1 commits, but T2 waits to commit until after T1 commits.
Safe: if T1 aborts, T2 can also abort → no inconsistent data.

Textual Diagram:

Time →
T1: | W(A) | COMMIT |
T2:       | R(A) | COMMIT |

✅ This schedule is recoverable.
</pre>

<h3>Rule of Thumb</h3>
<p>If a transaction reads from another transaction, it must commit after the one it read from. No restriction on writing uncommitted data (that’s cascades and strict schedules).</p>

<h3>Simple Code Simulation (C-like)</h3>
<pre>
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

int A = 0;

void T1() {
    printf("T1: W(A)=10\n");
    A = 10;
    sleep(1); // simulate transaction time
    printf("T1: COMMIT\n");
}

void T2() {
    printf("T2: R(A)=%d\n", A);
    sleep(2); // wait before commit
    printf("T2: COMMIT\n");
}

int main() {
    T1();  // T1 writes first
    T2();  // T2 reads and commits after T1
    return 0;
}
</pre>
<p>Here, T2 reads A after T1 writes but commits after T1 commits → recoverable schedule. Changing sleep order or commit order can simulate non-recoverable schedule.</p>

<h2>Cascadeless Schedule – In Depth</h2>

<h3>Definition</h3>
<p>A schedule is cascadeless if no transaction reads uncommitted data. In other words, a transaction T2 can read a value written by T1 only after T1 has committed.</p>

<h3>Key Point</h3>
<p>All cascadeless schedules are recoverable, but not all recoverable schedules are cascadeless.</p>

<h3>Why Cascadeless?</h3>
<ul>
    <li>Prevents domino effect in DBMS.</li>
    <li>Ensures system consistency with minimal rollback overhead.</li>
    <li>Makes recovery simpler because only the failed transaction needs undo.</li>
</ul>

<h3>Example</h3>
<pre>
Transactions:
T1: W(A)          // write A
T2: R(A)          // read A

Non-cascadeless schedule:
T1: W(A)
T2: R(A)
T2: COMMIT
T1: COMMIT

Problem: T2 reads uncommitted data from T1 → cascading abort ❌

Cascadeless schedule:
T1: W(A)
T1: COMMIT
T2: R(A)
T2: COMMIT

T2 reads only committed data from T1 ✅
</pre>

<h3>Textual Timeline Diagram</h3>
<pre>
Time →
T1: | W(A) | COMMIT |
T2:             | R(A) | COMMIT |
</pre>

<h3>Properties</h3>
<ul>
    <li>Eliminates cascading aborts.</li>
    <li>Ensures recoverability.</li>
    <li>Transactions read only committed values.</li>
    <li>Usually implemented in DBMS using Strict Two-Phase Locking (Strict 2PL).</li>
</ul>

<h3>Simple Simulation Code (C-like)</h3>
<pre>
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

int A = 0;

void T1() {
    printf("T1: W(A)=10\n");
    A = 10;
    sleep(1); // simulate processing
    printf("T1: COMMIT\n");
}

void T2() {
    sleep(2); // starts after T1 commit
    printf("T2: R(A)=%d\n", A);
    printf("T2: COMMIT\n");
}

int main() {
    printf("=== Cascadeless Schedule ===\n");
    T1();
    T2();
    return 0;
}
</pre>

<p>T2 reads only committed data from T1 → cascadeless.</p>

<h2>Strict Schedule – In Depth</h2>

<h3>Definition</h3>
<p>A schedule is strict if:</p>
<ul>
    <li>No transaction can read a data item until the last transaction that wrote it commits or aborts.</li>
    <li>No transaction can write a data item until the last transaction that wrote it commits or aborts.</li>
</ul>
<p>In simple terms: reads and writes are blocked until the previous writer finishes.</p>

<h3>Why strict?</h3>
<p>Makes recovery simple: if a crash happens, you can just undo uncommitted writes without worrying about cascading rollbacks. Guarantees both cascadeless and recoverable properties automatically.</p>

<h3>Properties</h3>
<table>
    <tr>
        <th>Property</th>
        <th>Strict Schedule</th>
    </tr>
    <tr>
        <td>Can read uncommitted data?</td>
        <td>No</td>
    </tr>
    <tr>
        <td>Can write on uncommitted data?</td>
        <td>No</td>
    </tr>
    <tr>
        <td>Cascadeless?</td>
        <td>Yes</td>
    </tr>
    <tr>
        <td>Recoverable?</td>
        <td>Yes</td>
    </tr>
    <tr>
        <td>Undo operations required?</td>
        <td>Simple</td>
    </tr>
</table>

<h3>Example</h3>
<pre>
Transactions:
T1: W(A)
T2: R(A)
T2: W(A)
T1: COMMIT
T2: COMMIT

Problem: T2 reads and writes before T1 commits → not strict

Strict Schedule Version:
T1: W(A)
T1: COMMIT
T2: R(A)
T2: W(A)
T2: COMMIT

T2 waits until T1 commits before reading or writing ✅
</pre>

<h3>Textual Timeline Diagram</h3>
<pre>
Time →
T1: | W(A) | COMMIT |
T2:             | R(A) | W(A) | COMMIT |
</pre>

<h3>Code Simulation (C-like)</h3>
<pre>
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

int A = 0; // shared data item

void T1() {
    printf("T1: W(A)=10\n");
    A = 10;         // write
    sleep(2);       // simulate transaction time
    printf("T1: COMMIT\n");
}

void T2() {
    sleep(3);       // wait until T1 commits
    printf("T2: R(A)=%d\n", A);
    A = 20;         // write
    printf("T2: W(A)=20\n");
    printf("T2: COMMIT\n");
}

int main() {
    printf("=== Strict Schedule Example ===\n");
    T1();
    T2();
    return 0;
}
</pre>

<p>Explanation: T2 waits until T1 finishes → ensures no uncommitted data is read or overwritten. Strict schedules make undo operations simple and prevent cascading aborts.</p>

<h2>5. Quick Comparison</h2>
<table>
    <tr>
        <th>Property</th>
        <th>Can Read Uncommitted Data?</th>
        <th>Commit Order Important?</th>
        <th>Notes</th>
    </tr>
    <tr>
        <td>Recoverable</td>
        <td>Yes</td>
        <td>Yes</td>
        <td>Must commit after the transaction it read from</td>
    </tr>
    <tr>
        <td>Cascadeless</td>
        <td>No</td>
        <td>Yes</td>
        <td>Reads only committed data</td>
    </tr>
    <tr>
        <td>Strict</td>
        <td>No</td>
        <td>Yes</td>
        <td>Writes blocked until previous writes committed; easiest to recover</td>
    </tr>
</table>
<h1>9. Concurrency Control</h1>

<p>Concurrency control ensures that multiple transactions executing simultaneously don’t violate database consistency. Without it, transactions could interfere, producing incorrect results.</p>

<h2>1. Lost Update Problem</h2>

<h3>Definition:</h3>
<p>Occurs when two transactions read the same data and update it simultaneously, and one update gets lost.</p>

<h3>Example:</h3>
<p>Initial balance of Account A: 1000</p>
<ul>
    <li>Transaction T1: Withdraw 200</li>
    <li>Transaction T2: Withdraw 100</li>
</ul>

<h3>Steps:</h3>
<table>
    <tr>
        <th>Step</th>
        <th>Transaction</th>
        <th>Operation</th>
        <th>Value of A</th>
    </tr>
    <tr>
        <td>1</td>
        <td>T1</td>
        <td>Read A</td>
        <td>1000</td>
    </tr>
    <tr>
        <td>2</td>
        <td>T2</td>
        <td>Read A</td>
        <td>1000</td>
    </tr>
    <tr>
        <td>3</td>
        <td>T1</td>
        <td>Write A = 1000 - 200 = 800</td>
        <td>800</td>
    </tr>
    <tr>
        <td>4</td>
        <td>T2</td>
        <td>Write A = 1000 - 100 = 900</td>
        <td>900</td>
    </tr>
</table>

<p><strong>Problem:</strong> T1’s withdrawal of 200 is lost. Final A = 900 instead of 700.</p>

<h3>Diagram:</h3>
<pre>
Time →
T1: R(A) → A=1000
T2: R(A) → A=1000
T1: W(A)=800
T2: W(A)=900
</pre>

<h3>Solution (Lock-based):</h3>
<pre>
-- Pseudo SQL using locks
BEGIN TRANSACTION;
SELECT balance FROM Account WHERE acc_no=101 FOR UPDATE; -- locks row
UPDATE Account SET balance = balance - 200 WHERE acc_no=101;
COMMIT;

BEGIN TRANSACTION;
SELECT balance FROM Account WHERE acc_no=101 FOR UPDATE;
UPDATE Account SET balance = balance - 100 WHERE acc_no=101;
COMMIT;
</pre>

<h2>2. Dirty Read Problem</h2>

<h3>Definition:</h3>
<p>Occurs when a transaction reads uncommitted changes from another transaction. If the other transaction rolls back, the read data is invalid.</p>

<h3>Example:</h3>
<p>Account A balance = 1000</p>
<ul>
    <li>Transaction T1: Withdraw 200 (not yet committed)</li>
    <li>Transaction T2: Reads balance</li>
</ul>

<h3>Steps:</h3>
<table>
    <tr>
        <th>Step</th>
        <th>Transaction</th>
        <th>Operation</th>
        <th>Value read</th>
    </tr>
    <tr>
        <td>1</td>
        <td>T1</td>
        <td>Update A = 800 (uncommitted)</td>
        <td>800</td>
    </tr>
    <tr>
        <td>2</td>
        <td>T2</td>
        <td>Read A</td>
        <td>800</td>
    </tr>
    <tr>
        <td>3</td>
        <td>T1</td>
        <td>Rollback</td>
        <td>1000</td>
    </tr>
</table>

<p><strong>Problem:</strong> T2 read a value (800) that was never officially in the database.</p>

<h3>Diagram:</h3>
<pre>
Time →
T1: W(A)=800 (uncommitted)
T2: R(A)=800
T1: ROLLBACK → A=1000
</pre>

<h3>Solution:</h3>
<p>Use read locks or isolation levels:</p>
<pre>
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;

-- T2 cannot read uncommitted data
SELECT balance FROM Account WHERE acc_no=101;
</pre>

<h2>3. Unrepeatable Read Problem</h2>

<h3>Definition:</h3>
<p>Occurs when a transaction reads the same row twice, but another transaction modifies it in between, causing inconsistency.</p>

<h3>Example:</h3>
<p>Account A balance = 1000</p>
<ul>
    <li>Transaction T1: Reads balance twice</li>
    <li>Transaction T2: Updates balance in between</li>
</ul>

<h3>Steps:</h3>
<table>
    <tr>
        <th>Step</th>
        <th>Transaction</th>
        <th>Operation</th>
        <th>Value read</th>
    </tr>
    <tr>
        <td>1</td>
        <td>T1</td>
        <td>Read A</td>
        <td>1000</td>
    </tr>
    <tr>
        <td>2</td>
        <td>T2</td>
        <td>Update A = 800</td>
        <td>800</td>
    </tr>
    <tr>
        <td>3</td>
        <td>T1</td>
        <td>Read A</td>
        <td>800</td>
    </tr>
</table>

<h3>Problem:</h3>
<p>T1 sees different values for the same row in one transaction.</p>

<h3>Diagram:</h3>
<pre>
Time →
T1: R(A)=1000
T2: W(A)=800
T1: R(A)=800
</pre>

<h3>Solution:</h3>
<p>Use repeatable read isolation level:</p>
<pre>
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;

-- T1 now sees the same value until commit
SELECT balance FROM Account WHERE acc_no=101;
</pre>

<h2>Summary Table of Problems</h2>
<table>
    <tr>
        <th>Problem</th>
        <th>What Happens</th>
        <th>How to Fix</th>
    </tr>
    <tr>
        <td>Lost Update</td>
        <td>Last write overwrites others</td>
        <td>Locks / 2PL</td>
    </tr>
    <tr>
        <td>Dirty Read</td>
        <td>Read uncommitted data</td>
        <td>Read Committed isolation</td>
    </tr>
    <tr>
        <td>Unrepeatable Read</td>
        <td>Row changes between reads</td>
        <td>Repeatable Read isolation</td>
    </tr>
</table>
<h1>1. Lock-Based Protocols</h1>

<h3>Definition:</h3>
<p>Lock-based protocols are a way to control concurrent access to database objects (like rows or tables) to ensure consistency and avoid problems like:</p>
<ul>
    <li>Lost updates</li>
    <li>Dirty reads</li>
    <li>Unrepeatable reads</li>
</ul>
<p>They work by locking the data items before accessing them.</p>

<h3>Types of Locks:</h3>
<ul>
    <li><strong>Shared Lock (S):</strong> Read-only access; Multiple transactions can hold shared locks on the same data item.</li>
    <li><strong>Exclusive Lock (X):</strong> Read & write access; Only one transaction can hold an exclusive lock on a data item at a time.</li>
</ul>

<h3>Lock Rules (2PL – Two Phase Locking):</h3>
<ul>
    <li><strong>Growing phase:</strong> Acquire all locks needed</li>
    <li><strong>Shrinking phase:</strong> Release locks</li>
</ul>
<p>This ensures serializability.</p>

<h3>Example Problem Solved:</h3>
<p>Imagine two transactions:</p>
<ul>
    <li>T1: Transfer $100 from A to B</li>
    <li>T2: Check balance of A</li>
</ul>
<p>Without locks, lost updates can occur:</p>
<pre>
T1 reads A = 500
T2 reads A = 500
T1 writes A = 400
T2 writes A = 500  <-- lost update!
</pre>
<p>With lock-based protocol, T1 locks A for writing → T2 waits until T1 releases. No lost updates occur.</p>

<h3>Textual Diagram Example:</h3>
<table>
    <tr>
        <th>Time</th>
        <th>Transaction</th>
        <th>Action</th>
        <th>Lock Status</th>
    </tr>
    <tr>
        <td>1</td>
        <td>T1</td>
        <td>Lock-X(A)</td>
        <td>A=X(T1)</td>
    </tr>
    <tr>
        <td>2</td>
        <td>T1</td>
        <td>Read/Write A</td>
        <td>A=X(T1)</td>
    </tr>
    <tr>
        <td>3</td>
        <td>T2</td>
        <td>Lock-S(A) (wait)</td>
        <td>A=X(T1) → T2 waits</td>
    </tr>
    <tr>
        <td>4</td>
        <td>T1</td>
        <td>Unlock(A)</td>
        <td>A=free</td>
    </tr>
    <tr>
        <td>5</td>
        <td>T2</td>
        <td>Lock-S(A)</td>
        <td>A=S(T2)</td>
    </tr>
    <tr>
        <td>6</td>
        <td>T2</td>
        <td>Read A</td>
        <td>A=S(T2)</td>
    </tr>
    <tr>
        <td>7</td>
        <td>T2</td>
        <td>Unlock(A)</td>
        <td>A=free</td>
    </tr>
</table>

<pre>
Time -->
T1: |--X(A)---Read/Write---Unlock--|
T2: |--------Wait-------S(A)---Read---Unlock--|
</pre>

<h3>C Code Simulation:</h3>
<pre>
#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;
#include &lt;unistd.h&gt;

int A = 500;
pthread_mutex_t lockA;

void* transaction1(void* arg) {
    pthread_mutex_lock(&lockA); // Exclusive lock
    printf("T1 locked A\n");
    A -= 100; 
    printf("T1 updated A: %d\n", A);
    sleep(2);
    pthread_mutex_unlock(&lockA);
    printf("T1 released A\n");
    return NULL;
}

void* transaction2(void* arg) {
    sleep(1);
    pthread_mutex_lock(&lockA);
    printf("T2 locked A\n");
    printf("T2 reads A: %d\n", A);
    pthread_mutex_unlock(&lockA);
    printf("T2 released A\n");
    return NULL;
}

int main() {
    pthread_t t1, t2;
    pthread_mutex_init(&lockA, NULL);

    pthread_create(&t1, NULL, transaction1, NULL);
    pthread_create(&t2, NULL, transaction2, NULL);

    pthread_join(t1, NULL);
    pthread_join(t2, NULL);

    pthread_mutex_destroy(&lockA);
    return 0;
}
</pre>

<h1>2. Two-Phase Locking (2PL)</h1>

<h3>Definition:</h3>
<p>Two-Phase Locking (2PL) is a protocol to ensure serializability of transactions in a DBMS. It divides a transaction's lifetime into:</p>
<ul>
    <li><strong>Growing Phase:</strong> Acquire locks (cannot release)</li>
    <li><strong>Shrinking Phase:</strong> Release locks (cannot acquire new locks)</li>
</ul>

<h3>Basic 2PL</h3>

<h3>Execution Example:</h3>
<table>
    <tr>
        <th>Time</th>
        <th>Transaction</th>
        <th>Action</th>
        <th>Lock Status</th>
    </tr>
    <tr><td>1</td><td>T1</td><td>Lock-X(A)</td><td>A=X(T1)</td></tr>
    <tr><td>2</td><td>T1</td><td>Read/Write A</td><td>A=X(T1)</td></tr>
    <tr><td>3</td><td>T1</td><td>Unlock A</td><td>A=free</td></tr>
    <tr><td>4</td><td>T2</td><td>Lock-S(A)</td><td>A=S(T2)</td></tr>
    <tr><td>5</td><td>T2</td><td>Read A</td><td>A=S(T2)</td></tr>
    <tr><td>6</td><td>T2</td><td>Unlock A</td><td>A=free</td></tr>
</table>

<pre>
Time -->
T1: |--X(A)--Read/Write--Unlock--|
T2: |----------Wait----------S(A)--Read--Unlock--|
</pre>

<h3>C Code Simulation of Basic 2PL:</h3>
<pre>
#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;
#include &lt;unistd.h&gt;

int A = 100;
pthread_mutex_t lockA;

void* T1(void* arg) {
    pthread_mutex_lock(&lockA);
    printf("T1 locked A\n");
    A += 50;
    printf("T1 updated A: %d\n", A);
    pthread_mutex_unlock(&lockA);
    printf("T1 released A\n");
    return NULL;
}

void* T2(void* arg) {
    sleep(1);
    pthread_mutex_lock(&lockA);
    printf("T2 locked A\n");
    printf("T2 reads A: %d\n", A);
    pthread_mutex_unlock(&lockA);
    printf("T2 released A\n");
    return NULL;
}

int main() {
    pthread_t t1, t2;
    pthread_mutex_init(&lockA, NULL);

    pthread_create(&t1, NULL, T1, NULL);
    pthread_create(&t2, NULL, T2, NULL);

    pthread_join(t1, NULL);
    pthread_join(t2, NULL);

    pthread_mutex_destroy(&lockA);
    return 0;
}
</pre>

<h3>Strict 2PL</h3>
<p>Variant where exclusive locks are held until commit to prevent cascading aborts.</p>

<table>
    <tr>
        <th>Feature</th>
        <th>2PL</th>
        <th>Strict 2PL</th>
    </tr>
    <tr><td>Lock release</td><td>After growing phase</td><td>Exclusive locks held until commit</td></tr>
    <tr><td>Cascading rollback</td><td>Possible</td><td>Prevented</td></tr>
    <tr><td>Serializability</td><td>Conflict serializable</td><td>Strict serializable</td></tr>
</table>

<h3>Example Schedule:</h3>
<table>
    <tr><th>Time</th><th>Transaction</th><th>Action</th><th>Lock Status</th></tr>
    <tr><td>1</td><td>T1</td><td>Lock-X(A)</td><td>A=X(T1)</td></tr>
    <tr><td>2</td><td>T1</td><td>Write A</td><td>A=X(T1)</td></tr>
    <tr><td>3</td><td>T2</td><td>Lock-S(A) (wait)</td><td>A=X(T1)</td></tr>
    <tr><td>4</td><td>T1</td><td>Commit</td><td>A still locked</td></tr>
    <tr><td>5</td><td>T1</td><td>Unlock A</td><td>A=free</td></tr>
    <tr><td>6</td><td>T2</td><td>Lock-S(A)</td><td>A=S(T2)</td></tr>
    <tr><td>7</td><td>T2</td><td>Read A</td><td>A=S(T2)</td></tr>
    <tr><td>8</td><td>T2</td><td>Unlock A</td><td>A=free</td></tr>
</table>

<pre>
Time -->
T1: |--X(A)--Write--Commit--Unlock--|
T2: |--------Wait--------------S(A)---Read--Unlock--|
</pre>

<h3>C Simulation of Strict 2PL:</h3>
<pre>
#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;
#include &lt;unistd.h&gt;

int A = 500;
pthread_mutex_t lockA;

void* T1(void* arg) {
    pthread_mutex_lock(&lockA);
    printf("T1 locked A\n");
    A += 100;
    printf("T1 updated A: %d\n", A);
    sleep(2);
    printf("T1 committed\n");
    pthread_mutex_unlock(&lockA);
    printf("T1 released A\n");
    return NULL;
}

void* T2(void* arg) {
    sleep(1);
    pthread_mutex_lock(&lockA);
    printf("T2 locked A\n");
    printf("T2 reads A: %d\n", A);
    pthread_mutex_unlock(&lockA);
    printf("T2 released A\n");
    return NULL;
}

int main() {
    pthread_t t1, t2;
    pthread_mutex_init(&lockA, NULL);

    pthread_create(&t1, NULL, T1, NULL);
    pthread_create(&t2, NULL, T2, NULL);

    pthread_join(t1, NULL);
    pthread_join(t2, NULL);

    pthread_mutex_destroy(&lockA);
    return 0;
}
</pre>

<h3>Rigorous 2PL (R2PL)</h3>
<p>Both shared and exclusive locks are held until commit, preventing cascading rollbacks and ensuring strict serializability.</p>

<h3>Example Schedule:</h3>
<table>
    <tr><th>Time</th><th>Transaction</th><th>Action</th><th>Lock Status</th></tr>
    <tr><td>1</td><td>T1</td><td>Lock-X(A)</td><td>A=X(T1)</td></tr>
    <tr><td>2</td><td>T1</td><td>Write A</td><td>A=X(T1)</td></tr>
    <tr><td>3</td><td>T1</td><td>Lock-X(B)</td><td>B=X(T1)</td></tr>
    <tr><td>4</td><td>T1</td><td>Write B</td><td>B=X(T1)</td></tr>
    <tr><td>5</td><td>T2</td><td>Lock-S(A) (wait)</td><td>A=X(T1), waits</td></tr>
    <tr><td>6</td><td>T2</td><td>Lock-S(B) (wait)</td><td>B=X(T1), waits</td></tr>
    <tr><td>7</td><td>T1</td><td>Commit & Unlock all</td><td>A/B free</td></tr>
    <tr><td>8</td><td>T2</td><td>Lock-S(A), Lock-S(B)</td><td>A/B=S(T2)</td></tr>
    <tr><td>9</td><td>T2</td><td>Read A, Read B</td><td></td></tr>
    <tr><td>10</td><td>T2</td><td>Unlock all</td><td></td></tr>
</table>

<pre>
Time -->
T1: |--X(A)--Write--X(B)--Write--Commit/Unlock--|
T2: |----------------Wait----------------S(A/B)--Read--Unlock--|
</pre>

<h3>C Simulation of Rigorous 2PL:</h3>
<pre>
#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;
#include &lt;unistd.h&gt;

int A = 100, B = 200;
pthread_mutex_t lockA, lockB;

void* T1(void* arg) {
    pthread_mutex_lock(&lockA);
    pthread_mutex_lock(&lockB);
    printf("T1 locked A and B\n");

    A += 50;
    B += 50;
    printf("T1 updated A=%d, B=%d\n", A, B);

    sleep(2);

    pthread_mutex_unlock(&lockA);
    pthread_mutex_unlock(&lockB);
    printf("T1 committed and released locks\n");
    return NULL;
}

void* T2(void* arg) {
    sleep(1);
    pthread_mutex_lock(&lockA);
    pthread_mutex_lock(&lockB);
    printf("T2 locked A and B\n");

    printf("T2 reads A=%d, B=%d\n", A, B);

    pthread_mutex_unlock(&lockA);
    pthread_mutex_unlock(&lockB);
    printf("T2 released locks\n");
    return NULL;
}

int main() {
    pthread_t t1, t2;
    pthread_mutex_init(&lockA, NULL);
    pthread_mutex_init(&lockB, NULL);

    pthread_create(&t1, NULL, T1, NULL);
    pthread_create(&t2, NULL, T2, NULL);

    pthread_join(t1, NULL);
    pthread_join(t2, NULL);

    pthread_mutex_destroy(&lockA);
    pthread_mutex_destroy(&lockB);
    return 0;
}
</pre>
<h1>1. Deadlock</h1>

<h3>Definition:</h3>
<p>A deadlock occurs in a database when two or more transactions are waiting indefinitely for each other to release resources. Essentially, no one can move forward.</p>
<p>Happens in concurrent transaction execution. Resources could be data items, tables, locks, semaphores, etc. Transactions in deadlock are blocked forever unless intervention occurs.</p>

<h3>Necessary Conditions for Deadlock (Coffman Conditions):</h3>
<p>All four must hold simultaneously:</p>
<ul>
    <li><strong>Mutual Exclusion:</strong> Only one transaction can hold a resource at a time.</li>
    <li><strong>Hold and Wait:</strong> A transaction holds at least one resource and waits for others.</li>
    <li><strong>No Preemption:</strong> Resources cannot be forcibly taken from a transaction.</li>
    <li><strong>Circular Wait:</strong> A circular chain of transactions exists where each waits for a resource held by the next.</li>
</ul>

<h3>Example Scenario:</h3>
<p>Transactions:</p>
<ul>
    <li>T1 wants to update row A then row B.</li>
    <li>T2 wants to update row B then row A.</li>
</ul>
<p>Step by Step Deadlock:</p>
<ol>
    <li>T1 locks A.</li>
    <li>T2 locks B.</li>
    <li>T1 tries to lock B → waits (locked by T2).</li>
    <li>T2 tries to lock A → waits (locked by T1).</li>
</ol>
<p>Now both are waiting forever → deadlock.</p>

<h3>Textual Diagram:</h3>
<pre>
     T1                T2
   ---------        ---------
   Lock(A)           Lock(B)
   Wait for B <----> Wait for A
</pre>

<h3>Deadlock Detection (Wait-for Graph):</h3>
<ul>
    <li>Nodes: Transactions</li>
    <li>Edge T1 → T2 if T1 waits for T2</li>
    <li>Deadlock exists if graph has a cycle</li>
</ul>
<p>Example Wait-for Graph:</p>
<pre>
T1 --> T2
T2 --> T1
</pre>
<p>Cycle detected → Deadlock.</p>

<h3>Simple Code Example in C (Simulating Deadlock):</h3>
<pre>
#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;
#include &lt;unistd.h&gt;

pthread_mutex_t resourceA = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t resourceB = PTHREAD_MUTEX_INITIALIZER;

void* transaction1(void* arg) {
    pthread_mutex_lock(&resourceA);
    printf("T1 locked Resource A\n");
    sleep(1); // Simulate some processing
    printf("T1 waiting for Resource B\n");
    pthread_mutex_lock(&resourceB); // Deadlock here
    printf("T1 locked Resource B\n");
    pthread_mutex_unlock(&resourceB);
    pthread_mutex_unlock(&resourceA);
    return NULL;
}

void* transaction2(void* arg) {
    pthread_mutex_lock(&resourceB);
    printf("T2 locked Resource B\n");
    sleep(1);
    printf("T2 waiting for Resource A\n");
    pthread_mutex_lock(&resourceA); // Deadlock here
    printf("T2 locked Resource A\n");
    pthread_mutex_unlock(&resourceA);
    pthread_mutex_unlock(&resourceB);
    return NULL;
}

int main() {
    pthread_t t1, t2;

    pthread_create(&t1, NULL, transaction1, NULL);
    pthread_create(&t2, NULL, transaction2, NULL);

    pthread_join(t1, NULL);
    pthread_join(t2, NULL);

    return 0;
}
</pre>

<p>What happens: T1 locks A, T2 locks B. Both then wait for each other → deadlock. Program will hang indefinitely unless killed.</p>

<h3>Deadlock Handling Techniques:</h3>
<ul>
    <li><strong>Deadlock Prevention:</strong> Avoid one of the Coffman conditions (e.g., acquire all locks at once, use strict order).</li>
    <li><strong>Deadlock Avoidance:</strong> Check resource allocation (Banker’s algorithm).</li>
    <li><strong>Deadlock Detection & Recovery:</strong>
        <ul>
            <li>Build a wait-for graph</li>
            <li>Detect cycles</li>
            <li>Abort one or more transactions to break the cycle</li>
        </ul>
    </li>
</ul>

<h1>2. Starvation</h1>

<h3>Definition:</h3>
<p>Starvation occurs in a concurrent system when a process waits indefinitely to get the necessary resources, even though other processes are progressing. Also called indefinite blocking.</p>
<p>Different from deadlock: in deadlock, processes wait for each other, forming a cycle; in starvation, a process is ignored indefinitely.</p>

<h3>Causes of Starvation:</h3>
<ul>
    <li>Priority scheduling: low-priority processes may never get CPU.</li>
    <li>Unfair resource allocation.</li>
    <li>Poor design in semaphore/mutex usage.</li>
</ul>

<h3>Example:</h3>
<p>Consider 3 processes P1, P2, P3 with priorities:</p>
<table>
    <tr>
        <th>Process</th>
        <th>Priority</th>
        <th>Status</th>
    </tr>
    <tr>
        <td>P1</td>
        <td>High (3)</td>
        <td>Running frequently</td>
    </tr>
    <tr>
        <td>P2</td>
        <td>Medium (2)</td>
        <td>Occasionally runs</td>
    </tr>
    <tr>
        <td>P3</td>
        <td>Low (1)</td>
        <td>Waiting indefinitely</td>
    </tr>
</table>

<h3>Textual Diagram:</h3>
<pre>
Time ---&gt;

[P1][P1][P2][P1][P1][P1][P2][P1] ...

P3: Waiting --------&gt; (never executes)
</pre>

<p>P3 keeps waiting because P1 keeps preempting it.</p>

<h3>Solution Approaches:</h3>
<ul>
    <li><strong>Aging:</strong> Gradually increase the priority of waiting processes so they eventually get CPU.</li>
    <li><strong>Fair scheduling:</strong> Ensure all processes get a turn.</li>
    <li>Avoid strict priority scheduling without a mechanism for low-priority processes.</li>
</ul>

<h3>Example Code in C (Using Priority Simulation):</h3>
<pre>
#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;
#include &lt;unistd.h&gt;

void *highPriority(void *arg) {
    while(1) {
        printf("High priority process running\n");
        usleep(100000); // simulate work
    }
}

void *lowPriority(void *arg) {
    while(1) {
        printf("Low priority process running\n");
        usleep(500000); // slower work
    }
}

int main() {
    pthread_t t1, t2;

    pthread_create(&t1, NULL, highPriority, NULL);
    pthread_create(&t2, NULL, lowPriority, NULL);

    pthread_join(t1, NULL);
    pthread_join(t2, NULL);

    return 0;
}
</pre>

<p>Explanation: highPriority keeps running often; lowPriority runs less frequently. If we had a strict priority scheduler, the low-priority thread might never execute, demonstrating starvation. In real OS, aging can adjust priorities to prevent starvation.</p>

<h1>Timestamp-Based Concurrency Control</h1>

<h2>1. Definition</h2>
<p>
A timestamp-based concurrency control protocol assigns a unique timestamp to each transaction when it starts. 
This timestamp determines the serial order of transactions. Older transactions get smaller timestamps. 
All read/write operations are checked against these timestamps to ensure conflict-serializability.
</p>

<h2>2. Key Concepts</h2>
<p>For each data item X, the DBMS maintains:</p>
<ul>
    <li><strong>TS_read(X)</strong> – the largest timestamp of any transaction that successfully read X.</li>
    <li><strong>TS_write(X)</strong> – the largest timestamp of any transaction that successfully wrote X.</li>
</ul>

<h3>Rules:</h3>
<ul>
    <li><strong>Read Rule:</strong> Transaction Ti can read X only if TS(Ti) &gt;= TS_write(X). Otherwise, Ti is aborted and restarted with the same timestamp.</li>
    <li><strong>Write Rule:</strong> Transaction Ti can write X only if TS(Ti) &gt;= TS_read(X) and TS(Ti) &gt;= TS_write(X). Otherwise, Ti is aborted and restarted.</li>
</ul>
<p>This ensures that older transactions are not overwritten by newer ones, preventing conflicts.</p>

<h2>3. Example</h2>
<table>
    <tr>
        <th>Transaction</th>
        <th>Operations</th>
    </tr>
    <tr>
        <td>T1</td>
        <td>R(X), W(X)</td>
    </tr>
    <tr>
        <td>T2</td>
        <td>R(X), W(X)</td>
    </tr>
</table>

<p>Timestamps:</p>
<ul>
    <li>TS(T1) = 1</li>
    <li>TS(T2) = 2</li>
</ul>

<p><strong>Execution Sequence:</strong> T1 → T2</p>
<ul>
    <li>T1 reads X: TS(T1) = 1 &gt;= TS_write(X)=0 → allowed, TS_read(X)=1</li>
    <li>T2 reads X: TS(T2) = 2 &gt;= TS_write(X)=0 → allowed, TS_read(X)=2</li>
    <li>T1 writes X: TS(T1)=1 &gt;= TS_read(X)=2? No → violates rule → T1 aborted</li>
    <li>T2 writes X: TS(T2)=2 &gt;= TS_read(X)=2 and TS(T2) &gt;= TS_write(X) → allowed</li>
</ul>
<p>So T1 must restart, maintaining serializability.</p>

<h2>4. Textual Diagram</h2>
<pre>
Timestamp(Ti)
--------------------
T1: 1
T2: 2

Data Item X:
TS_read(X)  TS_write(X)
   2           0

Execution Timeline:

T1: R(X) -------- X
T2: R(X) -------- X
T1: W(X) --- aborted
T2: W(X) -------- X
</pre>

<h2>5. Pseudo Code / Implementation in C</h2>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct {
    int ts; // timestamp of transaction
    char name[10];
} Transaction;

typedef struct {
    int ts_read;
    int ts_write;
    int value;
} DataItem;

int main() {
    DataItem X = {0, 0, 100}; // initial value 100
    Transaction T1 = {1, "T1"};
    Transaction T2 = {2, "T2"};

    // T1 reads X
    if(T1.ts &gt;= X.ts_write) {
        printf("%s reads X = %d\n", T1.name, X.value);
        X.ts_read = T1.ts;
    } else {
        printf("%s aborted on read\n", T1.name);
    }

    // T2 reads X
    if(T2.ts &gt;= X.ts_write) {
        printf("%s reads X = %d\n", T2.name, X.value);
        X.ts_read = T2.ts;
    } else {
        printf("%s aborted on read\n", T2.name);
    }

    // T1 tries to write X
    if(T1.ts &gt;= X.ts_read &amp;&amp; T1.ts &gt;= X.ts_write) {
        X.value += 10;
        X.ts_write = T1.ts;
        printf("%s writes X = %d\n", T1.name, X.value);
    } else {
        printf("%s aborted on write\n", T1.name);
    }

    // T2 tries to write X
    if(T2.ts &gt;= X.ts_read &amp;&amp; T2.ts &gt;= X.ts_write) {
        X.value += 20;
        X.ts_write = T2.ts;
        printf("%s writes X = %d\n", T2.name, X.value);
    } else {
        printf("%s aborted on write\n", T2.name);
    }

    return 0;
}
</pre>

<h3>Output:</h3>
<pre>
T1 reads X = 100
T2 reads X = 100
T1 aborted on write
T2 writes X = 120
</pre>

<h2>6. Advantages</h2>
<ul>
    <li>No deadlocks (unlike 2PL)</li>
    <li>Ensures conflict-serializability</li>
</ul>

<h2>7. Disadvantages</h2>
<ul>
    <li>Transactions may be aborted often in high contention</li>
    <li>Wasted work due to aborts</li>
</ul>
<h1>Optimistic Concurrency Control (OCC)</h1>

<h2>1. Definition</h2>
<p>Optimistic Concurrency Control is a non-locking concurrency control method. It assumes conflicts are rare and allows transactions to execute without locking resources. Before committing, the system checks if conflicts occurred; if so, the transaction may be rolled back.</p>

<h3>Key Idea:</h3>
<ul>
    <li>Work under the assumption that conflicts rarely happen.</li>
    <li>Detect conflicts at commit time instead of preventing them upfront.</li>
</ul>

<h2>2. Phases of OCC</h2>

<h3>Read Phase</h3>
<p>Transaction reads values from the database and makes updates in local memory (workspace). No locks are applied.</p>

<h3>Validation Phase</h3>
<p>Before committing, check whether the transaction conflicts with other transactions that committed in the meantime.</p>
<p>Three common validation strategies:</p>
<ul>
    <li><strong>Backward validation:</strong> Check against all previously committed transactions.</li>
    <li><strong>Forward validation:</strong> Check against transactions that will commit later.</li>
    <li><strong>Both:</strong> Combination.</li>
</ul>

<h3>Write Phase</h3>
<ul>
    <li>If validation succeeds → commit updates to the database.</li>
    <li>If validation fails → abort transaction and restart.</li>
</ul>

<h2>3. When to Use</h2>
<ul>
    <li>Low-conflict environments (e.g., read-heavy workloads).</li>
    <li>Systems where locking overhead would be expensive.</li>
</ul>

<h2>4. Example Scenario</h2>
<p>Assume two transactions T1 and T2 are running concurrently on a bank account A:</p>

<table>
    <tr><th>Account</th><th>Balance</th></tr>
    <tr><td>A</td><td>1000</td></tr>
</table>

<ul>
    <li>T1: Withdraw 200</li>
    <li>T2: Deposit 500</li>
</ul>

<h3>Step 1: Read Phase</h3>
<ul>
    <li>T1 reads balance 1000</li>
    <li>T2 reads balance 1000</li>
</ul>

<h3>Step 2: Update locally</h3>
<ul>
    <li>T1 computes 1000 - 200 = 800</li>
    <li>T2 computes 1000 + 500 = 1500</li>
</ul>

<h3>Step 3: Validation Phase</h3>
<ul>
    <li>T1 commits first → database balance becomes 800</li>
    <li>T2 validates → sees T1 committed and conflict occurs (depends on validation strategy)</li>
    <li>If conflict detected → T2 aborts and restarts</li>
    <li>Else → T2 commits → balance 1500 (conflict ignored if safe)</li>
</ul>

<h2>5. Textual Diagram</h2>
<pre>
Time -->
T1: Read(A=1000) ------> LocalUpdate(A=800) ------> Validation ------> Commit(A=800)
T2:       Read(A=1000) ------> LocalUpdate(A=1500) ------> Validation --X--> Abort
</pre>
<p>X indicates validation failure due to conflict.</p>

<h2>6. Pseudocode</h2>
<pre>
struct Transaction {
    int id;
    int local_balance;
    int read_version;
};

int db_balance = 1000;
int db_version = 0;

bool OCC_Commit(Transaction *T) {
    // Validation phase
    if (T->read_version != db_version) {
        printf("Transaction %d aborted due to conflict\n", T->id);
        return false; // abort
    }

    // Write phase
    db_balance = T->local_balance;
    db_version++; // increment version after commit
    printf("Transaction %d committed. New Balance: %d\n", T->id, db_balance);
    return true;
}

void main() {
    Transaction T1 = {1, 800, db_version}; // withdraw 200
    Transaction T2 = {2, 1500, db_version}; // deposit 500

    // Simulate commit T1 first
    OCC_Commit(&T1); // commits successfully
    OCC_Commit(&T2); // fails validation and aborts
}
</pre>

<h2>7. Key Points</h2>
<ul>
    <li>No locks → more concurrency.</li>
    <li>Best suited for read-heavy, low-conflict environments.</li>
    <li>Conflicts are detected late → may lead to transaction restarts.</li>
    <li>Compared to pessimistic concurrency control, OCC reduces overhead but can waste work if conflicts are frequent.</li>
</ul>

<h1>10. Recovery System</h1>

<h2>Types of Failures</h2>
<p>A recovery system ensures that the database remains consistent even in the presence of failures. Failures are inevitable, so recovery mechanisms are crucial to restore the database to a correct state.</p>

<h2>Transaction Failure in DBMS</h2>
<p>A transaction failure occurs when a single transaction cannot complete its execution successfully, even though the system is running fine. This could be due to logical errors, constraint violations, or runtime exceptions within that transaction.</p>

<h3>Causes:</h3>
<ul>
    <li>Logical errors: Mistakes in transaction code (e.g., division by zero, negative balance).</li>
    <li>Constraint violation: Violating primary key, foreign key, or check constraints.</li>
    <li>User abort: User manually aborts the transaction.</li>
    <li>Resource unavailability: Required data or resources not available at runtime.</li>
</ul>

<h3>Example:</h3>
<p>Bank transfer transaction:</p>
<table>
    <tr><th>Step</th><th>Action</th><th>DB State</th></tr>
    <tr><td>1</td><td>Read A.balance</td><td>A=500, B=300</td></tr>
    <tr><td>2</td><td>Read B.balance</td><td>A=500, B=300</td></tr>
    <tr><td>3</td><td>Update A.balance = A-100</td><td>A=400, B=300</td></tr>
    <tr><td>4</td><td>Update B.balance = B+100</td><td>System crashes (before updating)</td></tr>
</table>

<p>Problem: Only half the transaction completed → database inconsistency.</p>

<h3>Recovery from Transaction Failure:</h3>
<p>Use Undo operation to revert changes of the failed transaction. Transactions that did not commit must be rolled back.</p>

<h3>Textual Diagram:</h3>
<pre>
Before Transaction:
A=500, B=300

Transaction T1 starts
---------------------
Read A -> 500
Read B -> 300
Update A -> 400  <-- crash happens here
---------------------

After Recovery (Undo T1):
A=500, B=300
</pre>

<h3>Code Illustration (Undo Example in C):</h3>
<pre><code>
#include &lt;stdio.h&gt;

int main() {
    int A = 500, B = 300;
    int tempA = A, tempB = B; // Keep old values for rollback

    printf("Before Transaction: A=%d, B=%d\n", A, B);

    // Transaction T1
    A = A - 100; // Update A
    // Crash occurs before updating B
    printf("Crash happened!\n");

    // Undo Transaction T1
    A = tempA;
    B = tempB;

    printf("After Recovery (Undo): A=%d, B=%d\n", A, B);

    return 0;
}
</code></pre>

<h3>Output:</h3>
<pre>
Before Transaction: A=500, B=300
Crash happened!
After Recovery (Undo): A=500, B=300
</pre>

<h2>System Failure in DBMS</h2>
<p>A system failure occurs when the entire DBMS or the operating system crashes, usually while transactions are in progress. This is a big mess because everything in main memory (RAM) might be lost, even if the disk still has old data.</p>

<h3>Causes:</h3>
<ul>
    <li>Power failure</li>
    <li>OS crash</li>
    <li>DBMS software crash</li>
    <li>Hardware malfunction (not disk-specific)</li>
</ul>

<h3>Impact:</h3>
<ul>
    <li>Transactions in progress at the time of crash may leave the database in an inconsistent state.</li>
    <li>Committed transactions before the crash must not be lost (durability).</li>
    <li>Uncommitted transactions must be rolled back (atomicity).</li>
</ul>

<h3>Recovery Approach:</h3>
<p>System recovery usually involves log-based techniques:</p>
<ul>
    <li><strong>Write-Ahead Logging (WAL)</strong>: Before a transaction modifies the database, log the action to a persistent log.</li>
</ul>

<p>Logs contain:</p>
<ul>
    <li>Transaction ID</li>
    <li>Operation (update, insert, delete)</li>
    <li>Old value</li>
    <li>New value</li>
</ul>

<p><strong>Undo and Redo:</strong></p>
<ul>
    <li>Undo: Roll back transactions that didn’t commit before crash.</li>
    <li>Redo: Reapply changes of transactions that had committed but weren’t yet written to disk.</li>
</ul>

<h3>Example:</h3>
<p>Transaction T1: Transfer $100 from A to B</p>
<pre>
Step 1: Read A = 500
Step 2: A = A - 100 = 400
Step 3: Write A to disk
Step 4: Read B = 300
Step 5: B = B + 100 = 400

System crashes after Step 4.
</pre>

<p>Database state before recovery:</p>
<pre>
A = 400 (written), B = 300 (not updated)
</pre>

<p>Recovery using WAL:</p>
<ul>
    <li>Undo T1 → Restore A to 500, B remains 300</li>
    <li>Redo any committed transactions (none in this example)</li>
</ul>

<h3>Textual Diagram:</h3>
<pre>
Time --->

Start T1
   |
   v
Read A=500
   |
   v
Update A=400 ----> (Written to disk)
   |
   v
Read B=300
   |
   v
System Crash!
   |
   v
Recovery:
   Undo T1
   A restored to 500
   B remains 300
</pre>

<h3>Simple C-like Pseudocode for Recovery:</h3>
<pre><code>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

typedef struct {
    char trans[10];
    char action[10];
    int old_val;
    int new_val;
    int committed; // 0 = not committed, 1 = committed
} LogEntry;

void systemRecovery(LogEntry log[], int n) {
    printf("Recovery Process:\n");

    // Undo uncommitted transactions
    for(int i=n-1; i>=0; i--) {
        if(log[i].committed == 0 &amp;&amp; strcmp(log[i].action, "update")==0) {
            printf("Undo %s: restore value %d\n",
                   log[i].trans, log[i].old_val);
        }
    }

    // Redo committed transactions
    for(int i=0; i&lt;n; i++) {
        if(log[i].committed == 1 &amp;&amp; strcmp(log[i].action, "update")==0) {
            printf("Redo %s: apply value %d\n",
                   log[i].trans, log[i].new_val);
        }
    }
}

int main() {
    LogEntry log[2] = { {"T1","update",500,400,0},  // uncommitted
                        {"T2","update",300,500,1} }; // committed

    systemRecovery(log, 2);
    return 0;
}
</code></pre>

<h3>Output:</h3>
<pre>
Undo T1: restore value 500
Redo T2: apply value 500
</pre>

<h2>Media Failure in DBMS</h2>
<p><strong>Definition:</strong> A media failure occurs when the physical storage medium holding the database becomes unavailable or corrupted. Unlike a system crash, which is temporary, media failure usually involves permanent loss of data on the affected storage.</p>

<h3>Causes:</h3>
<ul>
    <li>Hard disk crash</li>
    <li>SSD corruption</li>
    <li>File system corruption</li>
    <li>Physical damage to storage media</li>
</ul>

<h3>Impact:</h3>
<ul>
    <li>Data cannot be read from the failed media.</li>
    <li>Database may lose committed transactions if backups are not available.</li>
    <li>Requires restoration from backup and possibly log replay.</li>
</ul>

<h3>Example:</h3>
<p>Banking database:</p>
<table>
    <tr><th>Accounts Table (on Disk 1)</th><th>Balance</th></tr>
    <tr><td>1001</td><td>5000</td></tr>
    <tr><td>1002</td><td>3000</td></tr>
</table>

<p>If Disk 1 crashes, the Accounts table is lost. The database must restore Accounts table from the latest backup.</p>

<h3>Recovery Approach:</h3>
<ol>
    <li>Restore from Backup: Identify the most recent full backup and load backup data onto a new disk.</li>
    <li>Redo Committed Transactions: Use the transaction log to redo all transactions committed after the backup.</li>
    <li>Undo Uncommitted Transactions: Any incomplete or uncommitted transactions are ignored.</li>
</ol>

<h3>Textual Diagram:</h3>
<pre>
Time Line:

[Backup] ---> [T1 committed] ---> [T2 committed] ---> [Disk Failure]

Recovery Steps:

1. Restore DB from Backup:
   Accounts:
   1001 | 4000
   1002 | 3000

2. Redo committed transactions using logs:
   Apply T1 -> Accounts 1001: 4000 -> 5000
   Apply T2 -> Accounts 1002: 3000 -> 3500

Recovered DB:
   Accounts:
   1001 | 5000
   1002 | 3500
</pre>

<h3>Simple Code Illustration of Media Failure Recovery:</h3>
<pre><code>
#include &lt;stdio.h&gt;

void restore_backup() {
    printf("Restoring database from backup...\n");
}

void redo_transaction(char *trans, int old_val, int new_val) {
    printf("Redoing %s: %d -> %d\n", trans, old_val, new_val);
}

int main() {
    printf("Media Failure detected!\n");

    // Step 1: Restore backup
    restore_backup();

    // Step 2: Redo committed transactions from log
    redo_transaction("T1", 4000, 5000);
    redo_transaction("T2", 3000, 3500);

    printf("Database recovered successfully.\n");
    return 0;
}
</code></pre>

<p><strong>Explanation:</strong> Media failure is about physical data loss, not temporary crashes. Backup + redo log is the standard recovery solution. Unlike transaction or system failure, undo is minimal because only uncommitted changes after the backup are lost.</p>
<h1>Log-Based Recovery</h1>

<h2>Definition</h2>
<p>
Log-based recovery is a technique used in DBMS to recover the database to a consistent state after a failure
(like system crash or power failure).
</p>

<p>
It works by keeping a log of all database changes before applying them to the database.
During recovery, the log is used to redo committed transactions and undo uncommitted transactions.
</p>

<h2>Key Concepts</h2>

<h3>Transaction Log</h3>
<p>A sequential record of all actions performed by transactions.</p>

<p><strong>Typical format:</strong></p>
<pre>
&lt;LSN, Transaction_ID, Operation, Data_Item, Old_Value, New_Value&gt;
</pre>

<ul>
    <li><strong>LSN</strong>: Log Sequence Number (unique, monotonically increasing)</li>
    <li><strong>Operation</strong>: UPDATE, INSERT, DELETE</li>
    <li><strong>Old_Value</strong>: Value before change (for undo)</li>
    <li><strong>New_Value</strong>: Value after change (for redo)</li>
</ul>

<h2>Types of Log-Based Recovery</h2>
<ul>
    <li><strong>UNDO/REDO Logging</strong>: Keeps both old and new values.</li>
    <li><strong>REDO-only Logging</strong>: Only for redo operations (used in deferred update).</li>
    <li><strong>UNDO-only Logging</strong>: Only for undo operations (used in immediate update).</li>
</ul>

<h2>Write-Ahead Logging (WAL)</h2>
<p><strong>Rule:</strong> Log must be written to stable storage before the database is updated.</p>
<p>
Ensures recovery is possible even if a crash occurs mid-update.
</p>

<h2>Steps in Log-Based Recovery</h2>
<p>Assume immediate update with undo/redo logging:</p>

<h3>Before Crash</h3>
<ul>
    <li>Log all operations before applying them to DB.</li>
</ul>

<h3>Crash Occurs</h3>

<h3>Recovery Phase</h3>
<ul>
    <li><strong>Analysis Phase</strong>: Identify which transactions are committed or uncommitted.</li>
    <li><strong>Redo Phase</strong>: Reapply operations of committed transactions.</li>
    <li><strong>Undo Phase</strong>: Rollback operations of uncommitted transactions using old values.</li>
</ul>

<h2>Example</h2>

<h3>Database</h3>
<table>
    <tr>
        <th>Account</th>
        <th>Balance</th>
    </tr>
    <tr>
        <td>A</td>
        <td>1000</td>
    </tr>
    <tr>
        <td>B</td>
        <td>2000</td>
    </tr>
</table>

<h3>Transactions</h3>
<ul>
    <li><strong>T1</strong>: Transfer 200 from A → B</li>
    <li><strong>T2</strong>: Deposit 500 into A</li>
</ul>

<h3>Log (Undo/Redo)</h3>
<table>
    <tr>
        <th>LSN</th>
        <th>Transaction</th>
        <th>Operation</th>
        <th>Data</th>
        <th>Old</th>
        <th>New</th>
    </tr>
    <tr>
        <td>1</td>
        <td>T1</td>
        <td>UPDATE</td>
        <td>A</td>
        <td>1000</td>
        <td>800</td>
    </tr>
    <tr>
        <td>2</td>
        <td>T1</td>
        <td>UPDATE</td>
        <td>B</td>
        <td>2000</td>
        <td>2200</td>
    </tr>
    <tr>
        <td>3</td>
        <td>T2</td>
        <td>UPDATE</td>
        <td>A</td>
        <td>800</td>
        <td>1300</td>
    </tr>
    <tr>
        <td>4</td>
        <td>T1</td>
        <td>COMMIT</td>
        <td></td>
        <td></td>
        <td></td>
    </tr>
</table>

<h3>Crash Scenario</h3>
<p>Crash happens after LSN 3, before T2 commits.</p>

<h3>Recovery Steps</h3>

<h4>Analysis Phase</h4>
<ul>
    <li>T1 committed (LSN 4 exists)</li>
    <li>T2 uncommitted (no COMMIT log)</li>
</ul>

<h4>Redo Phase (Redo committed transactions)</h4>
<ul>
    <li>A = 800</li>
    <li>B = 2200</li>
</ul>

<h4>Undo Phase (Undo uncommitted transactions)</h4>
<ul>
    <li>Rollback T2 updates</li>
    <li>A = 800 (undo 1300 → 800)</li>
</ul>

<h3>Final Database After Recovery</h3>
<table>
    <tr>
        <th>Account</th>
        <th>Balance</th>
    </tr>
    <tr>
        <td>A</td>
        <td>800</td>
    </tr>
    <tr>
        <td>B</td>
        <td>2200</td>
    </tr>
</table>

<h2>Textual Diagram</h2>
<pre>
Before Crash:

Transaction Logs:
LSN1: T1 updates A: 1000 -> 800
LSN2: T1 updates B: 2000 -> 2200
LSN3: T2 updates A: 800 -> 1300
LSN4: T1 COMMIT

Database:
A = 1300
B = 2200

Recovery:

Analysis:
Committed: T1
Uncommitted: T2

Redo T1:
A = 800
B = 2200

Undo T2:
A = 800

Final DB:
A = 800
B = 2200
</pre>

<p>
This is basically how any real DBMS like Oracle or SQL Server ensures you don’t lose committed
transactions even in a crash, thanks to log-based recovery.
</p>
</body>
</html>
